"use strict";
var e = require("fs"),
  t = require("events"),
  r = require("child_process"),
  n = require("path"),
  i = require("process"),
  a = require("tty"),
  s = require("util"),
  o = require("os");
function l(e) {
  return e && "object" == typeof e && "default" in e ? e : { default: e };
}
var u = l(e),
  c = l(t),
  p = l(r),
  h = l(n),
  d = l(i),
  f = l(a),
  y = l(s),
  m = l(o);
function v(e, t) {
  if (null == e) return {};
  var r,
    n,
    i = (function (e, t) {
      if (null == e) return {};
      var r,
        n,
        i = {},
        a = Object.keys(e);
      for (n = 0; n < a.length; n++)
        (r = a[n]), t.indexOf(r) >= 0 || (i[r] = e[r]);
      return i;
    })(e, t);
  if (Object.getOwnPropertySymbols) {
    var a = Object.getOwnPropertySymbols(e);
    for (n = 0; n < a.length; n++)
      (r = a[n]),
        t.indexOf(r) >= 0 ||
          (Object.prototype.propertyIsEnumerable.call(e, r) && (i[r] = e[r]));
  }
  return i;
}
function g(e) {
  return (
    (g =
      "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
        ? function (e) {
            return typeof e;
          }
        : function (e) {
            return e &&
              "function" == typeof Symbol &&
              e.constructor === Symbol &&
              e !== Symbol.prototype
              ? "symbol"
              : typeof e;
          }),
    g(e)
  );
}
function b(e) {
  var t = (function (e, t) {
    if ("object" !== g(e) || null === e) return e;
    var r = e[Symbol.toPrimitive];
    if (void 0 !== r) {
      var n = r.call(e, t || "default");
      if ("object" !== g(n)) return n;
      throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return ("string" === t ? String : Number)(e);
  })(e, "string");
  return "symbol" === g(t) ? t : String(t);
}
function T(e, t, r) {
  return (
    (t = b(t)) in e
      ? Object.defineProperty(e, t, {
          value: r,
          enumerable: !0,
          configurable: !0,
          writable: !0,
        })
      : (e[t] = r),
    e
  );
}
var S =
    "undefined" != typeof globalThis
      ? globalThis
      : "undefined" != typeof window
      ? window
      : "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : {},
  x = { exports: {} };
function E(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function P(e, t) {
  for (var r = 0; r < t.length; r++) {
    var n = t[r];
    (n.enumerable = n.enumerable || !1),
      (n.configurable = !0),
      "value" in n && (n.writable = !0),
      Object.defineProperty(e, b(n.key), n);
  }
}
function A(e, t, r) {
  return (
    t && P(e.prototype, t),
    r && P(e, r),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    e
  );
}
var k = {};
function w(e) {
  if (void 0 === e)
    throw new ReferenceError(
      "this hasn't been initialised - super() hasn't been called"
    );
  return e;
}
function C(e, t) {
  return (
    (C = Object.setPrototypeOf
      ? Object.setPrototypeOf.bind()
      : function (e, t) {
          return (e.__proto__ = t), e;
        }),
    C(e, t)
  );
}
function I(e, t) {
  if ("function" != typeof t && null !== t)
    throw new TypeError("Super expression must either be null or a function");
  (e.prototype = Object.create(t && t.prototype, {
    constructor: { value: e, writable: !0, configurable: !0 },
  })),
    Object.defineProperty(e, "prototype", { writable: !1 }),
    t && C(e, t);
}
function O(e, t) {
  if (t && ("object" === g(t) || "function" == typeof t)) return t;
  if (void 0 !== t)
    throw new TypeError(
      "Derived constructors may only return object or undefined"
    );
  return w(e);
}
function N(e) {
  return (
    (N = Object.setPrototypeOf
      ? Object.getPrototypeOf.bind()
      : function (e) {
          return e.__proto__ || Object.getPrototypeOf(e);
        }),
    N(e)
  );
}
function _(e, t, r) {
  return (
    (_ = (function () {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return (
          Boolean.prototype.valueOf.call(
            Reflect.construct(Boolean, [], function () {})
          ),
          !0
        );
      } catch (e) {
        return !1;
      }
    })()
      ? Reflect.construct.bind()
      : function (e, t, r) {
          var n = [null];
          n.push.apply(n, t);
          var i = new (Function.bind.apply(e, n))();
          return r && C(i, r.prototype), i;
        }),
    _.apply(null, arguments)
  );
}
function D(e) {
  var t = "function" == typeof Map ? new Map() : void 0;
  return (
    (D = function (e) {
      if (
        null === e ||
        ((r = e), -1 === Function.toString.call(r).indexOf("[native code]"))
      )
        return e;
      var r;
      if ("function" != typeof e)
        throw new TypeError(
          "Super expression must either be null or a function"
        );
      if (void 0 !== t) {
        if (t.has(e)) return t.get(e);
        t.set(e, n);
      }
      function n() {
        return _(e, arguments, N(this).constructor);
      }
      return (
        (n.prototype = Object.create(e.prototype, {
          constructor: {
            value: n,
            enumerable: !1,
            writable: !0,
            configurable: !0,
          },
        })),
        C(n, e)
      );
    }),
    D(e)
  );
}
var L = {};
function M(e) {
  var t = (function () {
    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
    if (Reflect.construct.sham) return !1;
    if ("function" == typeof Proxy) return !0;
    try {
      return (
        Boolean.prototype.valueOf.call(
          Reflect.construct(Boolean, [], function () {})
        ),
        !0
      );
    } catch (e) {
      return !1;
    }
  })();
  return function () {
    var r,
      n = N(e);
    if (t) {
      var i = N(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else r = n.apply(this, arguments);
    return O(this, r);
  };
}
var j = (function (e) {
    I(r, D(Error));
    var t = M(r);
    function r(e, n, i) {
      var a;
      return (
        E(this, r),
        (a = t.call(this, i)),
        Error.captureStackTrace(w(a), a.constructor),
        (a.name = a.constructor.name),
        (a.code = n),
        (a.exitCode = e),
        (a.nestedError = void 0),
        a
      );
    }
    return A(r);
  })(),
  F = (function (e) {
    I(r, j);
    var t = M(r);
    function r(e) {
      var n;
      return (
        E(this, r),
        (n = t.call(this, 1, "commander.invalidArgument", e)),
        Error.captureStackTrace(w(n), n.constructor),
        (n.name = n.constructor.name),
        n
      );
    }
    return A(r);
  })();
(L.CommanderError = j), (L.InvalidArgumentError = F);
var B = L.InvalidArgumentError,
  R = (function () {
    function e(t, r) {
      switch (
        (E(this, e),
        (this.description = r || ""),
        (this.variadic = !1),
        (this.parseArg = void 0),
        (this.defaultValue = void 0),
        (this.defaultValueDescription = void 0),
        (this.argChoices = void 0),
        t[0])
      ) {
        case "<":
          (this.required = !0), (this._name = t.slice(1, -1));
          break;
        case "[":
          (this.required = !1), (this._name = t.slice(1, -1));
          break;
        default:
          (this.required = !0), (this._name = t);
      }
      this._name.length > 3 &&
        "..." === this._name.slice(-3) &&
        ((this.variadic = !0), (this._name = this._name.slice(0, -3)));
    }
    return (
      A(e, [
        {
          key: "name",
          value: function () {
            return this._name;
          },
        },
        {
          key: "_concatValue",
          value: function (e, t) {
            return t !== this.defaultValue && Array.isArray(t)
              ? t.concat(e)
              : [e];
          },
        },
        {
          key: "default",
          value: function (e, t) {
            return (
              (this.defaultValue = e), (this.defaultValueDescription = t), this
            );
          },
        },
        {
          key: "argParser",
          value: function (e) {
            return (this.parseArg = e), this;
          },
        },
        {
          key: "choices",
          value: function (e) {
            var t = this;
            return (
              (this.argChoices = e.slice()),
              (this.parseArg = function (e, r) {
                if (!t.argChoices.includes(e))
                  throw new B(
                    "Allowed choices are ".concat(t.argChoices.join(", "), ".")
                  );
                return t.variadic ? t._concatValue(e, r) : e;
              }),
              this
            );
          },
        },
        {
          key: "argRequired",
          value: function () {
            return (this.required = !0), this;
          },
        },
        {
          key: "argOptional",
          value: function () {
            return (this.required = !1), this;
          },
        },
      ]),
      e
    );
  })();
function U(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function V(e, t) {
  if (e) {
    if ("string" == typeof e) return U(e, t);
    var r = Object.prototype.toString.call(e).slice(8, -1);
    return (
      "Object" === r && e.constructor && (r = e.constructor.name),
      "Map" === r || "Set" === r
        ? Array.from(e)
        : "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        ? U(e, t)
        : void 0
    );
  }
}
function K(e) {
  return (
    (function (e) {
      if (Array.isArray(e)) return U(e);
    })(e) ||
    (function (e) {
      if (
        ("undefined" != typeof Symbol && null != e[Symbol.iterator]) ||
        null != e["@@iterator"]
      )
        return Array.from(e);
    })(e) ||
    V(e) ||
    (function () {
      throw new TypeError(
        "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
      );
    })()
  );
}
function W(e, t, r, n, i, a, s) {
  try {
    var o = e[a](s),
      l = o.value;
  } catch (e) {
    return void r(e);
  }
  o.done ? t(l) : Promise.resolve(l).then(n, i);
}
function q(e) {
  return function () {
    var t = this,
      r = arguments;
    return new Promise(function (n, i) {
      var a = e.apply(t, r);
      function s(e) {
        W(a, n, i, s, o, "next", e);
      }
      function o(e) {
        W(a, n, i, s, o, "throw", e);
      }
      s(void 0);
    });
  };
}
function H(e, t) {
  return (
    (function (e) {
      if (Array.isArray(e)) return e;
    })(e) ||
    (function (e, t) {
      var r =
        null == e
          ? null
          : ("undefined" != typeof Symbol && e[Symbol.iterator]) ||
            e["@@iterator"];
      if (null != r) {
        var n,
          i,
          a,
          s,
          o = [],
          l = !0,
          u = !1;
        try {
          if (((a = (r = r.call(e)).next), 0 === t)) {
            if (Object(r) !== r) return;
            l = !1;
          } else
            for (
              ;
              !(l = (n = a.call(r)).done) && (o.push(n.value), o.length !== t);
              l = !0
            );
        } catch (e) {
          (u = !0), (i = e);
        } finally {
          try {
            if (!l && null != r.return && ((s = r.return()), Object(s) !== s))
              return;
          } finally {
            if (u) throw i;
          }
        }
        return o;
      }
    })(e, t) ||
    V(e, t) ||
    (function () {
      throw new TypeError(
        "Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
      );
    })()
  );
}
(k.Argument = R),
  (k.humanReadableArgName = function (e) {
    var t = e.name() + (!0 === e.variadic ? "..." : "");
    return e.required ? "<" + t + ">" : "[" + t + "]";
  });
var Y = { exports: {} },
  J = { exports: {} };
!(function (e) {
  function t(r) {
    return (
      (e.exports = t =
        "function" == typeof Symbol && "symbol" == typeof Symbol.iterator
          ? function (e) {
              return typeof e;
            }
          : function (e) {
              return e &&
                "function" == typeof Symbol &&
                e.constructor === Symbol &&
                e !== Symbol.prototype
                ? "symbol"
                : typeof e;
            }),
      (e.exports.__esModule = !0),
      (e.exports.default = e.exports),
      t(r)
    );
  }
  (e.exports = t), (e.exports.__esModule = !0), (e.exports.default = e.exports);
})(J),
  (function (e) {
    var t = J.exports.default;
    function r() {
      /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */
      (e.exports = r =
        function () {
          return n;
        }),
        (e.exports.__esModule = !0),
        (e.exports.default = e.exports);
      var n = {},
        i = Object.prototype,
        a = i.hasOwnProperty,
        s =
          Object.defineProperty ||
          function (e, t, r) {
            e[t] = r.value;
          },
        o = "function" == typeof Symbol ? Symbol : {},
        l = o.iterator || "@@iterator",
        u = o.asyncIterator || "@@asyncIterator",
        c = o.toStringTag || "@@toStringTag";
      function p(e, t, r) {
        return (
          Object.defineProperty(e, t, {
            value: r,
            enumerable: !0,
            configurable: !0,
            writable: !0,
          }),
          e[t]
        );
      }
      try {
        p({}, "");
      } catch (e) {
        p = function (e, t, r) {
          return (e[t] = r);
        };
      }
      function h(e, t, r, n) {
        var i = t && t.prototype instanceof y ? t : y,
          a = Object.create(i.prototype),
          o = new C(n || []);
        return s(a, "_invoke", { value: P(e, r, o) }), a;
      }
      function d(e, t, r) {
        try {
          return { type: "normal", arg: e.call(t, r) };
        } catch (e) {
          return { type: "throw", arg: e };
        }
      }
      n.wrap = h;
      var f = {};
      function y() {}
      function m() {}
      function v() {}
      var g = {};
      p(g, l, function () {
        return this;
      });
      var b = Object.getPrototypeOf,
        T = b && b(b(I([])));
      T && T !== i && a.call(T, l) && (g = T);
      var S = (v.prototype = y.prototype = Object.create(g));
      function x(e) {
        ["next", "throw", "return"].forEach(function (t) {
          p(e, t, function (e) {
            return this._invoke(t, e);
          });
        });
      }
      function E(e, r) {
        function n(i, s, o, l) {
          var u = d(e[i], e, s);
          if ("throw" !== u.type) {
            var c = u.arg,
              p = c.value;
            return p && "object" == t(p) && a.call(p, "__await")
              ? r.resolve(p.__await).then(
                  function (e) {
                    n("next", e, o, l);
                  },
                  function (e) {
                    n("throw", e, o, l);
                  }
                )
              : r.resolve(p).then(
                  function (e) {
                    (c.value = e), o(c);
                  },
                  function (e) {
                    return n("throw", e, o, l);
                  }
                );
          }
          l(u.arg);
        }
        var i;
        s(this, "_invoke", {
          value: function (e, t) {
            function a() {
              return new r(function (r, i) {
                n(e, t, r, i);
              });
            }
            return (i = i ? i.then(a, a) : a());
          },
        });
      }
      function P(e, t, r) {
        var n = "suspendedStart";
        return function (i, a) {
          if ("executing" === n)
            throw new Error("Generator is already running");
          if ("completed" === n) {
            if ("throw" === i) throw a;
            return O();
          }
          for (r.method = i, r.arg = a; ; ) {
            var s = r.delegate;
            if (s) {
              var o = A(s, r);
              if (o) {
                if (o === f) continue;
                return o;
              }
            }
            if ("next" === r.method) r.sent = r._sent = r.arg;
            else if ("throw" === r.method) {
              if ("suspendedStart" === n) throw ((n = "completed"), r.arg);
              r.dispatchException(r.arg);
            } else "return" === r.method && r.abrupt("return", r.arg);
            n = "executing";
            var l = d(e, t, r);
            if ("normal" === l.type) {
              if (((n = r.done ? "completed" : "suspendedYield"), l.arg === f))
                continue;
              return { value: l.arg, done: r.done };
            }
            "throw" === l.type &&
              ((n = "completed"), (r.method = "throw"), (r.arg = l.arg));
          }
        };
      }
      function A(e, t) {
        var r = t.method,
          n = e.iterator[r];
        if (void 0 === n)
          return (
            (t.delegate = null),
            ("throw" === r &&
              e.iterator.return &&
              ((t.method = "return"),
              (t.arg = void 0),
              A(e, t),
              "throw" === t.method)) ||
              ("return" !== r &&
                ((t.method = "throw"),
                (t.arg = new TypeError(
                  "The iterator does not provide a '" + r + "' method"
                )))),
            f
          );
        var i = d(n, e.iterator, t.arg);
        if ("throw" === i.type)
          return (t.method = "throw"), (t.arg = i.arg), (t.delegate = null), f;
        var a = i.arg;
        return a
          ? a.done
            ? ((t[e.resultName] = a.value),
              (t.next = e.nextLoc),
              "return" !== t.method && ((t.method = "next"), (t.arg = void 0)),
              (t.delegate = null),
              f)
            : a
          : ((t.method = "throw"),
            (t.arg = new TypeError("iterator result is not an object")),
            (t.delegate = null),
            f);
      }
      function k(e) {
        var t = { tryLoc: e[0] };
        1 in e && (t.catchLoc = e[1]),
          2 in e && ((t.finallyLoc = e[2]), (t.afterLoc = e[3])),
          this.tryEntries.push(t);
      }
      function w(e) {
        var t = e.completion || {};
        (t.type = "normal"), delete t.arg, (e.completion = t);
      }
      function C(e) {
        (this.tryEntries = [{ tryLoc: "root" }]),
          e.forEach(k, this),
          this.reset(!0);
      }
      function I(e) {
        if (e) {
          var t = e[l];
          if (t) return t.call(e);
          if ("function" == typeof e.next) return e;
          if (!isNaN(e.length)) {
            var r = -1,
              n = function t() {
                for (; ++r < e.length; )
                  if (a.call(e, r)) return (t.value = e[r]), (t.done = !1), t;
                return (t.value = void 0), (t.done = !0), t;
              };
            return (n.next = n);
          }
        }
        return { next: O };
      }
      function O() {
        return { value: void 0, done: !0 };
      }
      return (
        (m.prototype = v),
        s(S, "constructor", { value: v, configurable: !0 }),
        s(v, "constructor", { value: m, configurable: !0 }),
        (m.displayName = p(v, c, "GeneratorFunction")),
        (n.isGeneratorFunction = function (e) {
          var t = "function" == typeof e && e.constructor;
          return (
            !!t &&
            (t === m || "GeneratorFunction" === (t.displayName || t.name))
          );
        }),
        (n.mark = function (e) {
          return (
            Object.setPrototypeOf
              ? Object.setPrototypeOf(e, v)
              : ((e.__proto__ = v), p(e, c, "GeneratorFunction")),
            (e.prototype = Object.create(S)),
            e
          );
        }),
        (n.awrap = function (e) {
          return { __await: e };
        }),
        x(E.prototype),
        p(E.prototype, u, function () {
          return this;
        }),
        (n.AsyncIterator = E),
        (n.async = function (e, t, r, i, a) {
          void 0 === a && (a = Promise);
          var s = new E(h(e, t, r, i), a);
          return n.isGeneratorFunction(t)
            ? s
            : s.next().then(function (e) {
                return e.done ? e.value : s.next();
              });
        }),
        x(S),
        p(S, c, "Generator"),
        p(S, l, function () {
          return this;
        }),
        p(S, "toString", function () {
          return "[object Generator]";
        }),
        (n.keys = function (e) {
          var t = Object(e),
            r = [];
          for (var n in t) r.push(n);
          return (
            r.reverse(),
            function e() {
              for (; r.length; ) {
                var n = r.pop();
                if (n in t) return (e.value = n), (e.done = !1), e;
              }
              return (e.done = !0), e;
            }
          );
        }),
        (n.values = I),
        (C.prototype = {
          constructor: C,
          reset: function (e) {
            if (
              ((this.prev = 0),
              (this.next = 0),
              (this.sent = this._sent = void 0),
              (this.done = !1),
              (this.delegate = null),
              (this.method = "next"),
              (this.arg = void 0),
              this.tryEntries.forEach(w),
              !e)
            )
              for (var t in this)
                "t" === t.charAt(0) &&
                  a.call(this, t) &&
                  !isNaN(+t.slice(1)) &&
                  (this[t] = void 0);
          },
          stop: function () {
            this.done = !0;
            var e = this.tryEntries[0].completion;
            if ("throw" === e.type) throw e.arg;
            return this.rval;
          },
          dispatchException: function (e) {
            if (this.done) throw e;
            var t = this;
            function r(r, n) {
              return (
                (s.type = "throw"),
                (s.arg = e),
                (t.next = r),
                n && ((t.method = "next"), (t.arg = void 0)),
                !!n
              );
            }
            for (var n = this.tryEntries.length - 1; n >= 0; --n) {
              var i = this.tryEntries[n],
                s = i.completion;
              if ("root" === i.tryLoc) return r("end");
              if (i.tryLoc <= this.prev) {
                var o = a.call(i, "catchLoc"),
                  l = a.call(i, "finallyLoc");
                if (o && l) {
                  if (this.prev < i.catchLoc) return r(i.catchLoc, !0);
                  if (this.prev < i.finallyLoc) return r(i.finallyLoc);
                } else if (o) {
                  if (this.prev < i.catchLoc) return r(i.catchLoc, !0);
                } else {
                  if (!l)
                    throw new Error("try statement without catch or finally");
                  if (this.prev < i.finallyLoc) return r(i.finallyLoc);
                }
              }
            }
          },
          abrupt: function (e, t) {
            for (var r = this.tryEntries.length - 1; r >= 0; --r) {
              var n = this.tryEntries[r];
              if (
                n.tryLoc <= this.prev &&
                a.call(n, "finallyLoc") &&
                this.prev < n.finallyLoc
              ) {
                var i = n;
                break;
              }
            }
            i &&
              ("break" === e || "continue" === e) &&
              i.tryLoc <= t &&
              t <= i.finallyLoc &&
              (i = null);
            var s = i ? i.completion : {};
            return (
              (s.type = e),
              (s.arg = t),
              i
                ? ((this.method = "next"), (this.next = i.finallyLoc), f)
                : this.complete(s)
            );
          },
          complete: function (e, t) {
            if ("throw" === e.type) throw e.arg;
            return (
              "break" === e.type || "continue" === e.type
                ? (this.next = e.arg)
                : "return" === e.type
                ? ((this.rval = this.arg = e.arg),
                  (this.method = "return"),
                  (this.next = "end"))
                : "normal" === e.type && t && (this.next = t),
              f
            );
          },
          finish: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var r = this.tryEntries[t];
              if (r.finallyLoc === e)
                return this.complete(r.completion, r.afterLoc), w(r), f;
            }
          },
          catch: function (e) {
            for (var t = this.tryEntries.length - 1; t >= 0; --t) {
              var r = this.tryEntries[t];
              if (r.tryLoc === e) {
                var n = r.completion;
                if ("throw" === n.type) {
                  var i = n.arg;
                  w(r);
                }
                return i;
              }
            }
            throw new Error("illegal catch attempt");
          },
          delegateYield: function (e, t, r) {
            return (
              (this.delegate = { iterator: I(e), resultName: t, nextLoc: r }),
              "next" === this.method && (this.arg = void 0),
              f
            );
          },
        }),
        n
      );
    }
    (e.exports = r),
      (e.exports.__esModule = !0),
      (e.exports.default = e.exports);
  })(Y);
var X = Y.exports(),
  G = X;
try {
  regeneratorRuntime = X;
} catch (e) {
  "object" === ("undefined" == typeof globalThis ? "undefined" : g(globalThis))
    ? (globalThis.regeneratorRuntime = X)
    : Function("r", "regeneratorRuntime = r")(X);
}
var z = {},
  $ = {},
  Q = k.humanReadableArgName,
  Z = (function () {
    function e() {
      E(this, e),
        (this.helpWidth = void 0),
        (this.sortSubcommands = !1),
        (this.sortOptions = !1),
        (this.showGlobalOptions = !1);
    }
    return (
      A(e, [
        {
          key: "visibleCommands",
          value: function (e) {
            var t = e.commands.filter(function (e) {
              return !e._hidden;
            });
            if (e._hasImplicitHelpCommand()) {
              var r = H(e._helpCommandnameAndArgs.match(/([^ ]+) *(.*)/), 3),
                n = r[1],
                i = r[2],
                a = e.createCommand(n).helpOption(!1);
              a.description(e._helpCommandDescription),
                i && a.arguments(i),
                t.push(a);
            }
            return (
              this.sortSubcommands &&
                t.sort(function (e, t) {
                  return e.name().localeCompare(t.name());
                }),
              t
            );
          },
        },
        {
          key: "compareOptions",
          value: function (e, t) {
            var r = function (e) {
              return e.short
                ? e.short.replace(/^-/, "")
                : e.long.replace(/^--/, "");
            };
            return r(e).localeCompare(r(t));
          },
        },
        {
          key: "visibleOptions",
          value: function (e) {
            var t,
              r = e.options.filter(function (e) {
                return !e.hidden;
              }),
              n =
                e._hasHelpOption &&
                e._helpShortFlag &&
                !e._findOption(e._helpShortFlag),
              i = e._hasHelpOption && !e._findOption(e._helpLongFlag);
            (n || i) &&
              ((t = n
                ? i
                  ? e.createOption(e._helpFlags, e._helpDescription)
                  : e.createOption(e._helpShortFlag, e._helpDescription)
                : e.createOption(e._helpLongFlag, e._helpDescription)),
              r.push(t));
            return this.sortOptions && r.sort(this.compareOptions), r;
          },
        },
        {
          key: "visibleGlobalOptions",
          value: function (e) {
            if (!this.showGlobalOptions) return [];
            for (var t = [], r = e.parent; r; r = r.parent) {
              var n = r.options.filter(function (e) {
                return !e.hidden;
              });
              t.push.apply(t, K(n));
            }
            return this.sortOptions && t.sort(this.compareOptions), t;
          },
        },
        {
          key: "visibleArguments",
          value: function (e) {
            return (
              e._argsDescription &&
                e._args.forEach(function (t) {
                  t.description =
                    t.description || e._argsDescription[t.name()] || "";
                }),
              e._args.find(function (e) {
                return e.description;
              })
                ? e._args
                : []
            );
          },
        },
        {
          key: "subcommandTerm",
          value: function (e) {
            var t = e._args
              .map(function (e) {
                return Q(e);
              })
              .join(" ");
            return (
              e._name +
              (e._aliases[0] ? "|" + e._aliases[0] : "") +
              (e.options.length ? " [options]" : "") +
              (t ? " " + t : "")
            );
          },
        },
        {
          key: "optionTerm",
          value: function (e) {
            return e.flags;
          },
        },
        {
          key: "argumentTerm",
          value: function (e) {
            return e.name();
          },
        },
        {
          key: "longestSubcommandTermLength",
          value: function (e, t) {
            return t.visibleCommands(e).reduce(function (e, r) {
              return Math.max(e, t.subcommandTerm(r).length);
            }, 0);
          },
        },
        {
          key: "longestOptionTermLength",
          value: function (e, t) {
            return t.visibleOptions(e).reduce(function (e, r) {
              return Math.max(e, t.optionTerm(r).length);
            }, 0);
          },
        },
        {
          key: "longestGlobalOptionTermLength",
          value: function (e, t) {
            return t.visibleGlobalOptions(e).reduce(function (e, r) {
              return Math.max(e, t.optionTerm(r).length);
            }, 0);
          },
        },
        {
          key: "longestArgumentTermLength",
          value: function (e, t) {
            return t.visibleArguments(e).reduce(function (e, r) {
              return Math.max(e, t.argumentTerm(r).length);
            }, 0);
          },
        },
        {
          key: "commandUsage",
          value: function (e) {
            var t = e._name;
            e._aliases[0] && (t = t + "|" + e._aliases[0]);
            for (var r = "", n = e.parent; n; n = n.parent)
              r = n.name() + " " + r;
            return r + t + " " + e.usage();
          },
        },
        {
          key: "commandDescription",
          value: function (e) {
            return e.description();
          },
        },
        {
          key: "subcommandDescription",
          value: function (e) {
            return e.summary() || e.description();
          },
        },
        {
          key: "optionDescription",
          value: function (e) {
            var t = [];
            (e.argChoices &&
              t.push(
                "choices: ".concat(
                  e.argChoices
                    .map(function (e) {
                      return JSON.stringify(e);
                    })
                    .join(", ")
                )
              ),
            void 0 !== e.defaultValue) &&
              (e.required ||
                e.optional ||
                (e.isBoolean() && "boolean" == typeof e.defaultValue)) &&
              t.push(
                "default: ".concat(
                  e.defaultValueDescription || JSON.stringify(e.defaultValue)
                )
              );
            return (
              void 0 !== e.presetArg &&
                e.optional &&
                t.push("preset: ".concat(JSON.stringify(e.presetArg))),
              void 0 !== e.envVar && t.push("env: ".concat(e.envVar)),
              t.length > 0
                ? "".concat(e.description, " (").concat(t.join(", "), ")")
                : e.description
            );
          },
        },
        {
          key: "argumentDescription",
          value: function (e) {
            var t = [];
            if (
              (e.argChoices &&
                t.push(
                  "choices: ".concat(
                    e.argChoices
                      .map(function (e) {
                        return JSON.stringify(e);
                      })
                      .join(", ")
                  )
                ),
              void 0 !== e.defaultValue &&
                t.push(
                  "default: ".concat(
                    e.defaultValueDescription || JSON.stringify(e.defaultValue)
                  )
                ),
              t.length > 0)
            ) {
              var r = "(".concat(t.join(", "), ")");
              return e.description
                ? "".concat(e.description, " ").concat(r)
                : r;
            }
            return e.description;
          },
        },
        {
          key: "formatHelp",
          value: function (e, t) {
            var r = t.padWidth(e, t),
              n = t.helpWidth || 80;
            function i(e, i) {
              if (i) {
                var a = "".concat(e.padEnd(r + 2)).concat(i);
                return t.wrap(a, n - 2, r + 2);
              }
              return e;
            }
            function a(e) {
              return e.join("\n").replace(/^/gm, " ".repeat(2));
            }
            var s = ["Usage: ".concat(t.commandUsage(e)), ""],
              o = t.commandDescription(e);
            o.length > 0 && (s = s.concat([o, ""]));
            var l = t.visibleArguments(e).map(function (e) {
              return i(t.argumentTerm(e), t.argumentDescription(e));
            });
            l.length > 0 && (s = s.concat(["Arguments:", a(l), ""]));
            var u = t.visibleOptions(e).map(function (e) {
              return i(t.optionTerm(e), t.optionDescription(e));
            });
            if (
              (u.length > 0 && (s = s.concat(["Options:", a(u), ""])),
              this.showGlobalOptions)
            ) {
              var c = t.visibleGlobalOptions(e).map(function (e) {
                return i(t.optionTerm(e), t.optionDescription(e));
              });
              c.length > 0 && (s = s.concat(["Global Options:", a(c), ""]));
            }
            var p = t.visibleCommands(e).map(function (e) {
              return i(t.subcommandTerm(e), t.subcommandDescription(e));
            });
            return (
              p.length > 0 && (s = s.concat(["Commands:", a(p), ""])),
              s.join("\n")
            );
          },
        },
        {
          key: "padWidth",
          value: function (e, t) {
            return Math.max(
              t.longestOptionTermLength(e, t),
              t.longestGlobalOptionTermLength(e, t),
              t.longestSubcommandTermLength(e, t),
              t.longestArgumentTermLength(e, t)
            );
          },
        },
        {
          key: "wrap",
          value: function (e, t, r) {
            var n =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : 40;
            if (e.match(/[\n]\s+/)) return e;
            var i = t - r;
            if (i < n) return e;
            var a = e.slice(0, r),
              s = e.slice(r),
              o = " ".repeat(r),
              l = new RegExp(
                ".{1," + (i - 1) + "}([\\s​]|$)|[^\\s​]+?([\\s​]|$)",
                "g"
              );
            return (
              a +
              (s.match(l) || [])
                .map(function (e, t) {
                  return (
                    "\n" === e.slice(-1) && (e = e.slice(0, e.length - 1)),
                    (t > 0 ? o : "") + e.trimRight()
                  );
                })
                .join("\n")
            );
          },
        },
      ]),
      e
    );
  })();
$.Help = Z;
var ee = {},
  te = L.InvalidArgumentError,
  re = (function () {
    function e(t, r) {
      E(this, e),
        (this.flags = t),
        (this.description = r || ""),
        (this.required = t.includes("<")),
        (this.optional = t.includes("[")),
        (this.variadic = /\w\.\.\.[>\]]$/.test(t)),
        (this.mandatory = !1);
      var n = ie(t);
      (this.short = n.shortFlag),
        (this.long = n.longFlag),
        (this.negate = !1),
        this.long && (this.negate = this.long.startsWith("--no-")),
        (this.defaultValue = void 0),
        (this.defaultValueDescription = void 0),
        (this.presetArg = void 0),
        (this.envVar = void 0),
        (this.parseArg = void 0),
        (this.hidden = !1),
        (this.argChoices = void 0),
        (this.conflictsWith = []),
        (this.implied = void 0);
    }
    return (
      A(e, [
        {
          key: "default",
          value: function (e, t) {
            return (
              (this.defaultValue = e), (this.defaultValueDescription = t), this
            );
          },
        },
        {
          key: "preset",
          value: function (e) {
            return (this.presetArg = e), this;
          },
        },
        {
          key: "conflicts",
          value: function (e) {
            return (this.conflictsWith = this.conflictsWith.concat(e)), this;
          },
        },
        {
          key: "implies",
          value: function (e) {
            return (this.implied = Object.assign(this.implied || {}, e)), this;
          },
        },
        {
          key: "env",
          value: function (e) {
            return (this.envVar = e), this;
          },
        },
        {
          key: "argParser",
          value: function (e) {
            return (this.parseArg = e), this;
          },
        },
        {
          key: "makeOptionMandatory",
          value: function () {
            var e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            return (this.mandatory = !!e), this;
          },
        },
        {
          key: "hideHelp",
          value: function () {
            var e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            return (this.hidden = !!e), this;
          },
        },
        {
          key: "_concatValue",
          value: function (e, t) {
            return t !== this.defaultValue && Array.isArray(t)
              ? t.concat(e)
              : [e];
          },
        },
        {
          key: "choices",
          value: function (e) {
            var t = this;
            return (
              (this.argChoices = e.slice()),
              (this.parseArg = function (e, r) {
                if (!t.argChoices.includes(e))
                  throw new te(
                    "Allowed choices are ".concat(t.argChoices.join(", "), ".")
                  );
                return t.variadic ? t._concatValue(e, r) : e;
              }),
              this
            );
          },
        },
        {
          key: "name",
          value: function () {
            return this.long
              ? this.long.replace(/^--/, "")
              : this.short.replace(/^-/, "");
          },
        },
        {
          key: "attributeName",
          value: function () {
            return this.name()
              .replace(/^no-/, "")
              .split("-")
              .reduce(function (e, t) {
                return e + t[0].toUpperCase() + t.slice(1);
              });
          },
        },
        {
          key: "is",
          value: function (e) {
            return this.short === e || this.long === e;
          },
        },
        {
          key: "isBoolean",
          value: function () {
            return !this.required && !this.optional && !this.negate;
          },
        },
      ]),
      e
    );
  })(),
  ne = (function () {
    function e(t) {
      var r = this;
      E(this, e),
        (this.positiveOptions = new Map()),
        (this.negativeOptions = new Map()),
        (this.dualOptions = new Set()),
        t.forEach(function (e) {
          e.negate
            ? r.negativeOptions.set(e.attributeName(), e)
            : r.positiveOptions.set(e.attributeName(), e);
        }),
        this.negativeOptions.forEach(function (e, t) {
          r.positiveOptions.has(t) && r.dualOptions.add(t);
        });
    }
    return (
      A(e, [
        {
          key: "valueFromOption",
          value: function (e, t) {
            var r = t.attributeName();
            if (!this.dualOptions.has(r)) return !0;
            var n = this.negativeOptions.get(r).presetArg,
              i = void 0 !== n && n;
            return t.negate === (i === e);
          },
        },
      ]),
      e
    );
  })();
function ie(e) {
  var t,
    r,
    n = e.split(/[ |,]+/);
  return (
    n.length > 1 && !/^[[<]/.test(n[1]) && (t = n.shift()),
    (r = n.shift()),
    !t && /^-[^-]$/.test(r) && ((t = r), (r = void 0)),
    { shortFlag: t, longFlag: r }
  );
}
(ee.Option = re), (ee.splitOptionFlags = ie), (ee.DualOptions = ne);
var ae = {},
  se = 3;
function oe(e) {
  var t = (function () {
    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
    if (Reflect.construct.sham) return !1;
    if ("function" == typeof Proxy) return !0;
    try {
      return (
        Boolean.prototype.valueOf.call(
          Reflect.construct(Boolean, [], function () {})
        ),
        !0
      );
    } catch (e) {
      return !1;
    }
  })();
  return function () {
    var r,
      n = N(e);
    if (t) {
      var i = N(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else r = n.apply(this, arguments);
    return O(this, r);
  };
}
ae.suggestSimilar = function (e, t) {
  if (!t || 0 === t.length) return "";
  t = Array.from(new Set(t));
  var r = e.startsWith("--");
  r &&
    ((e = e.slice(2)),
    (t = t.map(function (e) {
      return e.slice(2);
    })));
  var n = [],
    i = se;
  return (
    t.forEach(function (t) {
      if (!(t.length <= 1)) {
        var r = (function (e, t) {
            if (Math.abs(e.length - t.length) > se)
              return Math.max(e.length, t.length);
            for (var r = [], n = 0; n <= e.length; n++) r[n] = [n];
            for (var i = 0; i <= t.length; i++) r[0][i] = i;
            for (var a = 1; a <= t.length; a++)
              for (var s = 1; s <= e.length; s++) {
                var o = 1;
                (o = e[s - 1] === t[a - 1] ? 0 : 1),
                  (r[s][a] = Math.min(
                    r[s - 1][a] + 1,
                    r[s][a - 1] + 1,
                    r[s - 1][a - 1] + o
                  )),
                  s > 1 &&
                    a > 1 &&
                    e[s - 1] === t[a - 2] &&
                    e[s - 2] === t[a - 1] &&
                    (r[s][a] = Math.min(r[s][a], r[s - 2][a - 2] + 1));
              }
            return r[e.length][t.length];
          })(e, t),
          a = Math.max(e.length, t.length);
        (a - r) / a > 0.4 &&
          (r < i ? ((i = r), (n = [t])) : r === i && n.push(t));
      }
    }),
    n.sort(function (e, t) {
      return e.localeCompare(t);
    }),
    r &&
      (n = n.map(function (e) {
        return "--".concat(e);
      })),
    n.length > 1
      ? "\n(Did you mean one of ".concat(n.join(", "), "?)")
      : 1 === n.length
      ? "\n(Did you mean ".concat(n[0], "?)")
      : ""
  );
};
var le = c.default.EventEmitter,
  ue = p.default,
  ce = h.default,
  pe = u.default,
  he = d.default,
  de = k.Argument,
  fe = k.humanReadableArgName,
  ye = L.CommanderError,
  me = $.Help,
  ve = ee.Option,
  ge = ee.splitOptionFlags,
  be = ee.DualOptions,
  Te = ae.suggestSimilar,
  Se = (function (e) {
    I(n, le);
    var t,
      r = oe(n);
    function n(e) {
      var t;
      return (
        E(this, n),
        ((t = r.call(this)).commands = []),
        (t.options = []),
        (t.parent = null),
        (t._allowUnknownOption = !1),
        (t._allowExcessArguments = !0),
        (t._args = []),
        (t.args = []),
        (t.rawArgs = []),
        (t.processedArgs = []),
        (t._scriptPath = null),
        (t._name = e || ""),
        (t._optionValues = {}),
        (t._optionValueSources = {}),
        (t._storeOptionsAsProperties = !1),
        (t._actionHandler = null),
        (t._executableHandler = !1),
        (t._executableFile = null),
        (t._executableDir = null),
        (t._defaultCommandName = null),
        (t._exitCallback = null),
        (t._aliases = []),
        (t._combineFlagAndOptionalValue = !0),
        (t._description = ""),
        (t._summary = ""),
        (t._argsDescription = void 0),
        (t._enablePositionalOptions = !1),
        (t._passThroughOptions = !1),
        (t._lifeCycleHooks = {}),
        (t._showHelpAfterError = !1),
        (t._showSuggestionAfterError = !0),
        (t._outputConfiguration = {
          writeOut: function (e) {
            return he.stdout.write(e);
          },
          writeErr: function (e) {
            return he.stderr.write(e);
          },
          getOutHelpWidth: function () {
            return he.stdout.isTTY ? he.stdout.columns : void 0;
          },
          getErrHelpWidth: function () {
            return he.stderr.isTTY ? he.stderr.columns : void 0;
          },
          outputError: function (e, t) {
            return t(e);
          },
        }),
        (t._hidden = !1),
        (t._hasHelpOption = !0),
        (t._helpFlags = "-h, --help"),
        (t._helpDescription = "display help for command"),
        (t._helpShortFlag = "-h"),
        (t._helpLongFlag = "--help"),
        (t._addImplicitHelpCommand = void 0),
        (t._helpCommandName = "help"),
        (t._helpCommandnameAndArgs = "help [command]"),
        (t._helpCommandDescription = "display help for command"),
        (t._helpConfiguration = {}),
        t
      );
    }
    return (
      A(n, [
        {
          key: "copyInheritedSettings",
          value: function (e) {
            return (
              (this._outputConfiguration = e._outputConfiguration),
              (this._hasHelpOption = e._hasHelpOption),
              (this._helpFlags = e._helpFlags),
              (this._helpDescription = e._helpDescription),
              (this._helpShortFlag = e._helpShortFlag),
              (this._helpLongFlag = e._helpLongFlag),
              (this._helpCommandName = e._helpCommandName),
              (this._helpCommandnameAndArgs = e._helpCommandnameAndArgs),
              (this._helpCommandDescription = e._helpCommandDescription),
              (this._helpConfiguration = e._helpConfiguration),
              (this._exitCallback = e._exitCallback),
              (this._storeOptionsAsProperties = e._storeOptionsAsProperties),
              (this._combineFlagAndOptionalValue =
                e._combineFlagAndOptionalValue),
              (this._allowExcessArguments = e._allowExcessArguments),
              (this._enablePositionalOptions = e._enablePositionalOptions),
              (this._showHelpAfterError = e._showHelpAfterError),
              (this._showSuggestionAfterError = e._showSuggestionAfterError),
              this
            );
          },
        },
        {
          key: "command",
          value: function (e, t, r) {
            var n = t,
              i = r;
            "object" === g(n) && null !== n && ((i = n), (n = null)),
              (i = i || {});
            var a = H(e.match(/([^ ]+) *(.*)/), 3),
              s = a[1],
              o = a[2],
              l = this.createCommand(s);
            return (
              n && (l.description(n), (l._executableHandler = !0)),
              i.isDefault && (this._defaultCommandName = l._name),
              (l._hidden = !(!i.noHelp && !i.hidden)),
              (l._executableFile = i.executableFile || null),
              o && l.arguments(o),
              this.commands.push(l),
              (l.parent = this),
              l.copyInheritedSettings(this),
              n ? this : l
            );
          },
        },
        {
          key: "createCommand",
          value: function (e) {
            return new n(e);
          },
        },
        {
          key: "createHelp",
          value: function () {
            return Object.assign(new me(), this.configureHelp());
          },
        },
        {
          key: "configureHelp",
          value: function (e) {
            return void 0 === e
              ? this._helpConfiguration
              : ((this._helpConfiguration = e), this);
          },
        },
        {
          key: "configureOutput",
          value: function (e) {
            return void 0 === e
              ? this._outputConfiguration
              : (Object.assign(this._outputConfiguration, e), this);
          },
        },
        {
          key: "showHelpAfterError",
          value: function () {
            var e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            return (
              "string" != typeof e && (e = !!e),
              (this._showHelpAfterError = e),
              this
            );
          },
        },
        {
          key: "showSuggestionAfterError",
          value: function () {
            var e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            return (this._showSuggestionAfterError = !!e), this;
          },
        },
        {
          key: "addCommand",
          value: function (e, t) {
            if (!e._name)
              throw new Error(
                "Command passed to .addCommand() must have a name\n- specify the name in Command constructor or using .name()"
              );
            return (
              (t = t || {}).isDefault && (this._defaultCommandName = e._name),
              (t.noHelp || t.hidden) && (e._hidden = !0),
              this.commands.push(e),
              (e.parent = this),
              this
            );
          },
        },
        {
          key: "createArgument",
          value: function (e, t) {
            return new de(e, t);
          },
        },
        {
          key: "argument",
          value: function (e, t, r, n) {
            var i = this.createArgument(e, t);
            return (
              "function" == typeof r ? i.default(n).argParser(r) : i.default(r),
              this.addArgument(i),
              this
            );
          },
        },
        {
          key: "arguments",
          value: function (e) {
            var t = this;
            return (
              e.split(/ +/).forEach(function (e) {
                t.argument(e);
              }),
              this
            );
          },
        },
        {
          key: "addArgument",
          value: function (e) {
            var t = this._args.slice(-1)[0];
            if (t && t.variadic)
              throw new Error(
                "only the last argument can be variadic '".concat(t.name(), "'")
              );
            if (
              e.required &&
              void 0 !== e.defaultValue &&
              void 0 === e.parseArg
            )
              throw new Error(
                "a default value for a required argument is never used: '".concat(
                  e.name(),
                  "'"
                )
              );
            return this._args.push(e), this;
          },
        },
        {
          key: "addHelpCommand",
          value: function (e, t) {
            return (
              !1 === e
                ? (this._addImplicitHelpCommand = !1)
                : ((this._addImplicitHelpCommand = !0),
                  "string" == typeof e &&
                    ((this._helpCommandName = e.split(" ")[0]),
                    (this._helpCommandnameAndArgs = e)),
                  (this._helpCommandDescription =
                    t || this._helpCommandDescription)),
              this
            );
          },
        },
        {
          key: "_hasImplicitHelpCommand",
          value: function () {
            return void 0 === this._addImplicitHelpCommand
              ? this.commands.length &&
                  !this._actionHandler &&
                  !this._findCommand("help")
              : this._addImplicitHelpCommand;
          },
        },
        {
          key: "hook",
          value: function (e, t) {
            var r = ["preSubcommand", "preAction", "postAction"];
            if (!r.includes(e))
              throw new Error(
                "Unexpected value for event passed to hook : '"
                  .concat(e, "'.\nExpecting one of '")
                  .concat(r.join("', '"), "'")
              );
            return (
              this._lifeCycleHooks[e]
                ? this._lifeCycleHooks[e].push(t)
                : (this._lifeCycleHooks[e] = [t]),
              this
            );
          },
        },
        {
          key: "exitOverride",
          value: function (e) {
            return (
              (this._exitCallback =
                e ||
                function (e) {
                  if ("commander.executeSubCommandAsync" !== e.code) throw e;
                }),
              this
            );
          },
        },
        {
          key: "_exit",
          value: function (e, t, r) {
            this._exitCallback && this._exitCallback(new ye(e, t, r)),
              he.exit(e);
          },
        },
        {
          key: "action",
          value: function (e) {
            var t = this;
            return (
              (this._actionHandler = function (r) {
                var n = t._args.length,
                  i = r.slice(0, n);
                return (
                  t._storeOptionsAsProperties ? (i[n] = t) : (i[n] = t.opts()),
                  i.push(t),
                  e.apply(t, i)
                );
              }),
              this
            );
          },
        },
        {
          key: "createOption",
          value: function (e, t) {
            return new ve(e, t);
          },
        },
        {
          key: "addOption",
          value: function (e) {
            var t = this,
              r = e.name(),
              n = e.attributeName();
            if (e.negate) {
              var i = e.long.replace(/^--no-/, "--");
              this._findOption(i) ||
                this.setOptionValueWithSource(
                  n,
                  void 0 === e.defaultValue || e.defaultValue,
                  "default"
                );
            } else
              void 0 !== e.defaultValue &&
                this.setOptionValueWithSource(n, e.defaultValue, "default");
            this.options.push(e);
            var a = function (r, i, a) {
              null == r && void 0 !== e.presetArg && (r = e.presetArg);
              var s = t.getOptionValue(n);
              if (null !== r && e.parseArg)
                try {
                  r = e.parseArg(r, s);
                } catch (e) {
                  if ("commander.invalidArgument" === e.code) {
                    var o = "".concat(i, " ").concat(e.message);
                    t.error(o, { exitCode: e.exitCode, code: e.code });
                  }
                  throw e;
                }
              else null !== r && e.variadic && (r = e._concatValue(r, s));
              null == r &&
                (r = !e.negate && (!(!e.isBoolean() && !e.optional) || "")),
                t.setOptionValueWithSource(n, r, a);
            };
            return (
              this.on("option:" + r, function (t) {
                var r = "error: option '"
                  .concat(e.flags, "' argument '")
                  .concat(t, "' is invalid.");
                a(t, r, "cli");
              }),
              e.envVar &&
                this.on("optionEnv:" + r, function (t) {
                  var r = "error: option '"
                    .concat(e.flags, "' value '")
                    .concat(t, "' from env '")
                    .concat(e.envVar, "' is invalid.");
                  a(t, r, "env");
                }),
              this
            );
          },
        },
        {
          key: "_optionEx",
          value: function (e, t, r, n, i) {
            if ("object" === g(t) && t instanceof ve)
              throw new Error(
                "To add an Option object use addOption() instead of option() or requiredOption()"
              );
            var a = this.createOption(t, r);
            if ((a.makeOptionMandatory(!!e.mandatory), "function" == typeof n))
              a.default(i).argParser(n);
            else if (n instanceof RegExp) {
              var s = n;
              (n = function (e, t) {
                var r = s.exec(e);
                return r ? r[0] : t;
              }),
                a.default(i).argParser(n);
            } else a.default(n);
            return this.addOption(a);
          },
        },
        {
          key: "option",
          value: function (e, t, r, n) {
            return this._optionEx({}, e, t, r, n);
          },
        },
        {
          key: "requiredOption",
          value: function (e, t, r, n) {
            return this._optionEx({ mandatory: !0 }, e, t, r, n);
          },
        },
        {
          key: "combineFlagAndOptionalValue",
          value: function () {
            var e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            return (this._combineFlagAndOptionalValue = !!e), this;
          },
        },
        {
          key: "allowUnknownOption",
          value: function () {
            var e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            return (this._allowUnknownOption = !!e), this;
          },
        },
        {
          key: "allowExcessArguments",
          value: function () {
            var e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            return (this._allowExcessArguments = !!e), this;
          },
        },
        {
          key: "enablePositionalOptions",
          value: function () {
            var e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            return (this._enablePositionalOptions = !!e), this;
          },
        },
        {
          key: "passThroughOptions",
          value: function () {
            var e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            if (
              ((this._passThroughOptions = !!e),
              this.parent && e && !this.parent._enablePositionalOptions)
            )
              throw new Error(
                "passThroughOptions can not be used without turning on enablePositionalOptions for parent command(s)"
              );
            return this;
          },
        },
        {
          key: "storeOptionsAsProperties",
          value: function () {
            var e =
              !(arguments.length > 0 && void 0 !== arguments[0]) ||
              arguments[0];
            if (((this._storeOptionsAsProperties = !!e), this.options.length))
              throw new Error(
                "call .storeOptionsAsProperties() before adding options"
              );
            return this;
          },
        },
        {
          key: "getOptionValue",
          value: function (e) {
            return this._storeOptionsAsProperties
              ? this[e]
              : this._optionValues[e];
          },
        },
        {
          key: "setOptionValue",
          value: function (e, t) {
            return this.setOptionValueWithSource(e, t, void 0);
          },
        },
        {
          key: "setOptionValueWithSource",
          value: function (e, t, r) {
            return (
              this._storeOptionsAsProperties
                ? (this[e] = t)
                : (this._optionValues[e] = t),
              (this._optionValueSources[e] = r),
              this
            );
          },
        },
        {
          key: "getOptionValueSource",
          value: function (e) {
            return this._optionValueSources[e];
          },
        },
        {
          key: "getOptionValueSourceWithGlobals",
          value: function (e) {
            var t;
            return (
              Pe(this).forEach(function (r) {
                void 0 !== r.getOptionValueSource(e) &&
                  (t = r.getOptionValueSource(e));
              }),
              t
            );
          },
        },
        {
          key: "_prepareUserArgs",
          value: function (e, t) {
            if (void 0 !== e && !Array.isArray(e))
              throw new Error(
                "first parameter to parse must be array or undefined"
              );
            var r;
            switch (
              ((t = t || {}),
              void 0 === e &&
                ((e = he.argv),
                he.versions && he.versions.electron && (t.from = "electron")),
              (this.rawArgs = e.slice()),
              t.from)
            ) {
              case void 0:
              case "node":
                (this._scriptPath = e[1]), (r = e.slice(2));
                break;
              case "electron":
                he.defaultApp
                  ? ((this._scriptPath = e[1]), (r = e.slice(2)))
                  : (r = e.slice(1));
                break;
              case "user":
                r = e.slice(0);
                break;
              default:
                throw new Error(
                  "unexpected parse option { from: '".concat(t.from, "' }")
                );
            }
            return (
              !this._name &&
                this._scriptPath &&
                this.nameFromFilename(this._scriptPath),
              (this._name = this._name || "program"),
              r
            );
          },
        },
        {
          key: "parse",
          value: function (e, t) {
            var r = this._prepareUserArgs(e, t);
            return this._parseCommand([], r), this;
          },
        },
        {
          key: "parseAsync",
          value:
            ((t = q(
              G.mark(function e(t, r) {
                var n;
                return G.wrap(
                  function (e) {
                    for (;;)
                      switch ((e.prev = e.next)) {
                        case 0:
                          return (
                            (n = this._prepareUserArgs(t, r)),
                            (e.next = 3),
                            this._parseCommand([], n)
                          );
                        case 3:
                          return e.abrupt("return", this);
                        case 4:
                        case "end":
                          return e.stop();
                      }
                  },
                  e,
                  this
                );
              })
            )),
            function (e, r) {
              return t.apply(this, arguments);
            }),
        },
        {
          key: "_executeSubCommand",
          value: function (e, t) {
            t = t.slice();
            var r,
              n = [".js", ".ts", ".tsx", ".mjs", ".cjs"];
            function i(e, t) {
              var r = ce.resolve(e, t);
              if (pe.existsSync(r)) return r;
              if (!n.includes(ce.extname(t))) {
                var i = n.find(function (e) {
                  return pe.existsSync("".concat(r).concat(e));
                });
                return i ? "".concat(r).concat(i) : void 0;
              }
            }
            this._checkForMissingMandatoryOptions(),
              this._checkForConflictingOptions();
            var a,
              s =
                e._executableFile || "".concat(this._name, "-").concat(e._name),
              o = this._executableDir || "";
            if (this._scriptPath) {
              var l;
              try {
                l = pe.realpathSync(this._scriptPath);
              } catch (e) {
                l = this._scriptPath;
              }
              o = ce.resolve(ce.dirname(l), o);
            }
            if (o) {
              var u = i(o, s);
              if (!u && !e._executableFile && this._scriptPath) {
                var c = ce.basename(
                  this._scriptPath,
                  ce.extname(this._scriptPath)
                );
                c !== this._name &&
                  (u = i(o, "".concat(c, "-").concat(e._name)));
              }
              s = u || s;
            }
            if (
              ((r = n.includes(ce.extname(s))),
              "win32" !== he.platform
                ? r
                  ? (t.unshift(s),
                    (t = Ee(he.execArgv).concat(t)),
                    (a = ue.spawn(he.argv[0], t, { stdio: "inherit" })))
                  : (a = ue.spawn(s, t, { stdio: "inherit" }))
                : (t.unshift(s),
                  (t = Ee(he.execArgv).concat(t)),
                  (a = ue.spawn(he.execPath, t, { stdio: "inherit" }))),
              !a.killed)
            ) {
              ["SIGUSR1", "SIGUSR2", "SIGTERM", "SIGINT", "SIGHUP"].forEach(
                function (e) {
                  he.on(e, function () {
                    !1 === a.killed && null === a.exitCode && a.kill(e);
                  });
                }
              );
            }
            var p = this._exitCallback;
            p
              ? a.on("close", function () {
                  p(
                    new ye(
                      he.exitCode || 0,
                      "commander.executeSubCommandAsync",
                      "(close)"
                    )
                  );
                })
              : a.on("close", he.exit.bind(he)),
              a.on("error", function (t) {
                if ("ENOENT" === t.code) {
                  var r = o
                      ? "searched for local subcommand relative to directory '".concat(
                          o,
                          "'"
                        )
                      : "no directory for search for local subcommand, use .executableDir() to supply a custom directory",
                    n = "'"
                      .concat(s, "' does not exist\n - if '")
                      .concat(
                        e._name,
                        "' is not meant to be an executable command, remove description parameter from '.command()' and use '.description()' instead\n - if the default executable name is not suitable, use the executableFile option to supply a custom name or path\n - "
                      )
                      .concat(r);
                  throw new Error(n);
                }
                if ("EACCES" === t.code)
                  throw new Error("'".concat(s, "' not executable"));
                if (p) {
                  var i = new ye(
                    1,
                    "commander.executeSubCommandAsync",
                    "(error)"
                  );
                  (i.nestedError = t), p(i);
                } else he.exit(1);
              }),
              (this.runningCommand = a);
          },
        },
        {
          key: "_dispatchSubcommand",
          value: function (e, t, r) {
            var n,
              i = this,
              a = this._findCommand(e);
            return (
              a || this.help({ error: !0 }),
              (n = this._chainOrCallSubCommandHook(n, a, "preSubcommand")),
              (n = this._chainOrCall(n, function () {
                if (!a._executableHandler) return a._parseCommand(t, r);
                i._executeSubCommand(a, t.concat(r));
              }))
            );
          },
        },
        {
          key: "_checkNumberOfArguments",
          value: function () {
            var e = this;
            this._args.forEach(function (t, r) {
              t.required && null == e.args[r] && e.missingArgument(t.name());
            }),
              (this._args.length > 0 &&
                this._args[this._args.length - 1].variadic) ||
                (this.args.length > this._args.length &&
                  this._excessArguments(this.args));
          },
        },
        {
          key: "_processArguments",
          value: function () {
            var e = this,
              t = function (t, r, n) {
                var i = r;
                if (null !== r && t.parseArg)
                  try {
                    i = t.parseArg(r, n);
                  } catch (n) {
                    if ("commander.invalidArgument" === n.code) {
                      var a = "error: command-argument value '"
                        .concat(r, "' is invalid for argument '")
                        .concat(t.name(), "'. ")
                        .concat(n.message);
                      e.error(a, { exitCode: n.exitCode, code: n.code });
                    }
                    throw n;
                  }
                return i;
              };
            this._checkNumberOfArguments();
            var r = [];
            this._args.forEach(function (n, i) {
              var a = n.defaultValue;
              n.variadic
                ? i < e.args.length
                  ? ((a = e.args.slice(i)),
                    n.parseArg &&
                      (a = a.reduce(function (e, r) {
                        return t(n, r, e);
                      }, n.defaultValue)))
                  : void 0 === a && (a = [])
                : i < e.args.length &&
                  ((a = e.args[i]),
                  n.parseArg && (a = t(n, a, n.defaultValue))),
                (r[i] = a);
            }),
              (this.processedArgs = r);
          },
        },
        {
          key: "_chainOrCall",
          value: function (e, t) {
            return e && e.then && "function" == typeof e.then
              ? e.then(function () {
                  return t();
                })
              : t();
          },
        },
        {
          key: "_chainOrCallHooks",
          value: function (e, t) {
            var r = this,
              n = e,
              i = [];
            return (
              Pe(this)
                .reverse()
                .filter(function (e) {
                  return void 0 !== e._lifeCycleHooks[t];
                })
                .forEach(function (e) {
                  e._lifeCycleHooks[t].forEach(function (t) {
                    i.push({ hookedCommand: e, callback: t });
                  });
                }),
              "postAction" === t && i.reverse(),
              i.forEach(function (e) {
                n = r._chainOrCall(n, function () {
                  return e.callback(e.hookedCommand, r);
                });
              }),
              n
            );
          },
        },
        {
          key: "_chainOrCallSubCommandHook",
          value: function (e, t, r) {
            var n = this,
              i = e;
            return (
              void 0 !== this._lifeCycleHooks[r] &&
                this._lifeCycleHooks[r].forEach(function (e) {
                  i = n._chainOrCall(i, function () {
                    return e(n, t);
                  });
                }),
              i
            );
          },
        },
        {
          key: "_parseCommand",
          value: function (e, t) {
            var r = this,
              n = this.parseOptions(t);
            if (
              (this._parseOptionsEnv(),
              this._parseOptionsImplied(),
              (e = e.concat(n.operands)),
              (t = n.unknown),
              (this.args = e.concat(t)),
              e && this._findCommand(e[0]))
            )
              return this._dispatchSubcommand(e[0], e.slice(1), t);
            if (
              this._hasImplicitHelpCommand() &&
              e[0] === this._helpCommandName
            )
              return (
                1 === e.length && this.help(),
                this._dispatchSubcommand(e[1], [], [this._helpLongFlag])
              );
            if (this._defaultCommandName)
              return (
                xe(this, t),
                this._dispatchSubcommand(this._defaultCommandName, e, t)
              );
            !this.commands.length ||
              0 !== this.args.length ||
              this._actionHandler ||
              this._defaultCommandName ||
              this.help({ error: !0 }),
              xe(this, n.unknown),
              this._checkForMissingMandatoryOptions(),
              this._checkForConflictingOptions();
            var i,
              a = function () {
                n.unknown.length > 0 && r.unknownOption(n.unknown[0]);
              },
              s = "command:".concat(this.name());
            if (this._actionHandler)
              return (
                a(),
                this._processArguments(),
                (i = this._chainOrCallHooks(i, "preAction")),
                (i = this._chainOrCall(i, function () {
                  return r._actionHandler(r.processedArgs);
                })),
                this.parent &&
                  (i = this._chainOrCall(i, function () {
                    r.parent.emit(s, e, t);
                  })),
                (i = this._chainOrCallHooks(i, "postAction"))
              );
            if (this.parent && this.parent.listenerCount(s))
              a(), this._processArguments(), this.parent.emit(s, e, t);
            else if (e.length) {
              if (this._findCommand("*"))
                return this._dispatchSubcommand("*", e, t);
              this.listenerCount("command:*")
                ? this.emit("command:*", e, t)
                : this.commands.length
                ? this.unknownCommand()
                : (a(), this._processArguments());
            } else
              this.commands.length
                ? (a(), this.help({ error: !0 }))
                : (a(), this._processArguments());
          },
        },
        {
          key: "_findCommand",
          value: function (e) {
            if (e)
              return this.commands.find(function (t) {
                return t._name === e || t._aliases.includes(e);
              });
          },
        },
        {
          key: "_findOption",
          value: function (e) {
            return this.options.find(function (t) {
              return t.is(e);
            });
          },
        },
        {
          key: "_checkForMissingMandatoryOptions",
          value: function () {
            for (
              var e = function (e) {
                  e.options.forEach(function (t) {
                    t.mandatory &&
                      void 0 === e.getOptionValue(t.attributeName()) &&
                      e.missingMandatoryOptionValue(t);
                  });
                },
                t = this;
              t;
              t = t.parent
            )
              e(t);
          },
        },
        {
          key: "_checkForConflictingLocalOptions",
          value: function () {
            var e = this,
              t = this.options.filter(function (t) {
                var r = t.attributeName();
                return (
                  void 0 !== e.getOptionValue(r) &&
                  "default" !== e.getOptionValueSource(r)
                );
              }),
              r = t.filter(function (e) {
                return e.conflictsWith.length > 0;
              });
            r.forEach(function (r) {
              var n = t.find(function (e) {
                return r.conflictsWith.includes(e.attributeName());
              });
              n && e._conflictingOption(r, n);
            });
          },
        },
        {
          key: "_checkForConflictingOptions",
          value: function () {
            for (var e = this; e; e = e.parent)
              e._checkForConflictingLocalOptions();
          },
        },
        {
          key: "parseOptions",
          value: function (e) {
            var t = [],
              r = [],
              n = t,
              i = e.slice();
            function a(e) {
              return e.length > 1 && "-" === e[0];
            }
            for (var s = null; i.length; ) {
              var o = i.shift();
              if ("--" === o) {
                var l;
                n === r && n.push(o), (l = n).push.apply(l, K(i));
                break;
              }
              if (!s || a(o)) {
                if (((s = null), a(o))) {
                  var u = this._findOption(o);
                  if (u) {
                    if (u.required) {
                      var c = i.shift();
                      void 0 === c && this.optionMissingArgument(u),
                        this.emit("option:".concat(u.name()), c);
                    } else if (u.optional) {
                      var p = null;
                      i.length > 0 && !a(i[0]) && (p = i.shift()),
                        this.emit("option:".concat(u.name()), p);
                    } else this.emit("option:".concat(u.name()));
                    s = u.variadic ? u : null;
                    continue;
                  }
                }
                if (o.length > 2 && "-" === o[0] && "-" !== o[1]) {
                  var h = this._findOption("-".concat(o[1]));
                  if (h) {
                    h.required ||
                    (h.optional && this._combineFlagAndOptionalValue)
                      ? this.emit("option:".concat(h.name()), o.slice(2))
                      : (this.emit("option:".concat(h.name())),
                        i.unshift("-".concat(o.slice(2))));
                    continue;
                  }
                }
                if (/^--[^=]+=/.test(o)) {
                  var d = o.indexOf("="),
                    f = this._findOption(o.slice(0, d));
                  if (f && (f.required || f.optional)) {
                    this.emit("option:".concat(f.name()), o.slice(d + 1));
                    continue;
                  }
                }
                if (
                  (a(o) && (n = r),
                  (this._enablePositionalOptions || this._passThroughOptions) &&
                    0 === t.length &&
                    0 === r.length)
                ) {
                  if (this._findCommand(o)) {
                    t.push(o), i.length > 0 && r.push.apply(r, K(i));
                    break;
                  }
                  if (
                    o === this._helpCommandName &&
                    this._hasImplicitHelpCommand()
                  ) {
                    t.push(o), i.length > 0 && t.push.apply(t, K(i));
                    break;
                  }
                  if (this._defaultCommandName) {
                    r.push(o), i.length > 0 && r.push.apply(r, K(i));
                    break;
                  }
                }
                if (this._passThroughOptions) {
                  var y;
                  n.push(o), i.length > 0 && (y = n).push.apply(y, K(i));
                  break;
                }
                n.push(o);
              } else this.emit("option:".concat(s.name()), o);
            }
            return { operands: t, unknown: r };
          },
        },
        {
          key: "opts",
          value: function () {
            if (this._storeOptionsAsProperties) {
              for (var e = {}, t = this.options.length, r = 0; r < t; r++) {
                var n = this.options[r].attributeName();
                e[n] = n === this._versionOptionName ? this._version : this[n];
              }
              return e;
            }
            return this._optionValues;
          },
        },
        {
          key: "optsWithGlobals",
          value: function () {
            return Pe(this).reduce(function (e, t) {
              return Object.assign(e, t.opts());
            }, {});
          },
        },
        {
          key: "error",
          value: function (e, t) {
            this._outputConfiguration.outputError(
              "".concat(e, "\n"),
              this._outputConfiguration.writeErr
            ),
              "string" == typeof this._showHelpAfterError
                ? this._outputConfiguration.writeErr(
                    "".concat(this._showHelpAfterError, "\n")
                  )
                : this._showHelpAfterError &&
                  (this._outputConfiguration.writeErr("\n"),
                  this.outputHelp({ error: !0 }));
            var r = t || {},
              n = r.exitCode || 1,
              i = r.code || "commander.error";
            this._exit(n, i, e);
          },
        },
        {
          key: "_parseOptionsEnv",
          value: function () {
            var e = this;
            this.options.forEach(function (t) {
              if (t.envVar && t.envVar in he.env) {
                var r = t.attributeName();
                (void 0 === e.getOptionValue(r) ||
                  ["default", "config", "env"].includes(
                    e.getOptionValueSource(r)
                  )) &&
                  (t.required || t.optional
                    ? e.emit("optionEnv:".concat(t.name()), he.env[t.envVar])
                    : e.emit("optionEnv:".concat(t.name())));
              }
            });
          },
        },
        {
          key: "_parseOptionsImplied",
          value: function () {
            var e = this,
              t = new be(this.options),
              r = function (t) {
                return (
                  void 0 !== e.getOptionValue(t) &&
                  !["default", "implied"].includes(e.getOptionValueSource(t))
                );
              };
            this.options
              .filter(function (n) {
                return (
                  void 0 !== n.implied &&
                  r(n.attributeName()) &&
                  t.valueFromOption(e.getOptionValue(n.attributeName()), n)
                );
              })
              .forEach(function (t) {
                Object.keys(t.implied)
                  .filter(function (e) {
                    return !r(e);
                  })
                  .forEach(function (r) {
                    e.setOptionValueWithSource(r, t.implied[r], "implied");
                  });
              });
          },
        },
        {
          key: "missingArgument",
          value: function (e) {
            var t = "error: missing required argument '".concat(e, "'");
            this.error(t, { code: "commander.missingArgument" });
          },
        },
        {
          key: "optionMissingArgument",
          value: function (e) {
            var t = "error: option '".concat(e.flags, "' argument missing");
            this.error(t, { code: "commander.optionMissingArgument" });
          },
        },
        {
          key: "missingMandatoryOptionValue",
          value: function (e) {
            var t = "error: required option '".concat(
              e.flags,
              "' not specified"
            );
            this.error(t, { code: "commander.missingMandatoryOptionValue" });
          },
        },
        {
          key: "_conflictingOption",
          value: function (e, t) {
            var r = this,
              n = function (e) {
                var t = (function (e) {
                    var t = e.attributeName(),
                      n = r.getOptionValue(t),
                      i = r.options.find(function (e) {
                        return e.negate && t === e.attributeName();
                      }),
                      a = r.options.find(function (e) {
                        return !e.negate && t === e.attributeName();
                      });
                    return i &&
                      ((void 0 === i.presetArg && !1 === n) ||
                        (void 0 !== i.presetArg && n === i.presetArg))
                      ? i
                      : a || e;
                  })(e),
                  n = t.attributeName();
                return "env" === r.getOptionValueSource(n)
                  ? "environment variable '".concat(t.envVar, "'")
                  : "option '".concat(t.flags, "'");
              },
              i = "error: ".concat(n(e), " cannot be used with ").concat(n(t));
            this.error(i, { code: "commander.conflictingOption" });
          },
        },
        {
          key: "unknownOption",
          value: function (e) {
            if (!this._allowUnknownOption) {
              var t = "";
              if (e.startsWith("--") && this._showSuggestionAfterError) {
                var r = [],
                  n = this;
                do {
                  var i = n
                    .createHelp()
                    .visibleOptions(n)
                    .filter(function (e) {
                      return e.long;
                    })
                    .map(function (e) {
                      return e.long;
                    });
                  (r = r.concat(i)), (n = n.parent);
                } while (n && !n._enablePositionalOptions);
                t = Te(e, r);
              }
              var a = "error: unknown option '".concat(e, "'").concat(t);
              this.error(a, { code: "commander.unknownOption" });
            }
          },
        },
        {
          key: "_excessArguments",
          value: function (e) {
            if (!this._allowExcessArguments) {
              var t = this._args.length,
                r = 1 === t ? "" : "s",
                n = this.parent ? " for '".concat(this.name(), "'") : "",
                i = "error: too many arguments"
                  .concat(n, ". Expected ")
                  .concat(t, " argument")
                  .concat(r, " but got ")
                  .concat(e.length, ".");
              this.error(i, { code: "commander.excessArguments" });
            }
          },
        },
        {
          key: "unknownCommand",
          value: function () {
            var e = this.args[0],
              t = "";
            if (this._showSuggestionAfterError) {
              var r = [];
              this.createHelp()
                .visibleCommands(this)
                .forEach(function (e) {
                  r.push(e.name()), e.alias() && r.push(e.alias());
                }),
                (t = Te(e, r));
            }
            var n = "error: unknown command '".concat(e, "'").concat(t);
            this.error(n, { code: "commander.unknownCommand" });
          },
        },
        {
          key: "version",
          value: function (e, t, r) {
            var n = this;
            if (void 0 === e) return this._version;
            (this._version = e),
              (t = t || "-V, --version"),
              (r = r || "output the version number");
            var i = this.createOption(t, r);
            return (
              (this._versionOptionName = i.attributeName()),
              this.options.push(i),
              this.on("option:" + i.name(), function () {
                n._outputConfiguration.writeOut("".concat(e, "\n")),
                  n._exit(0, "commander.version", e);
              }),
              this
            );
          },
        },
        {
          key: "description",
          value: function (e, t) {
            return void 0 === e && void 0 === t
              ? this._description
              : ((this._description = e),
                t && (this._argsDescription = t),
                this);
          },
        },
        {
          key: "summary",
          value: function (e) {
            return void 0 === e ? this._summary : ((this._summary = e), this);
          },
        },
        {
          key: "alias",
          value: function (e) {
            if (void 0 === e) return this._aliases[0];
            var t = this;
            if (
              (0 !== this.commands.length &&
                this.commands[this.commands.length - 1]._executableHandler &&
                (t = this.commands[this.commands.length - 1]),
              e === t._name)
            )
              throw new Error("Command alias can't be the same as its name");
            return t._aliases.push(e), this;
          },
        },
        {
          key: "aliases",
          value: function (e) {
            var t = this;
            return void 0 === e
              ? this._aliases
              : (e.forEach(function (e) {
                  return t.alias(e);
                }),
                this);
          },
        },
        {
          key: "usage",
          value: function (e) {
            if (void 0 === e) {
              if (this._usage) return this._usage;
              var t = this._args.map(function (e) {
                return fe(e);
              });
              return []
                .concat(
                  this.options.length || this._hasHelpOption ? "[options]" : [],
                  this.commands.length ? "[command]" : [],
                  this._args.length ? t : []
                )
                .join(" ");
            }
            return (this._usage = e), this;
          },
        },
        {
          key: "name",
          value: function (e) {
            return void 0 === e ? this._name : ((this._name = e), this);
          },
        },
        {
          key: "nameFromFilename",
          value: function (e) {
            return (this._name = ce.basename(e, ce.extname(e))), this;
          },
        },
        {
          key: "executableDir",
          value: function (e) {
            return void 0 === e
              ? this._executableDir
              : ((this._executableDir = e), this);
          },
        },
        {
          key: "helpInformation",
          value: function (e) {
            var t = this.createHelp();
            return (
              void 0 === t.helpWidth &&
                (t.helpWidth =
                  e && e.error
                    ? this._outputConfiguration.getErrHelpWidth()
                    : this._outputConfiguration.getOutHelpWidth()),
              t.formatHelp(this, t)
            );
          },
        },
        {
          key: "_getHelpContext",
          value: function (e) {
            var t,
              r = this,
              n = { error: !!(e = e || {}).error };
            return (
              (t = n.error
                ? function (e) {
                    return r._outputConfiguration.writeErr(e);
                  }
                : function (e) {
                    return r._outputConfiguration.writeOut(e);
                  }),
              (n.write = e.write || t),
              (n.command = this),
              n
            );
          },
        },
        {
          key: "outputHelp",
          value: function (e) {
            var t;
            "function" == typeof e && ((t = e), (e = void 0));
            var r = this._getHelpContext(e);
            Pe(this)
              .reverse()
              .forEach(function (e) {
                return e.emit("beforeAllHelp", r);
              }),
              this.emit("beforeHelp", r);
            var n = this.helpInformation(r);
            if (t && "string" != typeof (n = t(n)) && !Buffer.isBuffer(n))
              throw new Error(
                "outputHelp callback must return a string or a Buffer"
              );
            r.write(n),
              this.emit(this._helpLongFlag),
              this.emit("afterHelp", r),
              Pe(this).forEach(function (e) {
                return e.emit("afterAllHelp", r);
              });
          },
        },
        {
          key: "helpOption",
          value: function (e, t) {
            if ("boolean" == typeof e) return (this._hasHelpOption = e), this;
            (this._helpFlags = e || this._helpFlags),
              (this._helpDescription = t || this._helpDescription);
            var r = ge(this._helpFlags);
            return (
              (this._helpShortFlag = r.shortFlag),
              (this._helpLongFlag = r.longFlag),
              this
            );
          },
        },
        {
          key: "help",
          value: function (e) {
            this.outputHelp(e);
            var t = he.exitCode || 0;
            0 === t && e && "function" != typeof e && e.error && (t = 1),
              this._exit(t, "commander.help", "(outputHelp)");
          },
        },
        {
          key: "addHelpText",
          value: function (e, t) {
            var r = ["beforeAll", "before", "after", "afterAll"];
            if (!r.includes(e))
              throw new Error(
                "Unexpected value for position to addHelpText.\nExpecting one of '".concat(
                  r.join("', '"),
                  "'"
                )
              );
            var n = "".concat(e, "Help");
            return (
              this.on(n, function (e) {
                var r;
                (r =
                  "function" == typeof t
                    ? t({ error: e.error, command: e.command })
                    : t) && e.write("".concat(r, "\n"));
              }),
              this
            );
          },
        },
      ]),
      n
    );
  })();
function xe(e, t) {
  e._hasHelpOption &&
    t.find(function (t) {
      return t === e._helpLongFlag || t === e._helpShortFlag;
    }) &&
    (e.outputHelp(), e._exit(0, "commander.helpDisplayed", "(outputHelp)"));
}
function Ee(e) {
  return e.map(function (e) {
    if (!e.startsWith("--inspect")) return e;
    var t,
      r,
      n = "127.0.0.1",
      i = "9229";
    return (
      null !== (r = e.match(/^(--inspect(-brk)?)$/))
        ? (t = r[1])
        : null !== (r = e.match(/^(--inspect(-brk|-port)?)=([^:]+)$/))
        ? ((t = r[1]), /^\d+$/.test(r[3]) ? (i = r[3]) : (n = r[3]))
        : null !== (r = e.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) &&
          ((t = r[1]), (n = r[3]), (i = r[4])),
      t && "0" !== i
        ? ""
            .concat(t, "=")
            .concat(n, ":")
            .concat(parseInt(i) + 1)
        : e
    );
  });
}
function Pe(e) {
  for (var t = [], r = e; r; r = r.parent) t.push(r);
  return t;
}
(z.Command = Se),
  (function (e, t) {
    var r = k.Argument,
      n = z.Command,
      i = L.CommanderError,
      a = L.InvalidArgumentError,
      s = $.Help,
      o = ee.Option;
    ((t = e.exports = new n()).program = t),
      (t.Argument = r),
      (t.Command = n),
      (t.CommanderError = i),
      (t.Help = s),
      (t.InvalidArgumentError = a),
      (t.InvalidOptionArgumentError = a),
      (t.Option = o);
  })(x, x.exports);
var Ae = x.exports;
const {
  program: ke,
  createCommand: we,
  createArgument: Ce,
  createOption: Ie,
  CommanderError: Oe,
  InvalidArgumentError: Ne,
  InvalidOptionArgumentError: _e,
  Command: De,
  Argument: Le,
  Option: Me,
  Help: je,
} = Ae;
function Fe() {
  return (
    (Fe =
      "undefined" != typeof Reflect && Reflect.get
        ? Reflect.get.bind()
        : function (e, t, r) {
            var n = (function (e, t) {
              for (
                ;
                !Object.prototype.hasOwnProperty.call(e, t) &&
                null !== (e = N(e));

              );
              return e;
            })(e, t);
            if (n) {
              var i = Object.getOwnPropertyDescriptor(n, t);
              return i.get ? i.get.call(arguments.length < 3 ? e : r) : i.value;
            }
          }),
    Fe.apply(this, arguments)
  );
}
function Be(e, t) {
  return (
    t || (t = e.slice(0)),
    Object.freeze(
      Object.defineProperties(e, { raw: { value: Object.freeze(t) } })
    )
  );
}
var Re,
  Ue,
  Ve,
  Ke,
  We,
  qe = {};
function He(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Ye(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Ye(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Ye(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Je(e) {
  var t = (function () {
    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
    if (Reflect.construct.sham) return !1;
    if ("function" == typeof Proxy) return !0;
    try {
      return (
        Boolean.prototype.valueOf.call(
          Reflect.construct(Boolean, [], function () {})
        ),
        !0
      );
    } catch (e) {
      return !1;
    }
  })();
  return function () {
    var r,
      n = N(e);
    if (t) {
      var i = N(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else r = n.apply(this, arguments);
    return O(this, r);
  };
}
function Xe(e, t) {
  if (null == e) return {};
  var r,
    n,
    i = {},
    a = Object.keys(e);
  for (n = 0; n < a.length; n++) (r = a[n]), t.indexOf(r) >= 0 || (i[r] = e[r]);
  return i;
}
Object.defineProperty(qe, "__esModule", { value: !0 });
var Ge = A(function e(t, r, n) {
    E(this, e),
      (this.line = void 0),
      (this.column = void 0),
      (this.index = void 0),
      (this.line = t),
      (this.column = r),
      (this.index = n);
  }),
  ze = A(function e(t, r) {
    E(this, e),
      (this.start = void 0),
      (this.end = void 0),
      (this.filename = void 0),
      (this.identifierName = void 0),
      (this.start = t),
      (this.end = r);
  });
function $e(e, t) {
  var r = e.line,
    n = e.column,
    i = e.index;
  return new Ge(r, n + t, i + t);
}
var Qe = "BABEL_PARSER_SYNTAX_ERROR",
  Ze = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED",
  et = function (e) {
    var t =
      arguments.length > 1 && void 0 !== arguments[1]
        ? arguments[1]
        : e.length - 1;
    return {
      get: function () {
        return e.reduce(function (e, t) {
          return e[t];
        }, this);
      },
      set: function (r) {
        e.reduce(function (e, n, i) {
          return i === t ? (e[n] = r) : e[n];
        }, this);
      },
    };
  },
  tt = function (e, t, r) {
    return Object.keys(r)
      .map(function (e) {
        return [e, r[e]];
      })
      .filter(function (e) {
        return !!H(e, 2)[1];
      })
      .map(function (e) {
        var t = H(e, 2),
          r = t[0],
          n = t[1];
        return [
          r,
          "function" == typeof n
            ? { value: n, enumerable: !1 }
            : "string" == typeof n.reflect
            ? Object.assign({}, n, et(n.reflect.split(".")))
            : n,
        ];
      })
      .reduce(function (e, t) {
        var r = H(t, 2),
          n = r[0],
          i = r[1];
        return Object.defineProperty(
          e,
          n,
          Object.assign({ configurable: !0 }, i)
        );
      }, Object.assign(new e(), t));
  },
  rt = {
    ImportMetaOutsideModule: {
      message: "import.meta may appear only with 'sourceType: \"module\"'",
      code: Ze,
    },
    ImportOutsideModule: {
      message:
        "'import' and 'export' may appear only with 'sourceType: \"module\"'",
      code: Ze,
    },
  },
  nt = {
    ArrayPattern: "array destructuring pattern",
    AssignmentExpression: "assignment expression",
    AssignmentPattern: "assignment expression",
    ArrowFunctionExpression: "arrow function expression",
    ConditionalExpression: "conditional expression",
    CatchClause: "catch clause",
    ForOfStatement: "for-of statement",
    ForInStatement: "for-in statement",
    ForStatement: "for-loop",
    FormalParameters: "function parameter list",
    Identifier: "identifier",
    ImportSpecifier: "import specifier",
    ImportDefaultSpecifier: "import default specifier",
    ImportNamespaceSpecifier: "import namespace specifier",
    ObjectPattern: "object destructuring pattern",
    ParenthesizedExpression: "parenthesized expression",
    RestElement: "rest element",
    UpdateExpression: { true: "prefix operation", false: "postfix operation" },
    VariableDeclarator: "variable declaration",
    YieldExpression: "yield expression",
  },
  it = function (e) {
    var t = e.type,
      r = e.prefix;
    return "UpdateExpression" === t ? nt.UpdateExpression[String(r)] : nt[t];
  },
  at = {
    AccessorIsGenerator: function (e) {
      var t = e.kind;
      return "A ".concat(t, "ter cannot be a generator.");
    },
    ArgumentsInClass:
      "'arguments' is only allowed in functions and class methods.",
    AsyncFunctionInSingleStatementContext:
      "Async functions can only be declared at the top level or inside a block.",
    AwaitBindingIdentifier:
      "Can not use 'await' as identifier inside an async function.",
    AwaitBindingIdentifierInStaticBlock:
      "Can not use 'await' as identifier inside a static block.",
    AwaitExpressionFormalParameter:
      "'await' is not allowed in async function parameters.",
    AwaitNotInAsyncContext:
      "'await' is only allowed within async functions and at the top levels of modules.",
    AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
    BadGetterArity: "A 'get' accessor must not have any formal parameters.",
    BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
    BadSetterRestParameter:
      "A 'set' accessor function argument must not be a rest parameter.",
    ConstructorClassField: "Classes may not have a field named 'constructor'.",
    ConstructorClassPrivateField:
      "Classes may not have a private field named '#constructor'.",
    ConstructorIsAccessor: "Class constructor may not be an accessor.",
    ConstructorIsAsync: "Constructor can't be an async function.",
    ConstructorIsGenerator: "Constructor can't be a generator.",
    DeclarationMissingInitializer: function (e) {
      var t = e.kind;
      return "Missing initializer in ".concat(t, " declaration.");
    },
    DecoratorArgumentsOutsideParentheses:
      "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
    DecoratorBeforeExport:
      "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
    DecoratorsBeforeAfterExport:
      "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
    DecoratorConstructor:
      "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
    DecoratorExportClass:
      "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
    DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
    DecoratorStaticBlock: "Decorators can't be used with a static block.",
    DeletePrivateField: "Deleting a private field is not allowed.",
    DestructureNamedImport:
      "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
    DuplicateConstructor: "Duplicate constructor in the same class.",
    DuplicateDefaultExport: "Only one default export allowed per module.",
    DuplicateExport: function (e) {
      var t = e.exportName;
      return "`".concat(
        t,
        "` has already been exported. Exported identifiers must be unique."
      );
    },
    DuplicateProto: "Redefinition of __proto__ property.",
    DuplicateRegExpFlags: "Duplicate regular expression flag.",
    ElementAfterRest: "Rest element must be last element.",
    EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
    ExportBindingIsString: function (e) {
      var t = e.localName,
        r = e.exportName;
      return "A string literal cannot be used as an exported binding without `from`.\n- Did you mean `export { '"
        .concat(t, "' as '")
        .concat(r, "' } from 'some-module'`?");
    },
    ExportDefaultFromAsIdentifier:
      "'from' is not allowed as an identifier after 'export default'.",
    ForInOfLoopInitializer: function (e) {
      var t = e.type;
      return "'".concat(
        "ForInStatement" === t ? "for-in" : "for-of",
        "' loop variable declaration may not have an initializer."
      );
    },
    ForInUsing: "For-in loop may not start with 'using' declaration.",
    ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
    ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
    GeneratorInSingleStatementContext:
      "Generators can only be declared at the top level or inside a block.",
    IllegalBreakContinue: function (e) {
      var t = e.type;
      return "Unsyntactic ".concat(
        "BreakStatement" === t ? "break" : "continue",
        "."
      );
    },
    IllegalLanguageModeDirective:
      "Illegal 'use strict' directive in function with non-simple parameter list.",
    IllegalReturn: "'return' outside of function.",
    ImportBindingIsString: function (e) {
      var t = e.importName;
      return 'A string literal cannot be used as an imported binding.\n- Did you mean `import { "'.concat(
        t,
        '" as foo }`?'
      );
    },
    ImportCallArgumentTrailingComma:
      "Trailing comma is disallowed inside import(...) arguments.",
    ImportCallArity: function (e) {
      var t = e.maxArgumentCount;
      return "`import()` requires exactly ".concat(
        1 === t ? "one argument" : "one or two arguments",
        "."
      );
    },
    ImportCallNotNewExpression: "Cannot use new with import(...).",
    ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
    ImportJSONBindingNotDefault:
      "A JSON module can only be imported with `default`.",
    ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
    ImportReflectionNotBinding:
      'Only `import module x from "./module"` is valid.',
    IncompatibleRegExpUVFlags:
      "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
    InvalidBigIntLiteral: "Invalid BigIntLiteral.",
    InvalidCodePoint: "Code point out of bounds.",
    InvalidCoverInitializedName: "Invalid shorthand property initializer.",
    InvalidDecimal: "Invalid decimal.",
    InvalidDigit: function (e) {
      var t = e.radix;
      return "Expected number in radix ".concat(t, ".");
    },
    InvalidEscapeSequence: "Bad character escape sequence.",
    InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
    InvalidEscapedReservedWord: function (e) {
      var t = e.reservedWord;
      return "Escape sequence in keyword ".concat(t, ".");
    },
    InvalidIdentifier: function (e) {
      var t = e.identifierName;
      return "Invalid identifier ".concat(t, ".");
    },
    InvalidLhs: function (e) {
      var t = e.ancestor;
      return "Invalid left-hand side in ".concat(it(t), ".");
    },
    InvalidLhsBinding: function (e) {
      var t = e.ancestor;
      return "Binding invalid left-hand side in ".concat(it(t), ".");
    },
    InvalidNumber: "Invalid number.",
    InvalidOrMissingExponent:
      "Floating-point numbers require a valid exponent after the 'e'.",
    InvalidOrUnexpectedToken: function (e) {
      var t = e.unexpected;
      return "Unexpected character '".concat(t, "'.");
    },
    InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
    InvalidPrivateFieldResolution: function (e) {
      var t = e.identifierName;
      return "Private name #".concat(t, " is not defined.");
    },
    InvalidPropertyBindingPattern: "Binding member expression.",
    InvalidRecordProperty:
      "Only properties and spread elements are allowed in record definitions.",
    InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
    LabelRedeclaration: function (e) {
      var t = e.labelName;
      return "Label '".concat(t, "' is already declared.");
    },
    LetInLexicalBinding:
      "'let' is not allowed to be used as a name in 'let' or 'const' declarations.",
    LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
    MalformedRegExpFlags: "Invalid regular expression flag.",
    MissingClassName: "A class name is required.",
    MissingEqInAssignment:
      "Only '=' operator can be used for specifying default value.",
    MissingSemicolon: "Missing semicolon.",
    MissingPlugin: function (e) {
      var t = e.missingPlugin;
      return "This experimental syntax requires enabling the parser plugin: ".concat(
        t
          .map(function (e) {
            return JSON.stringify(e);
          })
          .join(", "),
        "."
      );
    },
    MissingOneOfPlugins: function (e) {
      var t = e.missingPlugin;
      return "This experimental syntax requires enabling one of the following parser plugin(s): ".concat(
        t
          .map(function (e) {
            return JSON.stringify(e);
          })
          .join(", "),
        "."
      );
    },
    MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
    MixingCoalesceWithLogical:
      "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
    ModuleAttributeDifferentFromType:
      "The only accepted module attribute is `type`.",
    ModuleAttributeInvalidValue:
      "Only string literals are allowed as module attribute values.",
    ModuleAttributesWithDuplicateKeys: function (e) {
      var t = e.key;
      return 'Duplicate key "'.concat(
        t,
        '" is not allowed in module attributes.'
      );
    },
    ModuleExportNameHasLoneSurrogate: function (e) {
      var t = e.surrogateCharCode;
      return "An export name cannot include a lone surrogate, found '\\u".concat(
        t.toString(16),
        "'."
      );
    },
    ModuleExportUndefined: function (e) {
      var t = e.localName;
      return "Export '".concat(t, "' is not defined.");
    },
    MultipleDefaultsInSwitch: "Multiple default clauses.",
    NewlineAfterThrow: "Illegal newline after throw.",
    NoCatchOrFinally: "Missing catch or finally clause.",
    NumberIdentifier: "Identifier directly after number.",
    NumericSeparatorInEscapeSequence:
      "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
    ObsoleteAwaitStar:
      "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
    OptionalChainingNoNew:
      "Constructors in/after an Optional Chain are not allowed.",
    OptionalChainingNoTemplate:
      "Tagged Template Literals are not allowed in optionalChain.",
    OverrideOnConstructor:
      "'override' modifier cannot appear on a constructor declaration.",
    ParamDupe: "Argument name clash.",
    PatternHasAccessor: "Object pattern can't contain getter or setter.",
    PatternHasMethod: "Object pattern can't contain methods.",
    PrivateInExpectedIn: function (e) {
      var t = e.identifierName;
      return "Private names are only allowed in property accesses (`obj.#"
        .concat(t, "`) or in `in` expressions (`#")
        .concat(t, " in obj`).");
    },
    PrivateNameRedeclaration: function (e) {
      var t = e.identifierName;
      return "Duplicate private name #".concat(t, ".");
    },
    RecordExpressionBarIncorrectEndSyntaxType:
      "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionBarIncorrectStartSyntaxType:
      "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    RecordExpressionHashIncorrectStartSyntaxType:
      "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    RecordNoProto: "'__proto__' is not allowed in Record expressions.",
    RestTrailingComma: "Unexpected trailing comma after rest element.",
    SloppyFunction:
      "In non-strict mode code, functions can only be declared at top level or inside a block.",
    SloppyFunctionAnnexB:
      "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
    StaticPrototype: "Classes may not have static property named prototype.",
    SuperNotAllowed:
      "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
    SuperPrivateField: "Private fields can't be accessed on super.",
    TrailingDecorator: "Decorators must be attached to a class element.",
    TupleExpressionBarIncorrectEndSyntaxType:
      "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionBarIncorrectStartSyntaxType:
      "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
    TupleExpressionHashIncorrectStartSyntaxType:
      "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
    UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
    UnexpectedAwaitAfterPipelineBody:
      'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
    UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
    UnexpectedImportExport:
      "'import' and 'export' may only appear at the top level.",
    UnexpectedKeyword: function (e) {
      var t = e.keyword;
      return "Unexpected keyword '".concat(t, "'.");
    },
    UnexpectedLeadingDecorator:
      "Leading decorators must be attached to a class declaration.",
    UnexpectedLexicalDeclaration:
      "Lexical declaration cannot appear in a single-statement context.",
    UnexpectedNewTarget:
      "`new.target` can only be used in functions or class properties.",
    UnexpectedNumericSeparator:
      "A numeric separator is only allowed between two digits.",
    UnexpectedPrivateField: "Unexpected private name.",
    UnexpectedReservedWord: function (e) {
      var t = e.reservedWord;
      return "Unexpected reserved word '".concat(t, "'.");
    },
    UnexpectedSuper: "'super' is only allowed in object methods and classes.",
    UnexpectedToken: function (e) {
      var t = e.expected,
        r = e.unexpected;
      return "Unexpected token"
        .concat(r ? " '".concat(r, "'.") : "")
        .concat(t ? ', expected "'.concat(t, '"') : "");
    },
    UnexpectedTokenUnaryExponentiation:
      "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
    UnexpectedUsingDeclaration:
      "Using declaration cannot appear in the top level when source type is `script`.",
    UnsupportedBind: "Binding should be performed on object property.",
    UnsupportedDecoratorExport:
      "A decorated export must export a class declaration.",
    UnsupportedDefaultExport:
      "Only expressions, functions or classes are allowed as the `default` export.",
    UnsupportedImport:
      "`import` can only be used in `import()` or `import.meta`.",
    UnsupportedMetaProperty: function (e) {
      var t = e.target,
        r = e.onlyValidPropertyName;
      return "The only valid meta property for "
        .concat(t, " is ")
        .concat(t, ".")
        .concat(r, ".");
    },
    UnsupportedParameterDecorator:
      "Decorators cannot be used to decorate parameters.",
    UnsupportedPropertyDecorator:
      "Decorators cannot be used to decorate object literal properties.",
    UnsupportedSuper:
      "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
    UnterminatedComment: "Unterminated comment.",
    UnterminatedRegExp: "Unterminated regular expression.",
    UnterminatedString: "Unterminated string constant.",
    UnterminatedTemplate: "Unterminated template.",
    UsingDeclarationHasBindingPattern:
      "Using declaration cannot have destructuring patterns.",
    VarRedeclaration: function (e) {
      var t = e.identifierName;
      return "Identifier '".concat(t, "' has already been declared.");
    },
    YieldBindingIdentifier:
      "Can not use 'yield' as identifier inside a generator.",
    YieldInParameter: "Yield expression is not allowed in formal parameters.",
    ZeroDigitNumericSeparator:
      "Numeric separator can not be used after leading 0.",
  },
  st = new Set([
    "ArrowFunctionExpression",
    "AssignmentExpression",
    "ConditionalExpression",
    "YieldExpression",
  ]),
  ot = {
    PipeBodyIsTighter:
      "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
    PipeTopicRequiresHackPipes:
      'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
    PipeTopicUnbound:
      "Topic reference is unbound; it must be inside a pipe body.",
    PipeTopicUnconfiguredToken: function (e) {
      var t = e.token;
      return "Invalid topic token "
        .concat(t, ". In order to use ")
        .concat(
          t,
          ' as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "'
        )
        .concat(t, '" }.');
    },
    PipeTopicUnused:
      "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
    PipeUnparenthesizedBody: function (e) {
      var t = e.type;
      return "Hack-style pipe body cannot be an unparenthesized ".concat(
        it({ type: t }),
        "; please wrap it in parentheses."
      );
    },
    PipelineBodyNoArrow:
      'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
    PipelineBodySequenceExpression:
      "Pipeline body may not be a comma-separated sequence expression.",
    PipelineHeadSequenceExpression:
      "Pipeline head should not be a comma-separated sequence expression.",
    PipelineTopicUnused:
      "Pipeline is in topic style but does not use topic reference.",
    PrimaryTopicNotAllowed:
      "Topic reference was used in a lexical context without topic binding.",
    PrimaryTopicRequiresSmartPipeline:
      'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
  },
  lt = ["toMessage"],
  ut = ["message"];
function ct(e, t) {
  if (Array.isArray(e))
    return function (t) {
      return ct(t, e[0]);
    };
  for (
    var r = {},
      n = function () {
        var n = a[i],
          s = e[n],
          o =
            "string" == typeof s
              ? {
                  message: function () {
                    return s;
                  },
                }
              : "function" == typeof s
              ? { message: s }
              : s,
          l = o.message,
          u = Xe(o, ut),
          c =
            "string" == typeof l
              ? function () {
                  return l;
                }
              : l;
        r[n] = (function (e) {
          var t = e.toMessage,
            r = Xe(e, lt);
          return function e(n) {
            var i = n.loc,
              a = n.details;
            return tt(SyntaxError, Object.assign({}, r, { loc: i }), {
              clone: function () {
                var t =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : {},
                  r = t.loc || {};
                return e({
                  loc: new Ge(
                    ("line" in r) ? r.line : this.loc.line,
                    ("column" in r) ? r.column : this.loc.column,
                    ("index" in r) ? r.index : this.loc.index
                  ),
                  details: Object.assign({}, this.details, t.details),
                });
              },
              details: { value: a, enumerable: !1 },
              message: {
                get: function () {
                  return ""
                    .concat(t(this.details), " (")
                    .concat(this.loc.line, ":")
                    .concat(this.loc.column, ")");
                },
                set: function (e) {
                  Object.defineProperty(this, "message", { value: e });
                },
              },
              pos: { reflect: "loc.index", enumerable: !0 },
              missingPlugin: ("missingPlugin" in a) && {
                reflect: "details.missingPlugin",
                enumerable: !0,
              },
            });
          };
        })(
          Object.assign(
            { code: Qe, reasonCode: n, toMessage: c },
            t ? { syntaxPlugin: t } : {},
            u
          )
        );
      },
      i = 0,
      a = Object.keys(e);
    i < a.length;
    i++
  )
    n();
  return r;
}
var pt = Object.assign(
    {},
    ct(rt),
    ct(at),
    ct({
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: function (e) {
        var t = e.referenceName;
        return "Assigning to '".concat(t, "' in strict mode.");
      },
      StrictEvalArgumentsBinding: function (e) {
        var t = e.bindingName;
        return "Binding '".concat(t, "' in strict mode.");
      },
      StrictFunction:
        "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape:
        "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral:
        "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode.",
    }),
    ct(Re || (Re = Be(["pipelineOperator"])))(ot)
  ),
  ht = Object.defineProperty,
  dt = function (e, t) {
    return ht(e, t, { enumerable: !1, value: e[t] });
  };
function ft(e) {
  return (
    e.loc.start && dt(e.loc.start, "index"),
    e.loc.end && dt(e.loc.end, "index"),
    e
  );
}
var yt = A(function e(t, r) {
    E(this, e),
      (this.token = void 0),
      (this.preserveSpace = void 0),
      (this.token = t),
      (this.preserveSpace = !!r);
  }),
  mt = {
    brace: new yt("{"),
    j_oTag: new yt("<tag"),
    j_cTag: new yt("</tag"),
    j_expr: new yt("<tag>...</tag>", !0),
  };
mt.template = new yt("`", !0);
var vt = !0,
  gt = !0,
  bt = !0,
  Tt = !0,
  St = !0,
  xt = A(function e(t) {
    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    E(this, e),
      (this.label = void 0),
      (this.keyword = void 0),
      (this.beforeExpr = void 0),
      (this.startsExpr = void 0),
      (this.rightAssociative = void 0),
      (this.isLoop = void 0),
      (this.isAssign = void 0),
      (this.prefix = void 0),
      (this.postfix = void 0),
      (this.binop = void 0),
      (this.label = t),
      (this.keyword = r.keyword),
      (this.beforeExpr = !!r.beforeExpr),
      (this.startsExpr = !!r.startsExpr),
      (this.rightAssociative = !!r.rightAssociative),
      (this.isLoop = !!r.isLoop),
      (this.isAssign = !!r.isAssign),
      (this.prefix = !!r.prefix),
      (this.postfix = !!r.postfix),
      (this.binop = null != r.binop ? r.binop : null),
      (this.updateContext = null);
  }),
  Et = new Map();
function Pt(e) {
  var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  t.keyword = e;
  var r = Dt(e, t);
  return Et.set(e, r), r;
}
function At(e, t) {
  return Dt(e, { beforeExpr: vt, binop: t });
}
var kt = -1,
  wt = [],
  Ct = [],
  It = [],
  Ot = [],
  Nt = [],
  _t = [];
function Dt(e) {
  var t,
    r,
    n,
    i,
    a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  return (
    ++kt,
    Ct.push(e),
    It.push(null != (t = a.binop) ? t : -1),
    Ot.push(null != (r = a.beforeExpr) && r),
    Nt.push(null != (n = a.startsExpr) && n),
    _t.push(null != (i = a.prefix) && i),
    wt.push(new xt(e, a)),
    kt
  );
}
function Lt(e) {
  var t,
    r,
    n,
    i,
    a = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
  return (
    ++kt,
    Et.set(e, kt),
    Ct.push(e),
    It.push(null != (t = a.binop) ? t : -1),
    Ot.push(null != (r = a.beforeExpr) && r),
    Nt.push(null != (n = a.startsExpr) && n),
    _t.push(null != (i = a.prefix) && i),
    wt.push(new xt("name", a)),
    kt
  );
}
var Mt = {
  bracketL: Dt("[", { beforeExpr: vt, startsExpr: gt }),
  bracketHashL: Dt("#[", { beforeExpr: vt, startsExpr: gt }),
  bracketBarL: Dt("[|", { beforeExpr: vt, startsExpr: gt }),
  bracketR: Dt("]"),
  bracketBarR: Dt("|]"),
  braceL: Dt("{", { beforeExpr: vt, startsExpr: gt }),
  braceBarL: Dt("{|", { beforeExpr: vt, startsExpr: gt }),
  braceHashL: Dt("#{", { beforeExpr: vt, startsExpr: gt }),
  braceR: Dt("}"),
  braceBarR: Dt("|}"),
  parenL: Dt("(", { beforeExpr: vt, startsExpr: gt }),
  parenR: Dt(")"),
  comma: Dt(",", { beforeExpr: vt }),
  semi: Dt(";", { beforeExpr: vt }),
  colon: Dt(":", { beforeExpr: vt }),
  doubleColon: Dt("::", { beforeExpr: vt }),
  dot: Dt("."),
  question: Dt("?", { beforeExpr: vt }),
  questionDot: Dt("?."),
  arrow: Dt("=>", { beforeExpr: vt }),
  template: Dt("template"),
  ellipsis: Dt("...", { beforeExpr: vt }),
  backQuote: Dt("`", { startsExpr: gt }),
  dollarBraceL: Dt("${", { beforeExpr: vt, startsExpr: gt }),
  templateTail: Dt("...`", { startsExpr: gt }),
  templateNonTail: Dt("...${", { beforeExpr: vt, startsExpr: gt }),
  at: Dt("@"),
  hash: Dt("#", { startsExpr: gt }),
  interpreterDirective: Dt("#!..."),
  eq: Dt("=", { beforeExpr: vt, isAssign: Tt }),
  assign: Dt("_=", { beforeExpr: vt, isAssign: Tt }),
  slashAssign: Dt("_=", { beforeExpr: vt, isAssign: Tt }),
  xorAssign: Dt("_=", { beforeExpr: vt, isAssign: Tt }),
  moduloAssign: Dt("_=", { beforeExpr: vt, isAssign: Tt }),
  incDec: Dt("++/--", { prefix: St, postfix: !0, startsExpr: gt }),
  bang: Dt("!", { beforeExpr: vt, prefix: St, startsExpr: gt }),
  tilde: Dt("~", { beforeExpr: vt, prefix: St, startsExpr: gt }),
  doubleCaret: Dt("^^", { startsExpr: gt }),
  doubleAt: Dt("@@", { startsExpr: gt }),
  pipeline: At("|>", 0),
  nullishCoalescing: At("??", 1),
  logicalOR: At("||", 1),
  logicalAND: At("&&", 2),
  bitwiseOR: At("|", 3),
  bitwiseXOR: At("^", 4),
  bitwiseAND: At("&", 5),
  equality: At("==/!=/===/!==", 6),
  lt: At("</>/<=/>=", 7),
  gt: At("</>/<=/>=", 7),
  relational: At("</>/<=/>=", 7),
  bitShift: At("<</>>/>>>", 8),
  bitShiftL: At("<</>>/>>>", 8),
  bitShiftR: At("<</>>/>>>", 8),
  plusMin: Dt("+/-", { beforeExpr: vt, binop: 9, prefix: St, startsExpr: gt }),
  modulo: Dt("%", { binop: 10, startsExpr: gt }),
  star: Dt("*", { binop: 10 }),
  slash: At("/", 10),
  exponent: Dt("**", { beforeExpr: vt, binop: 11, rightAssociative: !0 }),
  _in: Pt("in", { beforeExpr: vt, binop: 7 }),
  _instanceof: Pt("instanceof", { beforeExpr: vt, binop: 7 }),
  _break: Pt("break"),
  _case: Pt("case", { beforeExpr: vt }),
  _catch: Pt("catch"),
  _continue: Pt("continue"),
  _debugger: Pt("debugger"),
  _default: Pt("default", { beforeExpr: vt }),
  _else: Pt("else", { beforeExpr: vt }),
  _finally: Pt("finally"),
  _function: Pt("function", { startsExpr: gt }),
  _if: Pt("if"),
  _return: Pt("return", { beforeExpr: vt }),
  _switch: Pt("switch"),
  _throw: Pt("throw", { beforeExpr: vt, prefix: St, startsExpr: gt }),
  _try: Pt("try"),
  _var: Pt("var"),
  _const: Pt("const"),
  _with: Pt("with"),
  _new: Pt("new", { beforeExpr: vt, startsExpr: gt }),
  _this: Pt("this", { startsExpr: gt }),
  _super: Pt("super", { startsExpr: gt }),
  _class: Pt("class", { startsExpr: gt }),
  _extends: Pt("extends", { beforeExpr: vt }),
  _export: Pt("export"),
  _import: Pt("import", { startsExpr: gt }),
  _null: Pt("null", { startsExpr: gt }),
  _true: Pt("true", { startsExpr: gt }),
  _false: Pt("false", { startsExpr: gt }),
  _typeof: Pt("typeof", { beforeExpr: vt, prefix: St, startsExpr: gt }),
  _void: Pt("void", { beforeExpr: vt, prefix: St, startsExpr: gt }),
  _delete: Pt("delete", { beforeExpr: vt, prefix: St, startsExpr: gt }),
  _do: Pt("do", { isLoop: bt, beforeExpr: vt }),
  _for: Pt("for", { isLoop: bt }),
  _while: Pt("while", { isLoop: bt }),
  _as: Lt("as", { startsExpr: gt }),
  _assert: Lt("assert", { startsExpr: gt }),
  _async: Lt("async", { startsExpr: gt }),
  _await: Lt("await", { startsExpr: gt }),
  _from: Lt("from", { startsExpr: gt }),
  _get: Lt("get", { startsExpr: gt }),
  _let: Lt("let", { startsExpr: gt }),
  _meta: Lt("meta", { startsExpr: gt }),
  _of: Lt("of", { startsExpr: gt }),
  _sent: Lt("sent", { startsExpr: gt }),
  _set: Lt("set", { startsExpr: gt }),
  _static: Lt("static", { startsExpr: gt }),
  _using: Lt("using", { startsExpr: gt }),
  _yield: Lt("yield", { startsExpr: gt }),
  _asserts: Lt("asserts", { startsExpr: gt }),
  _checks: Lt("checks", { startsExpr: gt }),
  _exports: Lt("exports", { startsExpr: gt }),
  _global: Lt("global", { startsExpr: gt }),
  _implements: Lt("implements", { startsExpr: gt }),
  _intrinsic: Lt("intrinsic", { startsExpr: gt }),
  _infer: Lt("infer", { startsExpr: gt }),
  _is: Lt("is", { startsExpr: gt }),
  _mixins: Lt("mixins", { startsExpr: gt }),
  _proto: Lt("proto", { startsExpr: gt }),
  _require: Lt("require", { startsExpr: gt }),
  _satisfies: Lt("satisfies", { startsExpr: gt }),
  _keyof: Lt("keyof", { startsExpr: gt }),
  _readonly: Lt("readonly", { startsExpr: gt }),
  _unique: Lt("unique", { startsExpr: gt }),
  _abstract: Lt("abstract", { startsExpr: gt }),
  _declare: Lt("declare", { startsExpr: gt }),
  _enum: Lt("enum", { startsExpr: gt }),
  _module: Lt("module", { startsExpr: gt }),
  _namespace: Lt("namespace", { startsExpr: gt }),
  _interface: Lt("interface", { startsExpr: gt }),
  _type: Lt("type", { startsExpr: gt }),
  _opaque: Lt("opaque", { startsExpr: gt }),
  name: Dt("name", { startsExpr: gt }),
  string: Dt("string", { startsExpr: gt }),
  num: Dt("num", { startsExpr: gt }),
  bigint: Dt("bigint", { startsExpr: gt }),
  decimal: Dt("decimal", { startsExpr: gt }),
  regexp: Dt("regexp", { startsExpr: gt }),
  privateName: Dt("#name", { startsExpr: gt }),
  eof: Dt("eof"),
  jsxName: Dt("jsxName"),
  jsxText: Dt("jsxText", { beforeExpr: !0 }),
  jsxTagStart: Dt("jsxTagStart", { startsExpr: !0 }),
  jsxTagEnd: Dt("jsxTagEnd"),
  placeholder: Dt("%%", { startsExpr: !0 }),
};
function jt(e) {
  return e >= 93 && e <= 130;
}
function Ft(e) {
  return e >= 58 && e <= 130;
}
function Bt(e) {
  return e >= 58 && e <= 134;
}
function Rt(e) {
  return Nt[e];
}
function Ut(e) {
  return e >= 127 && e <= 129;
}
function Vt(e) {
  return e >= 58 && e <= 92;
}
function Kt(e) {
  return Ct[e];
}
function Wt(e) {
  return It[e];
}
function qt(e) {
  return e >= 24 && e <= 25;
}
function Ht(e) {
  return wt[e];
}
(wt[8].updateContext = function (e) {
  e.pop();
}),
  (wt[5].updateContext =
    wt[7].updateContext =
    wt[23].updateContext =
      function (e) {
        e.push(mt.brace);
      }),
  (wt[22].updateContext = function (e) {
    e[e.length - 1] === mt.template ? e.pop() : e.push(mt.template);
  }),
  (wt[140].updateContext = function (e) {
    e.push(mt.j_expr, mt.j_oTag);
  });
var Yt =
    "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
  Jt =
    "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿",
  Xt = new RegExp("[" + Yt + "]"),
  Gt = new RegExp("[" + Yt + Jt + "]");
Yt = Jt = null;
var zt = [
    0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48,
    48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5,
    39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10,
    21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11,
    22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2,
    2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72,
    56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20,
    28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4,
    0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2,
    14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4,
    159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0,
    60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2,
    23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12,
    45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0,
    26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921,
    103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30,
    18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67,
    12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16,
    0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2,
    70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2,
    27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2,
    24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11,
    6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60,
    67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5,
    0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0,
    3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719,
    33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191,
  ],
  $t = [
    509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1,
    574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1,
    11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13,
    9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3,
    2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3,
    8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5,
    2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0,
    10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2,
    6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4,
    14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
    8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31,
    3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2,
    16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983,
    6, 110, 6, 6, 9, 4759, 9, 787719, 239,
  ];
function Qt(e, t) {
  for (var r = 65536, n = 0, i = t.length; n < i; n += 2) {
    if ((r += t[n]) > e) return !1;
    if ((r += t[n + 1]) >= e) return !0;
  }
  return !1;
}
function Zt(e) {
  return e < 65
    ? 36 === e
    : e <= 90 ||
        (e < 97
          ? 95 === e
          : e <= 122 ||
            (e <= 65535
              ? e >= 170 && Xt.test(String.fromCharCode(e))
              : Qt(e, zt)));
}
function er(e) {
  return e < 48
    ? 36 === e
    : e < 58 ||
        (!(e < 65) &&
          (e <= 90 ||
            (e < 97
              ? 95 === e
              : e <= 122 ||
                (e <= 65535
                  ? e >= 170 && Gt.test(String.fromCharCode(e))
                  : Qt(e, zt) || Qt(e, $t)))));
}
var tr = [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield",
  ],
  rr = ["eval", "arguments"],
  nr = new Set([
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete",
  ]),
  ir = new Set(tr),
  ar = new Set(rr);
function sr(e, t) {
  return (t && "await" === e) || "enum" === e;
}
function or(e, t) {
  return sr(e, t) || ir.has(e);
}
function lr(e) {
  return ar.has(e);
}
function ur(e, t) {
  return or(e, t) || lr(e);
}
var cr = new Set([
  "break",
  "case",
  "catch",
  "continue",
  "debugger",
  "default",
  "do",
  "else",
  "finally",
  "for",
  "function",
  "if",
  "return",
  "switch",
  "throw",
  "try",
  "var",
  "const",
  "while",
  "with",
  "new",
  "this",
  "super",
  "class",
  "extends",
  "export",
  "import",
  "null",
  "true",
  "false",
  "in",
  "instanceof",
  "typeof",
  "void",
  "delete",
  "implements",
  "interface",
  "let",
  "package",
  "private",
  "protected",
  "public",
  "static",
  "yield",
  "eval",
  "arguments",
  "enum",
  "await",
]);
var pr = 64,
  hr = 128,
  dr = 256,
  fr = 387,
  yr = 128,
  mr = 1024,
  vr = 2048,
  gr = 4096,
  br = 8192,
  Tr = 8201,
  Sr = 64,
  xr = A(function e(t) {
    E(this, e),
      (this.var = new Set()),
      (this.lexical = new Set()),
      (this.functions = new Set()),
      (this.flags = t);
  }),
  Er = (function () {
    function e(t, r) {
      E(this, e),
        (this.parser = void 0),
        (this.scopeStack = []),
        (this.inModule = void 0),
        (this.undefinedExports = new Map()),
        (this.parser = t),
        (this.inModule = r);
    }
    return (
      A(e, [
        {
          key: "inTopLevel",
          get: function () {
            return (1 & this.currentScope().flags) > 0;
          },
        },
        {
          key: "inFunction",
          get: function () {
            return (2 & this.currentVarScopeFlags()) > 0;
          },
        },
        {
          key: "allowSuper",
          get: function () {
            return (16 & this.currentThisScopeFlags()) > 0;
          },
        },
        {
          key: "allowDirectSuper",
          get: function () {
            return (32 & this.currentThisScopeFlags()) > 0;
          },
        },
        {
          key: "inClass",
          get: function () {
            return (this.currentThisScopeFlags() & pr) > 0;
          },
        },
        {
          key: "inClassAndNotInNonArrowFunction",
          get: function () {
            var e = this.currentThisScopeFlags();
            return (e & pr) > 0 && 0 == (2 & e);
          },
        },
        {
          key: "inStaticBlock",
          get: function () {
            for (var e = this.scopeStack.length - 1; ; e--) {
              var t = this.scopeStack[e].flags;
              if (t & hr) return !0;
              if (451 & t) return !1;
            }
          },
        },
        {
          key: "inNonArrowFunction",
          get: function () {
            return (2 & this.currentThisScopeFlags()) > 0;
          },
        },
        {
          key: "treatFunctionsAsVar",
          get: function () {
            return this.treatFunctionsAsVarInScope(this.currentScope());
          },
        },
        {
          key: "createScope",
          value: function (e) {
            return new xr(e);
          },
        },
        {
          key: "enter",
          value: function (e) {
            this.scopeStack.push(this.createScope(e));
          },
        },
        {
          key: "exit",
          value: function () {
            return this.scopeStack.pop().flags;
          },
        },
        {
          key: "treatFunctionsAsVarInScope",
          value: function (e) {
            return !!(130 & e.flags || (!this.parser.inModule && 1 & e.flags));
          },
        },
        {
          key: "declareName",
          value: function (e, t, r) {
            var n = this.currentScope();
            if (8 & t || 16 & t)
              this.checkRedeclarationInScope(n, e, t, r),
                16 & t ? n.functions.add(e) : n.lexical.add(e),
                8 & t && this.maybeExportDefined(n, e);
            else if (4 & t)
              for (
                var i = this.scopeStack.length - 1;
                i >= 0 &&
                ((n = this.scopeStack[i]),
                this.checkRedeclarationInScope(n, e, t, r),
                n.var.add(e),
                this.maybeExportDefined(n, e),
                !(n.flags & fr));
                --i
              );
            this.parser.inModule &&
              1 & n.flags &&
              this.undefinedExports.delete(e);
          },
        },
        {
          key: "maybeExportDefined",
          value: function (e, t) {
            this.parser.inModule &&
              1 & e.flags &&
              this.undefinedExports.delete(t);
          },
        },
        {
          key: "checkRedeclarationInScope",
          value: function (e, t, r, n) {
            this.isRedeclaredInScope(e, t, r) &&
              this.parser.raise(pt.VarRedeclaration, {
                at: n,
                identifierName: t,
              });
          },
        },
        {
          key: "isRedeclaredInScope",
          value: function (e, t, r) {
            return (
              !!(1 & r) &&
              (8 & r
                ? e.lexical.has(t) || e.functions.has(t) || e.var.has(t)
                : 16 & r
                ? e.lexical.has(t) ||
                  (!this.treatFunctionsAsVarInScope(e) && e.var.has(t))
                : (e.lexical.has(t) &&
                    !(8 & e.flags && e.lexical.values().next().value === t)) ||
                  (!this.treatFunctionsAsVarInScope(e) && e.functions.has(t)))
            );
          },
        },
        {
          key: "checkLocalExport",
          value: function (e) {
            var t = e.name,
              r = this.scopeStack[0];
            r.lexical.has(t) ||
              r.var.has(t) ||
              r.functions.has(t) ||
              this.undefinedExports.set(t, e.loc.start);
          },
        },
        {
          key: "currentScope",
          value: function () {
            return this.scopeStack[this.scopeStack.length - 1];
          },
        },
        {
          key: "currentVarScopeFlags",
          value: function () {
            for (var e = this.scopeStack.length - 1; ; e--) {
              var t = this.scopeStack[e].flags;
              if (t & fr) return t;
            }
          },
        },
        {
          key: "currentThisScopeFlags",
          value: function () {
            for (var e = this.scopeStack.length - 1; ; e--) {
              var t = this.scopeStack[e].flags;
              if (451 & t && !(4 & t)) return t;
            }
          },
        },
      ]),
      e
    );
  })(),
  Pr = (function (e) {
    I(r, xr);
    var t = Je(r);
    function r() {
      var e;
      E(this, r);
      for (var n = arguments.length, i = new Array(n), a = 0; a < n; a++)
        i[a] = arguments[a];
      return (
        ((e = t.call.apply(t, [this].concat(i))).declareFunctions = new Set()),
        e
      );
    }
    return A(r);
  })(),
  Ar = (function (e) {
    I(r, Er);
    var t = Je(r);
    function r() {
      return E(this, r), t.apply(this, arguments);
    }
    return (
      A(r, [
        {
          key: "createScope",
          value: function (e) {
            return new Pr(e);
          },
        },
        {
          key: "declareName",
          value: function (e, t, n) {
            var i = this.currentScope();
            if (t & vr)
              return (
                this.checkRedeclarationInScope(i, e, t, n),
                this.maybeExportDefined(i, e),
                void i.declareFunctions.add(e)
              );
            Fe(N(r.prototype), "declareName", this).call(this, e, t, n);
          },
        },
        {
          key: "isRedeclaredInScope",
          value: function (e, t, n) {
            return (
              !!Fe(N(r.prototype), "isRedeclaredInScope", this).call(
                this,
                e,
                t,
                n
              ) ||
              (!!(n & vr) &&
                !e.declareFunctions.has(t) &&
                (e.lexical.has(t) || e.functions.has(t)))
            );
          },
        },
        {
          key: "checkLocalExport",
          value: function (e) {
            this.scopeStack[0].declareFunctions.has(e.name) ||
              Fe(N(r.prototype), "checkLocalExport", this).call(this, e);
          },
        },
      ]),
      r
    );
  })(),
  kr = (function () {
    function e() {
      E(this, e),
        (this.sawUnambiguousESM = !1),
        (this.ambiguousScriptDifferentAst = !1);
    }
    return (
      A(e, [
        {
          key: "hasPlugin",
          value: function (e) {
            if ("string" == typeof e) return this.plugins.has(e);
            var t = H(e, 2),
              r = t[0],
              n = t[1];
            if (!this.hasPlugin(r)) return !1;
            for (
              var i = this.plugins.get(r), a = 0, s = Object.keys(n);
              a < s.length;
              a++
            ) {
              var o = s[a];
              if ((null == i ? void 0 : i[o]) !== n[o]) return !1;
            }
            return !0;
          },
        },
        {
          key: "getPluginOption",
          value: function (e, t) {
            var r;
            return null == (r = this.plugins.get(e)) ? void 0 : r[t];
          },
        },
      ]),
      e
    );
  })();
function wr(e, t) {
  var r;
  void 0 === e.trailingComments
    ? (e.trailingComments = t)
    : (r = e.trailingComments).unshift.apply(r, K(t));
}
function Cr(e, t) {
  var r;
  void 0 === e.innerComments
    ? (e.innerComments = t)
    : (r = e.innerComments).unshift.apply(r, K(t));
}
function Ir(e, t, r) {
  for (var n = null, i = t.length; null === n && i > 0; ) n = t[--i];
  null === n || n.start > r.start ? Cr(e, r.comments) : wr(n, r.comments);
}
var Or = (function (e) {
    I(r, kr);
    var t = Je(r);
    function r() {
      return E(this, r), t.apply(this, arguments);
    }
    return (
      A(r, [
        {
          key: "addComment",
          value: function (e) {
            this.filename && (e.loc.filename = this.filename),
              this.state.comments.push(e);
          },
        },
        {
          key: "processComment",
          value: function (e) {
            var t = this.state.commentStack,
              r = t.length;
            if (0 !== r) {
              var n = r - 1,
                i = t[n];
              i.start === e.end && ((i.leadingNode = e), n--);
              for (var a = e.start; n >= 0; n--) {
                var s = t[n],
                  o = s.end;
                if (!(o > a)) {
                  o === a && (s.trailingNode = e);
                  break;
                }
                (s.containingNode = e), this.finalizeComment(s), t.splice(n, 1);
              }
            }
          },
        },
        {
          key: "finalizeComment",
          value: function (e) {
            var t = e.comments;
            if (null !== e.leadingNode || null !== e.trailingNode)
              null !== e.leadingNode && wr(e.leadingNode, t),
                null !== e.trailingNode &&
                  (function (e, t) {
                    var r;
                    void 0 === e.leadingComments
                      ? (e.leadingComments = t)
                      : (r = e.leadingComments).unshift.apply(r, K(t));
                  })(e.trailingNode, t);
            else {
              var r = e.containingNode,
                n = e.start;
              if (44 === this.input.charCodeAt(n - 1))
                switch (r.type) {
                  case "ObjectExpression":
                  case "ObjectPattern":
                  case "RecordExpression":
                    Ir(r, r.properties, e);
                    break;
                  case "CallExpression":
                  case "OptionalCallExpression":
                    Ir(r, r.arguments, e);
                    break;
                  case "FunctionDeclaration":
                  case "FunctionExpression":
                  case "ArrowFunctionExpression":
                  case "ObjectMethod":
                  case "ClassMethod":
                  case "ClassPrivateMethod":
                    Ir(r, r.params, e);
                    break;
                  case "ArrayExpression":
                  case "ArrayPattern":
                  case "TupleExpression":
                    Ir(r, r.elements, e);
                    break;
                  case "ExportNamedDeclaration":
                  case "ImportDeclaration":
                    Ir(r, r.specifiers, e);
                    break;
                  default:
                    Cr(r, t);
                }
              else Cr(r, t);
            }
          },
        },
        {
          key: "finalizeRemainingComments",
          value: function () {
            for (var e = this.state.commentStack, t = e.length - 1; t >= 0; t--)
              this.finalizeComment(e[t]);
            this.state.commentStack = [];
          },
        },
        {
          key: "resetPreviousNodeTrailingComments",
          value: function (e) {
            var t = this.state.commentStack,
              r = t.length;
            if (0 !== r) {
              var n = t[r - 1];
              n.leadingNode === e && (n.leadingNode = null);
            }
          },
        },
        {
          key: "takeSurroundingComments",
          value: function (e, t, r) {
            var n = this.state.commentStack,
              i = n.length;
            if (0 !== i)
              for (var a = i - 1; a >= 0; a--) {
                var s = n[a],
                  o = s.end;
                if (s.start === r) s.leadingNode = e;
                else if (o === t) s.trailingNode = e;
                else if (o < t) break;
              }
          },
        },
      ]),
      r
    );
  })(),
  Nr = /\r\n?|[\n\u2028\u2029]/,
  _r = new RegExp(Nr.source, "g");
function Dr(e) {
  switch (e) {
    case 10:
    case 13:
    case 8232:
    case 8233:
      return !0;
    default:
      return !1;
  }
}
var Lr = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g,
  Mr = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g,
  jr = new RegExp(
    "(?=(" +
      Mr.source +
      "))\\1" +
      /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source,
    "y"
  );
function Fr(e) {
  switch (e) {
    case 9:
    case 11:
    case 12:
    case 32:
    case 160:
    case 5760:
    case 8192:
    case 8193:
    case 8194:
    case 8195:
    case 8196:
    case 8197:
    case 8198:
    case 8199:
    case 8200:
    case 8201:
    case 8202:
    case 8239:
    case 8287:
    case 12288:
    case 65279:
      return !0;
    default:
      return !1;
  }
}
var Br = (function () {
    function e() {
      E(this, e),
        (this.strict = void 0),
        (this.curLine = void 0),
        (this.lineStart = void 0),
        (this.startLoc = void 0),
        (this.endLoc = void 0),
        (this.errors = []),
        (this.potentialArrowAt = -1),
        (this.noArrowAt = []),
        (this.noArrowParamsConversionAt = []),
        (this.maybeInArrowParameters = !1),
        (this.inType = !1),
        (this.noAnonFunctionType = !1),
        (this.hasFlowComment = !1),
        (this.isAmbientContext = !1),
        (this.inAbstractClass = !1),
        (this.inDisallowConditionalTypesContext = !1),
        (this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null,
        }),
        (this.soloAwait = !1),
        (this.inFSharpPipelineDirectBody = !1),
        (this.labels = []),
        (this.comments = []),
        (this.commentStack = []),
        (this.pos = 0),
        (this.type = 137),
        (this.value = null),
        (this.start = 0),
        (this.end = 0),
        (this.lastTokEndLoc = null),
        (this.lastTokStartLoc = null),
        (this.lastTokStart = 0),
        (this.context = [mt.brace]),
        (this.canStartJSXElement = !0),
        (this.containsEsc = !1),
        (this.firstInvalidTemplateEscapePos = null),
        (this.strictErrors = new Map()),
        (this.tokensLength = 0);
    }
    return (
      A(e, [
        {
          key: "init",
          value: function (e) {
            var t = e.strictMode,
              r = e.sourceType,
              n = e.startLine,
              i = e.startColumn;
            (this.strict = !1 !== t && (!0 === t || "module" === r)),
              (this.curLine = n),
              (this.lineStart = -i),
              (this.startLoc = this.endLoc = new Ge(n, i, 0));
          },
        },
        {
          key: "curPosition",
          value: function () {
            return new Ge(this.curLine, this.pos - this.lineStart, this.pos);
          },
        },
        {
          key: "clone",
          value: function (t) {
            for (
              var r = new e(), n = Object.keys(this), i = 0, a = n.length;
              i < a;
              i++
            ) {
              var s = n[i],
                o = this[s];
              !t && Array.isArray(o) && (o = o.slice()), (r[s] = o);
            }
            return r;
          },
        },
      ]),
      e
    );
  })(),
  Rr = function (e) {
    return e >= 48 && e <= 57;
  },
  Ur = {
    decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
    hex: new Set([46, 88, 95, 120]),
  },
  Vr = {
    bin: function (e) {
      return 48 === e || 49 === e;
    },
    oct: function (e) {
      return e >= 48 && e <= 55;
    },
    dec: function (e) {
      return e >= 48 && e <= 57;
    },
    hex: function (e) {
      return (
        (e >= 48 && e <= 57) || (e >= 65 && e <= 70) || (e >= 97 && e <= 102)
      );
    },
  };
function Kr(e, t, r, n, i, a) {
  for (var s = r, o = n, l = i, u = "", c = null, p = r, h = t.length; ; ) {
    if (r >= h) {
      a.unterminated(s, o, l), (u += t.slice(p, r));
      break;
    }
    var d = t.charCodeAt(r);
    if (Wr(e, d, t, r)) {
      u += t.slice(p, r);
      break;
    }
    if (92 === d) {
      u += t.slice(p, r);
      var f = qr(t, r, n, i, "template" === e, a);
      null !== f.ch || c
        ? (u += f.ch)
        : (c = { pos: r, lineStart: n, curLine: i }),
        (r = f.pos),
        (n = f.lineStart),
        (i = f.curLine),
        (p = r);
    } else
      8232 === d || 8233 === d
        ? (++i, (n = ++r))
        : 10 === d || 13 === d
        ? "template" === e
          ? ((u += t.slice(p, r) + "\n"),
            ++r,
            13 === d && 10 === t.charCodeAt(r) && ++r,
            ++i,
            (p = n = r))
          : a.unterminated(s, o, l)
        : ++r;
  }
  return {
    pos: r,
    str: u,
    firstInvalidLoc: c,
    lineStart: n,
    curLine: i,
    containsInvalid: !!c,
  };
}
function Wr(e, t, r, n) {
  return "template" === e
    ? 96 === t || (36 === t && 123 === r.charCodeAt(n + 1))
    : t === ("double" === e ? 34 : 39);
}
function qr(e, t, r, n, i, a) {
  var s = !i;
  t++;
  var o = function (e) {
      return { pos: t, ch: e, lineStart: r, curLine: n };
    },
    l = e.charCodeAt(t++);
  switch (l) {
    case 110:
      return o("\n");
    case 114:
      return o("\r");
    case 120:
      var u,
        c = Hr(e, t, r, n, 2, !1, s, a);
      return (
        (u = c.code), (t = c.pos), o(null === u ? null : String.fromCharCode(u))
      );
    case 117:
      var p,
        h = Jr(e, t, r, n, s, a);
      return (
        (p = h.code),
        (t = h.pos),
        o(null === p ? null : String.fromCodePoint(p))
      );
    case 116:
      return o("\t");
    case 98:
      return o("\b");
    case 118:
      return o("\v");
    case 102:
      return o("\f");
    case 13:
      10 === e.charCodeAt(t) && ++t;
    case 10:
      (r = t), ++n;
    case 8232:
    case 8233:
      return o("");
    case 56:
    case 57:
      if (i) return o(null);
      a.strictNumericEscape(t - 1, r, n);
    default:
      if (l >= 48 && l <= 55) {
        var d = t - 1,
          f = e.slice(d, t + 2).match(/^[0-7]+/)[0],
          y = parseInt(f, 8);
        y > 255 && ((f = f.slice(0, -1)), (y = parseInt(f, 8))),
          (t += f.length - 1);
        var m = e.charCodeAt(t);
        if ("0" !== f || 56 === m || 57 === m) {
          if (i) return o(null);
          a.strictNumericEscape(d, r, n);
        }
        return o(String.fromCharCode(y));
      }
      return o(String.fromCharCode(l));
  }
}
function Hr(e, t, r, n, i, a, s, o) {
  var l,
    u = t,
    c = Yr(e, t, r, n, 16, i, a, !1, o, !s);
  return (
    (l = c.n),
    (t = c.pos),
    null === l && (s ? o.invalidEscapeSequence(u, r, n) : (t = u - 1)),
    { code: l, pos: t }
  );
}
function Yr(e, t, r, n, i, a, s, o, l, u) {
  for (
    var c = t,
      p = 16 === i ? Ur.hex : Ur.decBinOct,
      h = 16 === i ? Vr.hex : 10 === i ? Vr.dec : 8 === i ? Vr.oct : Vr.bin,
      d = !1,
      f = 0,
      y = 0,
      m = null == a ? 1 / 0 : a;
    y < m;
    ++y
  ) {
    var v = e.charCodeAt(t),
      g = void 0;
    if (95 !== v || "bail" === o) {
      if (
        (g =
          v >= 97
            ? v - 97 + 10
            : v >= 65
            ? v - 65 + 10
            : Rr(v)
            ? v - 48
            : 1 / 0) >= i
      ) {
        if (g <= 9 && u) return { n: null, pos: t };
        if (g <= 9 && l.invalidDigit(t, r, n, i)) g = 0;
        else {
          if (!s) break;
          (g = 0), (d = !0);
        }
      }
      ++t, (f = f * i + g);
    } else {
      var b = e.charCodeAt(t - 1),
        T = e.charCodeAt(t + 1);
      if (o) {
        if (Number.isNaN(T) || !h(T) || p.has(b) || p.has(T)) {
          if (u) return { n: null, pos: t };
          l.unexpectedNumericSeparator(t, r, n);
        }
      } else {
        if (u) return { n: null, pos: t };
        l.numericSeparatorInEscapeSequence(t, r, n);
      }
      ++t;
    }
  }
  return t === c || (null != a && t - c !== a) || d
    ? { n: null, pos: t }
    : { n: f, pos: t };
}
function Jr(e, t, r, n, i, a) {
  var s;
  if (123 === e.charCodeAt(t)) {
    var o = Hr(e, ++t, r, n, e.indexOf("}", t) - t, !0, i, a);
    if (((s = o.code), (t = o.pos), ++t, null !== s && s > 1114111)) {
      if (!i) return { code: null, pos: t };
      a.invalidCodePoint(t, r, n);
    }
  } else {
    var l = Hr(e, t, r, n, 4, !1, i, a);
    (s = l.code), (t = l.pos);
  }
  return { code: s, pos: t };
}
var Xr = ["at"],
  Gr = ["at"];
function zr(e, t, r) {
  return new Ge(r, e - t, e);
}
var $r = new Set([103, 109, 115, 105, 121, 117, 100, 118]),
  Qr = A(function e(t) {
    E(this, e),
      (this.type = t.type),
      (this.value = t.value),
      (this.start = t.start),
      (this.end = t.end),
      (this.loc = new ze(t.startLoc, t.endLoc));
  }),
  Zr = (function (e) {
    I(r, Or);
    var t = Je(r);
    function r(e, n) {
      var i;
      return (
        E(this, r),
        ((i = t.call(this)).isLookahead = void 0),
        (i.tokens = []),
        (i.errorHandlers_readInt = {
          invalidDigit: function (e, t, r, n) {
            return (
              !!i.options.errorRecovery &&
              (i.raise(pt.InvalidDigit, { at: zr(e, t, r), radix: n }), !0)
            );
          },
          numericSeparatorInEscapeSequence: i.errorBuilder(
            pt.NumericSeparatorInEscapeSequence
          ),
          unexpectedNumericSeparator: i.errorBuilder(
            pt.UnexpectedNumericSeparator
          ),
        }),
        (i.errorHandlers_readCodePoint = Object.assign(
          {},
          i.errorHandlers_readInt,
          {
            invalidEscapeSequence: i.errorBuilder(pt.InvalidEscapeSequence),
            invalidCodePoint: i.errorBuilder(pt.InvalidCodePoint),
          }
        )),
        (i.errorHandlers_readStringContents_string = Object.assign(
          {},
          i.errorHandlers_readCodePoint,
          {
            strictNumericEscape: function (e, t, r) {
              i.recordStrictModeErrors(pt.StrictNumericEscape, {
                at: zr(e, t, r),
              });
            },
            unterminated: function (e, t, r) {
              throw i.raise(pt.UnterminatedString, { at: zr(e - 1, t, r) });
            },
          }
        )),
        (i.errorHandlers_readStringContents_template = Object.assign(
          {},
          i.errorHandlers_readCodePoint,
          {
            strictNumericEscape: i.errorBuilder(pt.StrictNumericEscape),
            unterminated: function (e, t, r) {
              throw i.raise(pt.UnterminatedTemplate, { at: zr(e, t, r) });
            },
          }
        )),
        (i.state = new Br()),
        i.state.init(e),
        (i.input = n),
        (i.length = n.length),
        (i.isLookahead = !1),
        i
      );
    }
    return (
      A(r, [
        {
          key: "pushToken",
          value: function (e) {
            (this.tokens.length = this.state.tokensLength),
              this.tokens.push(e),
              ++this.state.tokensLength;
          },
        },
        {
          key: "next",
          value: function () {
            this.checkKeywordEscapes(),
              this.options.tokens && this.pushToken(new Qr(this.state)),
              (this.state.lastTokStart = this.state.start),
              (this.state.lastTokEndLoc = this.state.endLoc),
              (this.state.lastTokStartLoc = this.state.startLoc),
              this.nextToken();
          },
        },
        {
          key: "eat",
          value: function (e) {
            return !!this.match(e) && (this.next(), !0);
          },
        },
        {
          key: "match",
          value: function (e) {
            return this.state.type === e;
          },
        },
        {
          key: "createLookaheadState",
          value: function (e) {
            return {
              pos: e.pos,
              value: null,
              type: e.type,
              start: e.start,
              end: e.end,
              context: [this.curContext()],
              inType: e.inType,
              startLoc: e.startLoc,
              lastTokEndLoc: e.lastTokEndLoc,
              curLine: e.curLine,
              lineStart: e.lineStart,
              curPosition: e.curPosition,
            };
          },
        },
        {
          key: "lookahead",
          value: function () {
            var e = this.state;
            (this.state = this.createLookaheadState(e)),
              (this.isLookahead = !0),
              this.nextToken(),
              (this.isLookahead = !1);
            var t = this.state;
            return (this.state = e), t;
          },
        },
        {
          key: "nextTokenStart",
          value: function () {
            return this.nextTokenStartSince(this.state.pos);
          },
        },
        {
          key: "nextTokenStartSince",
          value: function (e) {
            return (Lr.lastIndex = e), Lr.test(this.input) ? Lr.lastIndex : e;
          },
        },
        {
          key: "lookaheadCharCode",
          value: function () {
            return this.input.charCodeAt(this.nextTokenStart());
          },
        },
        {
          key: "nextTokenInLineStart",
          value: function () {
            return this.nextTokenInLineStartSince(this.state.pos);
          },
        },
        {
          key: "nextTokenInLineStartSince",
          value: function (e) {
            return (Mr.lastIndex = e), Mr.test(this.input) ? Mr.lastIndex : e;
          },
        },
        {
          key: "lookaheadInLineCharCode",
          value: function () {
            return this.input.charCodeAt(this.nextTokenInLineStart());
          },
        },
        {
          key: "codePointAtPos",
          value: function (e) {
            var t = this.input.charCodeAt(e);
            if (55296 == (64512 & t) && ++e < this.input.length) {
              var r = this.input.charCodeAt(e);
              56320 == (64512 & r) &&
                (t = 65536 + ((1023 & t) << 10) + (1023 & r));
            }
            return t;
          },
        },
        {
          key: "setStrict",
          value: function (e) {
            var t = this;
            (this.state.strict = e),
              e &&
                (this.state.strictErrors.forEach(function (e) {
                  var r = H(e, 2),
                    n = r[0],
                    i = r[1];
                  return t.raise(n, { at: i });
                }),
                this.state.strictErrors.clear());
          },
        },
        {
          key: "curContext",
          value: function () {
            return this.state.context[this.state.context.length - 1];
          },
        },
        {
          key: "nextToken",
          value: function () {
            this.skipSpace(),
              (this.state.start = this.state.pos),
              this.isLookahead ||
                (this.state.startLoc = this.state.curPosition()),
              this.state.pos >= this.length
                ? this.finishToken(137)
                : this.getTokenFromCode(this.codePointAtPos(this.state.pos));
          },
        },
        {
          key: "skipBlockComment",
          value: function (e) {
            var t;
            this.isLookahead || (t = this.state.curPosition());
            var r = this.state.pos,
              n = this.input.indexOf(e, r + 2);
            if (-1 === n)
              throw this.raise(pt.UnterminatedComment, {
                at: this.state.curPosition(),
              });
            for (
              this.state.pos = n + e.length, _r.lastIndex = r + 2;
              _r.test(this.input) && _r.lastIndex <= n;

            )
              ++this.state.curLine, (this.state.lineStart = _r.lastIndex);
            if (!this.isLookahead) {
              var i = {
                type: "CommentBlock",
                value: this.input.slice(r + 2, n),
                start: r,
                end: n + e.length,
                loc: new ze(t, this.state.curPosition()),
              };
              return this.options.tokens && this.pushToken(i), i;
            }
          },
        },
        {
          key: "skipLineComment",
          value: function (e) {
            var t,
              r = this.state.pos;
            this.isLookahead || (t = this.state.curPosition());
            var n = this.input.charCodeAt((this.state.pos += e));
            if (this.state.pos < this.length)
              for (; !Dr(n) && ++this.state.pos < this.length; )
                n = this.input.charCodeAt(this.state.pos);
            if (!this.isLookahead) {
              var i = this.state.pos,
                a = {
                  type: "CommentLine",
                  value: this.input.slice(r + e, i),
                  start: r,
                  end: i,
                  loc: new ze(t, this.state.curPosition()),
                };
              return this.options.tokens && this.pushToken(a), a;
            }
          },
        },
        {
          key: "skipSpace",
          value: function () {
            var e = this.state.pos,
              t = [];
            e: for (; this.state.pos < this.length; ) {
              var r = this.input.charCodeAt(this.state.pos);
              switch (r) {
                case 32:
                case 160:
                case 9:
                  ++this.state.pos;
                  break;
                case 13:
                  10 === this.input.charCodeAt(this.state.pos + 1) &&
                    ++this.state.pos;
                case 10:
                case 8232:
                case 8233:
                  ++this.state.pos,
                    ++this.state.curLine,
                    (this.state.lineStart = this.state.pos);
                  break;
                case 47:
                  switch (this.input.charCodeAt(this.state.pos + 1)) {
                    case 42:
                      var n = this.skipBlockComment("*/");
                      void 0 !== n &&
                        (this.addComment(n),
                        this.options.attachComment && t.push(n));
                      break;
                    case 47:
                      var i = this.skipLineComment(2);
                      void 0 !== i &&
                        (this.addComment(i),
                        this.options.attachComment && t.push(i));
                      break;
                    default:
                      break e;
                  }
                  break;
                default:
                  if (Fr(r)) ++this.state.pos;
                  else if (45 === r && !this.inModule && this.options.annexB) {
                    var a = this.state.pos;
                    if (
                      45 !== this.input.charCodeAt(a + 1) ||
                      62 !== this.input.charCodeAt(a + 2) ||
                      !(0 === e || this.state.lineStart > e)
                    )
                      break e;
                    var s = this.skipLineComment(3);
                    void 0 !== s &&
                      (this.addComment(s),
                      this.options.attachComment && t.push(s));
                  } else {
                    if (60 !== r || this.inModule || !this.options.annexB)
                      break e;
                    var o = this.state.pos;
                    if (
                      33 !== this.input.charCodeAt(o + 1) ||
                      45 !== this.input.charCodeAt(o + 2) ||
                      45 !== this.input.charCodeAt(o + 3)
                    )
                      break e;
                    var l = this.skipLineComment(4);
                    void 0 !== l &&
                      (this.addComment(l),
                      this.options.attachComment && t.push(l));
                  }
              }
            }
            if (t.length > 0) {
              var u = {
                start: e,
                end: this.state.pos,
                comments: t,
                leadingNode: null,
                trailingNode: null,
                containingNode: null,
              };
              this.state.commentStack.push(u);
            }
          },
        },
        {
          key: "finishToken",
          value: function (e, t) {
            (this.state.end = this.state.pos),
              (this.state.endLoc = this.state.curPosition());
            var r = this.state.type;
            (this.state.type = e),
              (this.state.value = t),
              this.isLookahead || this.updateContext(r);
          },
        },
        {
          key: "replaceToken",
          value: function (e) {
            (this.state.type = e), this.updateContext();
          },
        },
        {
          key: "readToken_numberSign",
          value: function () {
            if (0 !== this.state.pos || !this.readToken_interpreter()) {
              var e = this.state.pos + 1,
                t = this.codePointAtPos(e);
              if (t >= 48 && t <= 57)
                throw this.raise(pt.UnexpectedDigitAfterHash, {
                  at: this.state.curPosition(),
                });
              if (123 === t || (91 === t && this.hasPlugin("recordAndTuple"))) {
                if (
                  (this.expectPlugin("recordAndTuple"),
                  "bar" ===
                    this.getPluginOption("recordAndTuple", "syntaxType"))
                )
                  throw this.raise(
                    123 === t
                      ? pt.RecordExpressionHashIncorrectStartSyntaxType
                      : pt.TupleExpressionHashIncorrectStartSyntaxType,
                    { at: this.state.curPosition() }
                  );
                (this.state.pos += 2),
                  123 === t ? this.finishToken(7) : this.finishToken(1);
              } else
                Zt(t)
                  ? (++this.state.pos, this.finishToken(136, this.readWord1(t)))
                  : 92 === t
                  ? (++this.state.pos, this.finishToken(136, this.readWord1()))
                  : this.finishOp(27, 1);
            }
          },
        },
        {
          key: "readToken_dot",
          value: function () {
            var e = this.input.charCodeAt(this.state.pos + 1);
            e >= 48 && e <= 57
              ? this.readNumber(!0)
              : 46 === e && 46 === this.input.charCodeAt(this.state.pos + 2)
              ? ((this.state.pos += 3), this.finishToken(21))
              : (++this.state.pos, this.finishToken(16));
          },
        },
        {
          key: "readToken_slash",
          value: function () {
            61 === this.input.charCodeAt(this.state.pos + 1)
              ? this.finishOp(31, 2)
              : this.finishOp(56, 1);
          },
        },
        {
          key: "readToken_interpreter",
          value: function () {
            if (0 !== this.state.pos || this.length < 2) return !1;
            var e = this.input.charCodeAt(this.state.pos + 1);
            if (33 !== e) return !1;
            var t = this.state.pos;
            for (
              this.state.pos += 1;
              !Dr(e) && ++this.state.pos < this.length;

            )
              e = this.input.charCodeAt(this.state.pos);
            var r = this.input.slice(t + 2, this.state.pos);
            return this.finishToken(28, r), !0;
          },
        },
        {
          key: "readToken_mult_modulo",
          value: function (e) {
            var t = 42 === e ? 55 : 54,
              r = 1,
              n = this.input.charCodeAt(this.state.pos + 1);
            42 === e &&
              42 === n &&
              (r++, (n = this.input.charCodeAt(this.state.pos + 2)), (t = 57)),
              61 !== n || this.state.inType || (r++, (t = 37 === e ? 33 : 30)),
              this.finishOp(t, r);
          },
        },
        {
          key: "readToken_pipe_amp",
          value: function (e) {
            var t = this.input.charCodeAt(this.state.pos + 1);
            if (t !== e) {
              if (124 === e) {
                if (62 === t) return void this.finishOp(39, 2);
                if (this.hasPlugin("recordAndTuple") && 125 === t) {
                  if (
                    "bar" !==
                    this.getPluginOption("recordAndTuple", "syntaxType")
                  )
                    throw this.raise(
                      pt.RecordExpressionBarIncorrectEndSyntaxType,
                      { at: this.state.curPosition() }
                    );
                  return (this.state.pos += 2), void this.finishToken(9);
                }
                if (this.hasPlugin("recordAndTuple") && 93 === t) {
                  if (
                    "bar" !==
                    this.getPluginOption("recordAndTuple", "syntaxType")
                  )
                    throw this.raise(
                      pt.TupleExpressionBarIncorrectEndSyntaxType,
                      { at: this.state.curPosition() }
                    );
                  return (this.state.pos += 2), void this.finishToken(4);
                }
              }
              61 !== t
                ? this.finishOp(124 === e ? 43 : 45, 1)
                : this.finishOp(30, 2);
            } else
              61 === this.input.charCodeAt(this.state.pos + 2)
                ? this.finishOp(30, 3)
                : this.finishOp(124 === e ? 41 : 42, 2);
          },
        },
        {
          key: "readToken_caret",
          value: function () {
            var e = this.input.charCodeAt(this.state.pos + 1);
            if (61 !== e || this.state.inType)
              if (
                94 === e &&
                this.hasPlugin([
                  "pipelineOperator",
                  { proposal: "hack", topicToken: "^^" },
                ])
              ) {
                this.finishOp(37, 2),
                  94 === this.input.codePointAt(this.state.pos) &&
                    this.unexpected();
              } else this.finishOp(44, 1);
            else this.finishOp(32, 2);
          },
        },
        {
          key: "readToken_atSign",
          value: function () {
            64 === this.input.charCodeAt(this.state.pos + 1) &&
            this.hasPlugin([
              "pipelineOperator",
              { proposal: "hack", topicToken: "@@" },
            ])
              ? this.finishOp(38, 2)
              : this.finishOp(26, 1);
          },
        },
        {
          key: "readToken_plus_min",
          value: function (e) {
            var t = this.input.charCodeAt(this.state.pos + 1);
            t !== e
              ? 61 === t
                ? this.finishOp(30, 2)
                : this.finishOp(53, 1)
              : this.finishOp(34, 2);
          },
        },
        {
          key: "readToken_lt",
          value: function () {
            var e = this.state.pos,
              t = this.input.charCodeAt(e + 1);
            if (60 === t)
              return 61 === this.input.charCodeAt(e + 2)
                ? void this.finishOp(30, 3)
                : void this.finishOp(51, 2);
            61 !== t ? this.finishOp(47, 1) : this.finishOp(49, 2);
          },
        },
        {
          key: "readToken_gt",
          value: function () {
            var e = this.state.pos,
              t = this.input.charCodeAt(e + 1);
            if (62 === t) {
              var r = 62 === this.input.charCodeAt(e + 2) ? 3 : 2;
              return 61 === this.input.charCodeAt(e + r)
                ? void this.finishOp(30, r + 1)
                : void this.finishOp(52, r);
            }
            61 !== t ? this.finishOp(48, 1) : this.finishOp(49, 2);
          },
        },
        {
          key: "readToken_eq_excl",
          value: function (e) {
            var t = this.input.charCodeAt(this.state.pos + 1);
            if (61 !== t)
              return 61 === e && 62 === t
                ? ((this.state.pos += 2), void this.finishToken(19))
                : void this.finishOp(61 === e ? 29 : 35, 1);
            this.finishOp(
              46,
              61 === this.input.charCodeAt(this.state.pos + 2) ? 3 : 2
            );
          },
        },
        {
          key: "readToken_question",
          value: function () {
            var e = this.input.charCodeAt(this.state.pos + 1),
              t = this.input.charCodeAt(this.state.pos + 2);
            63 === e
              ? 61 === t
                ? this.finishOp(30, 3)
                : this.finishOp(40, 2)
              : 46 !== e || (t >= 48 && t <= 57)
              ? (++this.state.pos, this.finishToken(17))
              : ((this.state.pos += 2), this.finishToken(18));
          },
        },
        {
          key: "getTokenFromCode",
          value: function (e) {
            switch (e) {
              case 46:
                return void this.readToken_dot();
              case 40:
                return ++this.state.pos, void this.finishToken(10);
              case 41:
                return ++this.state.pos, void this.finishToken(11);
              case 59:
                return ++this.state.pos, void this.finishToken(13);
              case 44:
                return ++this.state.pos, void this.finishToken(12);
              case 91:
                if (
                  this.hasPlugin("recordAndTuple") &&
                  124 === this.input.charCodeAt(this.state.pos + 1)
                ) {
                  if (
                    "bar" !==
                    this.getPluginOption("recordAndTuple", "syntaxType")
                  )
                    throw this.raise(
                      pt.TupleExpressionBarIncorrectStartSyntaxType,
                      { at: this.state.curPosition() }
                    );
                  (this.state.pos += 2), this.finishToken(2);
                } else ++this.state.pos, this.finishToken(0);
                return;
              case 93:
                return ++this.state.pos, void this.finishToken(3);
              case 123:
                if (
                  this.hasPlugin("recordAndTuple") &&
                  124 === this.input.charCodeAt(this.state.pos + 1)
                ) {
                  if (
                    "bar" !==
                    this.getPluginOption("recordAndTuple", "syntaxType")
                  )
                    throw this.raise(
                      pt.RecordExpressionBarIncorrectStartSyntaxType,
                      { at: this.state.curPosition() }
                    );
                  (this.state.pos += 2), this.finishToken(6);
                } else ++this.state.pos, this.finishToken(5);
                return;
              case 125:
                return ++this.state.pos, void this.finishToken(8);
              case 58:
                return void (this.hasPlugin("functionBind") &&
                58 === this.input.charCodeAt(this.state.pos + 1)
                  ? this.finishOp(15, 2)
                  : (++this.state.pos, this.finishToken(14)));
              case 63:
                return void this.readToken_question();
              case 96:
                return void this.readTemplateToken();
              case 48:
                var t = this.input.charCodeAt(this.state.pos + 1);
                if (120 === t || 88 === t) return void this.readRadixNumber(16);
                if (111 === t || 79 === t) return void this.readRadixNumber(8);
                if (98 === t || 66 === t) return void this.readRadixNumber(2);
              case 49:
              case 50:
              case 51:
              case 52:
              case 53:
              case 54:
              case 55:
              case 56:
              case 57:
                return void this.readNumber(!1);
              case 34:
              case 39:
                return void this.readString(e);
              case 47:
                return void this.readToken_slash();
              case 37:
              case 42:
                return void this.readToken_mult_modulo(e);
              case 124:
              case 38:
                return void this.readToken_pipe_amp(e);
              case 94:
                return void this.readToken_caret();
              case 43:
              case 45:
                return void this.readToken_plus_min(e);
              case 60:
                return void this.readToken_lt();
              case 62:
                return void this.readToken_gt();
              case 61:
              case 33:
                return void this.readToken_eq_excl(e);
              case 126:
                return void this.finishOp(36, 1);
              case 64:
                return void this.readToken_atSign();
              case 35:
                return void this.readToken_numberSign();
              case 92:
                return void this.readWord();
              default:
                if (Zt(e)) return void this.readWord(e);
            }
            throw this.raise(pt.InvalidOrUnexpectedToken, {
              at: this.state.curPosition(),
              unexpected: String.fromCodePoint(e),
            });
          },
        },
        {
          key: "finishOp",
          value: function (e, t) {
            var r = this.input.slice(this.state.pos, this.state.pos + t);
            (this.state.pos += t), this.finishToken(e, r);
          },
        },
        {
          key: "readRegexp",
          value: function () {
            for (
              var e,
                t,
                r = this.state.startLoc,
                n = this.state.start + 1,
                i = this.state.pos;
              ;
              ++i
            ) {
              if (i >= this.length)
                throw this.raise(pt.UnterminatedRegExp, { at: $e(r, 1) });
              var a = this.input.charCodeAt(i);
              if (Dr(a))
                throw this.raise(pt.UnterminatedRegExp, { at: $e(r, 1) });
              if (e) e = !1;
              else {
                if (91 === a) t = !0;
                else if (93 === a && t) t = !1;
                else if (47 === a && !t) break;
                e = 92 === a;
              }
            }
            var s = this.input.slice(n, i);
            ++i;
            for (
              var o = "",
                l = function () {
                  return $e(r, i + 2 - n);
                };
              i < this.length;

            ) {
              var u = this.codePointAtPos(i),
                c = String.fromCharCode(u);
              if ($r.has(u))
                118 === u
                  ? (this.expectPlugin("regexpUnicodeSets", l()),
                    o.includes("u") &&
                      this.raise(pt.IncompatibleRegExpUVFlags, { at: l() }))
                  : 117 === u &&
                    o.includes("v") &&
                    this.raise(pt.IncompatibleRegExpUVFlags, { at: l() }),
                  o.includes(c) &&
                    this.raise(pt.DuplicateRegExpFlags, { at: l() });
              else {
                if (!er(u) && 92 !== u) break;
                this.raise(pt.MalformedRegExpFlags, { at: l() });
              }
              ++i, (o += c);
            }
            (this.state.pos = i),
              this.finishToken(135, { pattern: s, flags: o });
          },
        },
        {
          key: "readInt",
          value: function (e, t) {
            var r =
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
              n =
                !(arguments.length > 3 && void 0 !== arguments[3]) ||
                arguments[3],
              i = Yr(
                this.input,
                this.state.pos,
                this.state.lineStart,
                this.state.curLine,
                e,
                t,
                r,
                n,
                this.errorHandlers_readInt,
                !1
              ),
              a = i.n,
              s = i.pos;
            return (this.state.pos = s), a;
          },
        },
        {
          key: "readRadixNumber",
          value: function (e) {
            var t = this.state.curPosition(),
              r = !1;
            this.state.pos += 2;
            var n = this.readInt(e);
            null == n &&
              this.raise(pt.InvalidDigit, { at: $e(t, 2), radix: e });
            var i = this.input.charCodeAt(this.state.pos);
            if (110 === i) ++this.state.pos, (r = !0);
            else if (109 === i) throw this.raise(pt.InvalidDecimal, { at: t });
            if (Zt(this.codePointAtPos(this.state.pos)))
              throw this.raise(pt.NumberIdentifier, {
                at: this.state.curPosition(),
              });
            if (r) {
              var a = this.input
                .slice(t.index, this.state.pos)
                .replace(/[_n]/g, "");
              this.finishToken(133, a);
            } else this.finishToken(132, n);
          },
        },
        {
          key: "readNumber",
          value: function (e) {
            var t = this.state.pos,
              r = this.state.curPosition(),
              n = !1,
              i = !1,
              a = !1,
              s = !1,
              o = !1;
            e ||
              null !== this.readInt(10) ||
              this.raise(pt.InvalidNumber, { at: this.state.curPosition() });
            var l = this.state.pos - t >= 2 && 48 === this.input.charCodeAt(t);
            if (l) {
              var u = this.input.slice(t, this.state.pos);
              if (
                (this.recordStrictModeErrors(pt.StrictOctalLiteral, { at: r }),
                !this.state.strict)
              ) {
                var c = u.indexOf("_");
                c > 0 &&
                  this.raise(pt.ZeroDigitNumericSeparator, { at: $e(r, c) });
              }
              o = l && !/[89]/.test(u);
            }
            var p = this.input.charCodeAt(this.state.pos);
            if (
              (46 !== p ||
                o ||
                (++this.state.pos,
                this.readInt(10),
                (n = !0),
                (p = this.input.charCodeAt(this.state.pos))),
              (69 !== p && 101 !== p) ||
                o ||
                ((43 !== (p = this.input.charCodeAt(++this.state.pos)) &&
                  45 !== p) ||
                  ++this.state.pos,
                null === this.readInt(10) &&
                  this.raise(pt.InvalidOrMissingExponent, { at: r }),
                (n = !0),
                (s = !0),
                (p = this.input.charCodeAt(this.state.pos))),
              110 === p &&
                ((n || l) && this.raise(pt.InvalidBigIntLiteral, { at: r }),
                ++this.state.pos,
                (i = !0)),
              109 === p &&
                (this.expectPlugin("decimal", this.state.curPosition()),
                (s || l) && this.raise(pt.InvalidDecimal, { at: r }),
                ++this.state.pos,
                (a = !0)),
              Zt(this.codePointAtPos(this.state.pos)))
            )
              throw this.raise(pt.NumberIdentifier, {
                at: this.state.curPosition(),
              });
            var h = this.input.slice(t, this.state.pos).replace(/[_mn]/g, "");
            if (i) this.finishToken(133, h);
            else if (a) this.finishToken(134, h);
            else {
              var d = o ? parseInt(h, 8) : parseFloat(h);
              this.finishToken(132, d);
            }
          },
        },
        {
          key: "readCodePoint",
          value: function (e) {
            var t = Jr(
                this.input,
                this.state.pos,
                this.state.lineStart,
                this.state.curLine,
                e,
                this.errorHandlers_readCodePoint
              ),
              r = t.code,
              n = t.pos;
            return (this.state.pos = n), r;
          },
        },
        {
          key: "readString",
          value: function (e) {
            var t = Kr(
                34 === e ? "double" : "single",
                this.input,
                this.state.pos + 1,
                this.state.lineStart,
                this.state.curLine,
                this.errorHandlers_readStringContents_string
              ),
              r = t.str,
              n = t.pos,
              i = t.curLine,
              a = t.lineStart;
            (this.state.pos = n + 1),
              (this.state.lineStart = a),
              (this.state.curLine = i),
              this.finishToken(131, r);
          },
        },
        {
          key: "readTemplateContinuation",
          value: function () {
            this.match(8) || this.unexpected(null, 8),
              this.state.pos--,
              this.readTemplateToken();
          },
        },
        {
          key: "readTemplateToken",
          value: function () {
            var e = this.input[this.state.pos],
              t = Kr(
                "template",
                this.input,
                this.state.pos + 1,
                this.state.lineStart,
                this.state.curLine,
                this.errorHandlers_readStringContents_template
              ),
              r = t.str,
              n = t.firstInvalidLoc,
              i = t.pos,
              a = t.curLine,
              s = t.lineStart;
            (this.state.pos = i + 1),
              (this.state.lineStart = s),
              (this.state.curLine = a),
              n &&
                (this.state.firstInvalidTemplateEscapePos = new Ge(
                  n.curLine,
                  n.pos - n.lineStart,
                  n.pos
                )),
              96 === this.input.codePointAt(i)
                ? this.finishToken(24, n ? null : e + r + "`")
                : (this.state.pos++,
                  this.finishToken(25, n ? null : e + r + "${"));
          },
        },
        {
          key: "recordStrictModeErrors",
          value: function (e, t) {
            var r = t.at,
              n = r.index;
            this.state.strict && !this.state.strictErrors.has(n)
              ? this.raise(e, { at: r })
              : this.state.strictErrors.set(n, [e, r]);
          },
        },
        {
          key: "readWord1",
          value: function (e) {
            this.state.containsEsc = !1;
            var t = "",
              r = this.state.pos,
              n = this.state.pos;
            for (
              void 0 !== e && (this.state.pos += e <= 65535 ? 1 : 2);
              this.state.pos < this.length;

            ) {
              var i = this.codePointAtPos(this.state.pos);
              if (er(i)) this.state.pos += i <= 65535 ? 1 : 2;
              else {
                if (92 !== i) break;
                (this.state.containsEsc = !0),
                  (t += this.input.slice(n, this.state.pos));
                var a = this.state.curPosition(),
                  s = this.state.pos === r ? Zt : er;
                if (117 !== this.input.charCodeAt(++this.state.pos)) {
                  this.raise(pt.MissingUnicodeEscape, {
                    at: this.state.curPosition(),
                  }),
                    (n = this.state.pos - 1);
                  continue;
                }
                ++this.state.pos;
                var o = this.readCodePoint(!0);
                null !== o &&
                  (s(o) || this.raise(pt.EscapedCharNotAnIdentifier, { at: a }),
                  (t += String.fromCodePoint(o))),
                  (n = this.state.pos);
              }
            }
            return t + this.input.slice(n, this.state.pos);
          },
        },
        {
          key: "readWord",
          value: function (e) {
            var t = this.readWord1(e),
              r = Et.get(t);
            void 0 !== r
              ? this.finishToken(r, Kt(r))
              : this.finishToken(130, t);
          },
        },
        {
          key: "checkKeywordEscapes",
          value: function () {
            var e = this.state.type;
            Vt(e) &&
              this.state.containsEsc &&
              this.raise(pt.InvalidEscapedReservedWord, {
                at: this.state.startLoc,
                reservedWord: Kt(e),
              });
          },
        },
        {
          key: "raise",
          value: function (e, t) {
            var r = t.at,
              n = Xe(t, Xr),
              i = e({ loc: r instanceof Ge ? r : r.loc.start, details: n });
            if (!this.options.errorRecovery) throw i;
            return this.isLookahead || this.state.errors.push(i), i;
          },
        },
        {
          key: "raiseOverwrite",
          value: function (e, t) {
            for (
              var r = t.at,
                n = Xe(t, Gr),
                i = r instanceof Ge ? r : r.loc.start,
                a = i.index,
                s = this.state.errors,
                o = s.length - 1;
              o >= 0;
              o--
            ) {
              var l = s[o];
              if (l.loc.index === a) return (s[o] = e({ loc: i, details: n }));
              if (l.loc.index < a) break;
            }
            return this.raise(e, t);
          },
        },
        { key: "updateContext", value: function (e) {} },
        {
          key: "unexpected",
          value: function (e, t) {
            throw this.raise(pt.UnexpectedToken, {
              expected: t ? Kt(t) : null,
              at: null != e ? e : this.state.startLoc,
            });
          },
        },
        {
          key: "expectPlugin",
          value: function (e, t) {
            if (this.hasPlugin(e)) return !0;
            throw this.raise(pt.MissingPlugin, {
              at: null != t ? t : this.state.startLoc,
              missingPlugin: [e],
            });
          },
        },
        {
          key: "expectOnePlugin",
          value: function (e) {
            var t = this;
            if (
              !e.some(function (e) {
                return t.hasPlugin(e);
              })
            )
              throw this.raise(pt.MissingOneOfPlugins, {
                at: this.state.startLoc,
                missingPlugin: e,
              });
          },
        },
        {
          key: "errorBuilder",
          value: function (e) {
            var t = this;
            return function (r, n, i) {
              t.raise(e, { at: zr(r, n, i) });
            };
          },
        },
      ]),
      r
    );
  })(),
  en = A(function e() {
    E(this, e),
      (this.privateNames = new Set()),
      (this.loneAccessors = new Map()),
      (this.undefinedPrivateNames = new Map());
  }),
  tn = (function () {
    function e(t) {
      E(this, e),
        (this.parser = void 0),
        (this.stack = []),
        (this.undefinedPrivateNames = new Map()),
        (this.parser = t);
    }
    return (
      A(e, [
        {
          key: "current",
          value: function () {
            return this.stack[this.stack.length - 1];
          },
        },
        {
          key: "enter",
          value: function () {
            this.stack.push(new en());
          },
        },
        {
          key: "exit",
          value: function () {
            for (
              var e = this.stack.pop(),
                t = this.current(),
                r = 0,
                n = Array.from(e.undefinedPrivateNames);
              r < n.length;
              r++
            ) {
              var i = H(n[r], 2),
                a = i[0],
                s = i[1];
              t
                ? t.undefinedPrivateNames.has(a) ||
                  t.undefinedPrivateNames.set(a, s)
                : this.parser.raise(pt.InvalidPrivateFieldResolution, {
                    at: s,
                    identifierName: a,
                  });
            }
          },
        },
        {
          key: "declarePrivateName",
          value: function (e, t, r) {
            var n = this.current(),
              i = n.privateNames,
              a = n.loneAccessors,
              s = n.undefinedPrivateNames,
              o = i.has(e);
            if (3 & t) {
              var l = o && a.get(e);
              if (l)
                (o = (3 & l) === (3 & t) || (4 & l) !== (4 & t)) || a.delete(e);
              else o || a.set(e, t);
            }
            o &&
              this.parser.raise(pt.PrivateNameRedeclaration, {
                at: r,
                identifierName: e,
              }),
              i.add(e),
              s.delete(e);
          },
        },
        {
          key: "usePrivateName",
          value: function (e, t) {
            var r,
              n,
              i = He(this.stack);
            try {
              for (i.s(); !(n = i.n()).done; )
                if ((r = n.value).privateNames.has(e)) return;
            } catch (e) {
              i.e(e);
            } finally {
              i.f();
            }
            r
              ? r.undefinedPrivateNames.set(e, t)
              : this.parser.raise(pt.InvalidPrivateFieldResolution, {
                  at: t,
                  identifierName: e,
                });
          },
        },
      ]),
      e
    );
  })(),
  rn = (function () {
    function e() {
      var t =
        arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 0;
      E(this, e), (this.type = void 0), (this.type = t);
    }
    return (
      A(e, [
        {
          key: "canBeArrowParameterDeclaration",
          value: function () {
            return 2 === this.type || 1 === this.type;
          },
        },
        {
          key: "isCertainlyParameterDeclaration",
          value: function () {
            return 3 === this.type;
          },
        },
      ]),
      e
    );
  })(),
  nn = (function (e) {
    I(r, rn);
    var t = Je(r);
    function r(e) {
      var n;
      return (
        E(this, r), ((n = t.call(this, e)).declarationErrors = new Map()), n
      );
    }
    return (
      A(r, [
        {
          key: "recordDeclarationError",
          value: function (e, t) {
            var r = t.at,
              n = r.index;
            this.declarationErrors.set(n, [e, r]);
          },
        },
        {
          key: "clearDeclarationError",
          value: function (e) {
            this.declarationErrors.delete(e);
          },
        },
        {
          key: "iterateErrors",
          value: function (e) {
            this.declarationErrors.forEach(e);
          },
        },
      ]),
      r
    );
  })(),
  an = (function () {
    function e(t) {
      E(this, e),
        (this.parser = void 0),
        (this.stack = [new rn()]),
        (this.parser = t);
    }
    return (
      A(e, [
        {
          key: "enter",
          value: function (e) {
            this.stack.push(e);
          },
        },
        {
          key: "exit",
          value: function () {
            this.stack.pop();
          },
        },
        {
          key: "recordParameterInitializerError",
          value: function (e, t) {
            for (
              var r = { at: t.at.loc.start },
                n = this.stack,
                i = n.length - 1,
                a = n[i];
              !a.isCertainlyParameterDeclaration();

            ) {
              if (!a.canBeArrowParameterDeclaration()) return;
              a.recordDeclarationError(e, r), (a = n[--i]);
            }
            this.parser.raise(e, r);
          },
        },
        {
          key: "recordArrowParameterBindingError",
          value: function (e, t) {
            var r = t.at,
              n = this.stack,
              i = n[n.length - 1],
              a = { at: r.loc.start };
            if (i.isCertainlyParameterDeclaration()) this.parser.raise(e, a);
            else {
              if (!i.canBeArrowParameterDeclaration()) return;
              i.recordDeclarationError(e, a);
            }
          },
        },
        {
          key: "recordAsyncArrowParametersError",
          value: function (e) {
            for (
              var t = e.at, r = this.stack, n = r.length - 1, i = r[n];
              i.canBeArrowParameterDeclaration();

            )
              2 === i.type &&
                i.recordDeclarationError(pt.AwaitBindingIdentifier, { at: t }),
                (i = r[--n]);
          },
        },
        {
          key: "validateAsPattern",
          value: function () {
            var e = this,
              t = this.stack,
              r = t[t.length - 1];
            r.canBeArrowParameterDeclaration() &&
              r.iterateErrors(function (r) {
                var n = H(r, 2),
                  i = n[0],
                  a = n[1];
                e.parser.raise(i, { at: a });
                for (
                  var s = t.length - 2, o = t[s];
                  o.canBeArrowParameterDeclaration();

                )
                  o.clearDeclarationError(a.index), (o = t[--s]);
              });
          },
        },
      ]),
      e
    );
  })();
function sn() {
  return new rn();
}
var on = (function () {
  function e() {
    E(this, e), (this.stacks = []);
  }
  return (
    A(e, [
      {
        key: "enter",
        value: function (e) {
          this.stacks.push(e);
        },
      },
      {
        key: "exit",
        value: function () {
          this.stacks.pop();
        },
      },
      {
        key: "currentFlags",
        value: function () {
          return this.stacks[this.stacks.length - 1];
        },
      },
      {
        key: "hasAwait",
        get: function () {
          return (2 & this.currentFlags()) > 0;
        },
      },
      {
        key: "hasYield",
        get: function () {
          return (1 & this.currentFlags()) > 0;
        },
      },
      {
        key: "hasReturn",
        get: function () {
          return (4 & this.currentFlags()) > 0;
        },
      },
      {
        key: "hasIn",
        get: function () {
          return (8 & this.currentFlags()) > 0;
        },
      },
    ]),
    e
  );
})();
function ln(e, t) {
  return (e ? 2 : 0) | (t ? 1 : 0);
}
var un = (function (e) {
    I(r, Zr);
    var t = Je(r);
    function r() {
      return E(this, r), t.apply(this, arguments);
    }
    return (
      A(r, [
        {
          key: "addExtra",
          value: function (e, t, r) {
            var n =
              !(arguments.length > 3 && void 0 !== arguments[3]) ||
              arguments[3];
            if (e) {
              var i = (e.extra = e.extra || {});
              n
                ? (i[t] = r)
                : Object.defineProperty(i, t, { enumerable: n, value: r });
            }
          },
        },
        {
          key: "isContextual",
          value: function (e) {
            return this.state.type === e && !this.state.containsEsc;
          },
        },
        {
          key: "isUnparsedContextual",
          value: function (e, t) {
            var r = e + t.length;
            if (this.input.slice(e, r) === t) {
              var n = this.input.charCodeAt(r);
              return !(er(n) || 55296 == (64512 & n));
            }
            return !1;
          },
        },
        {
          key: "isLookaheadContextual",
          value: function (e) {
            var t = this.nextTokenStart();
            return this.isUnparsedContextual(t, e);
          },
        },
        {
          key: "eatContextual",
          value: function (e) {
            return !!this.isContextual(e) && (this.next(), !0);
          },
        },
        {
          key: "expectContextual",
          value: function (e, t) {
            if (!this.eatContextual(e)) {
              if (null != t) throw this.raise(t, { at: this.state.startLoc });
              this.unexpected(null, e);
            }
          },
        },
        {
          key: "canInsertSemicolon",
          value: function () {
            return (
              this.match(137) || this.match(8) || this.hasPrecedingLineBreak()
            );
          },
        },
        {
          key: "hasPrecedingLineBreak",
          value: function () {
            return Nr.test(
              this.input.slice(this.state.lastTokEndLoc.index, this.state.start)
            );
          },
        },
        {
          key: "hasFollowingLineBreak",
          value: function () {
            return (jr.lastIndex = this.state.end), jr.test(this.input);
          },
        },
        {
          key: "isLineTerminator",
          value: function () {
            return this.eat(13) || this.canInsertSemicolon();
          },
        },
        {
          key: "semicolon",
          value: function () {
            (!(arguments.length > 0 && void 0 !== arguments[0]) || arguments[0]
              ? this.isLineTerminator()
              : this.eat(13)) ||
              this.raise(pt.MissingSemicolon, { at: this.state.lastTokEndLoc });
          },
        },
        {
          key: "expect",
          value: function (e, t) {
            this.eat(e) || this.unexpected(t, e);
          },
        },
        {
          key: "tryParse",
          value: function (e) {
            var t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : this.state.clone(),
              r = { node: null };
            try {
              var n = e(function () {
                var e =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : null;
                throw ((r.node = e), r);
              });
              if (this.state.errors.length > t.errors.length) {
                var i = this.state;
                return (
                  (this.state = t),
                  (this.state.tokensLength = i.tokensLength),
                  {
                    node: n,
                    error: i.errors[t.errors.length],
                    thrown: !1,
                    aborted: !1,
                    failState: i,
                  }
                );
              }
              return {
                node: n,
                error: null,
                thrown: !1,
                aborted: !1,
                failState: null,
              };
            } catch (e) {
              var a = this.state;
              if (((this.state = t), e instanceof SyntaxError))
                return {
                  node: null,
                  error: e,
                  thrown: !0,
                  aborted: !1,
                  failState: a,
                };
              if (e === r)
                return {
                  node: r.node,
                  error: null,
                  thrown: !1,
                  aborted: !0,
                  failState: a,
                };
              throw e;
            }
          },
        },
        {
          key: "checkExpressionErrors",
          value: function (e, t) {
            if (!e) return !1;
            var r = e.shorthandAssignLoc,
              n = e.doubleProtoLoc,
              i = e.privateKeyLoc,
              a = e.optionalParametersLoc;
            if (!t) return !!(r || n || a || i);
            null != r && this.raise(pt.InvalidCoverInitializedName, { at: r }),
              null != n && this.raise(pt.DuplicateProto, { at: n }),
              null != i && this.raise(pt.UnexpectedPrivateField, { at: i }),
              null != a && this.unexpected(a);
          },
        },
        {
          key: "isLiteralPropertyName",
          value: function () {
            return Bt(this.state.type);
          },
        },
        {
          key: "isPrivateName",
          value: function (e) {
            return "PrivateName" === e.type;
          },
        },
        {
          key: "getPrivateNameSV",
          value: function (e) {
            return e.id.name;
          },
        },
        {
          key: "hasPropertyAsPrivateName",
          value: function (e) {
            return (
              ("MemberExpression" === e.type ||
                "OptionalMemberExpression" === e.type) &&
              this.isPrivateName(e.property)
            );
          },
        },
        {
          key: "isObjectProperty",
          value: function (e) {
            return "ObjectProperty" === e.type;
          },
        },
        {
          key: "isObjectMethod",
          value: function (e) {
            return "ObjectMethod" === e.type;
          },
        },
        {
          key: "initializeScopes",
          value: function () {
            var e = this,
              t =
                arguments.length > 0 && void 0 !== arguments[0]
                  ? arguments[0]
                  : "module" === this.options.sourceType,
              r = this.state.labels;
            this.state.labels = [];
            var n = this.exportedIdentifiers;
            this.exportedIdentifiers = new Set();
            var i = this.inModule;
            this.inModule = t;
            var a = this.scope,
              s = this.getScopeHandler();
            this.scope = new s(this, t);
            var o = this.prodParam;
            this.prodParam = new on();
            var l = this.classScope;
            this.classScope = new tn(this);
            var u = this.expressionScope;
            return (
              (this.expressionScope = new an(this)),
              function () {
                (e.state.labels = r),
                  (e.exportedIdentifiers = n),
                  (e.inModule = i),
                  (e.scope = a),
                  (e.prodParam = o),
                  (e.classScope = l),
                  (e.expressionScope = u);
              }
            );
          },
        },
        {
          key: "enterInitialScopes",
          value: function () {
            var e = 0;
            this.inModule && (e |= 2),
              this.scope.enter(1),
              this.prodParam.enter(e);
          },
        },
        {
          key: "checkDestructuringPrivate",
          value: function (e) {
            var t = e.privateKeyLoc;
            null !== t && this.expectPlugin("destructuringPrivate", t);
          },
        },
      ]),
      r
    );
  })(),
  cn = A(function e() {
    E(this, e),
      (this.shorthandAssignLoc = null),
      (this.doubleProtoLoc = null),
      (this.privateKeyLoc = null),
      (this.optionalParametersLoc = null);
  }),
  pn = A(function e(t, r, n) {
    E(this, e),
      (this.type = ""),
      (this.start = r),
      (this.end = 0),
      (this.loc = new ze(n)),
      null != t && t.options.ranges && (this.range = [r, 0]),
      null != t && t.filename && (this.loc.filename = t.filename);
  }),
  hn = pn.prototype;
function dn(e) {
  var t = e.type,
    r = e.start,
    n = e.end,
    i = e.loc,
    a = e.range,
    s = e.extra,
    o = e.name,
    l = Object.create(hn);
  return (
    (l.type = t),
    (l.start = r),
    (l.end = n),
    (l.loc = i),
    (l.range = a),
    (l.extra = s),
    (l.name = o),
    "Placeholder" === t && (l.expectedNode = e.expectedNode),
    l
  );
}
function fn(e) {
  var t = e.type,
    r = e.start,
    n = e.end,
    i = e.loc,
    a = e.range,
    s = e.extra;
  if ("Placeholder" === t)
    return (function (e) {
      return dn(e);
    })(e);
  var o = Object.create(hn);
  return (
    (o.type = t),
    (o.start = r),
    (o.end = n),
    (o.loc = i),
    (o.range = a),
    void 0 !== e.raw ? (o.raw = e.raw) : (o.extra = s),
    (o.value = e.value),
    o
  );
}
hn.__clone = function () {
  for (
    var e = new pn(void 0, this.start, this.loc.start),
      t = Object.keys(this),
      r = 0,
      n = t.length;
    r < n;
    r++
  ) {
    var i = t[r];
    "leadingComments" !== i &&
      "trailingComments" !== i &&
      "innerComments" !== i &&
      (e[i] = this[i]);
  }
  return e;
};
var yn = (function (e) {
    I(r, un);
    var t = Je(r);
    function r() {
      return E(this, r), t.apply(this, arguments);
    }
    return (
      A(r, [
        {
          key: "startNode",
          value: function () {
            return new pn(this, this.state.start, this.state.startLoc);
          },
        },
        {
          key: "startNodeAt",
          value: function (e) {
            return new pn(this, e.index, e);
          },
        },
        {
          key: "startNodeAtNode",
          value: function (e) {
            return this.startNodeAt(e.loc.start);
          },
        },
        {
          key: "finishNode",
          value: function (e, t) {
            return this.finishNodeAt(e, t, this.state.lastTokEndLoc);
          },
        },
        {
          key: "finishNodeAt",
          value: function (e, t, r) {
            return (
              (e.type = t),
              (e.end = r.index),
              (e.loc.end = r),
              this.options.ranges && (e.range[1] = r.index),
              this.options.attachComment && this.processComment(e),
              e
            );
          },
        },
        {
          key: "resetStartLocation",
          value: function (e, t) {
            (e.start = t.index),
              (e.loc.start = t),
              this.options.ranges && (e.range[0] = t.index);
          },
        },
        {
          key: "resetEndLocation",
          value: function (e) {
            var t =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : this.state.lastTokEndLoc;
            (e.end = t.index),
              (e.loc.end = t),
              this.options.ranges && (e.range[1] = t.index);
          },
        },
        {
          key: "resetStartLocationFromNode",
          value: function (e, t) {
            this.resetStartLocation(e, t.loc.start);
          },
        },
      ]),
      r
    );
  })(),
  mn = new Set([
    "_",
    "any",
    "bool",
    "boolean",
    "empty",
    "extends",
    "false",
    "interface",
    "mixed",
    "null",
    "number",
    "static",
    "string",
    "true",
    "typeof",
    "void",
  ]),
  vn = ct(Ue || (Ue = Be(["flow"])))({
    AmbiguousConditionalArrow:
      "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
    AmbiguousDeclareModuleKind:
      "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
    AssignReservedType: function (e) {
      var t = e.reservedType;
      return "Cannot overwrite reserved type ".concat(t, ".");
    },
    DeclareClassElement:
      "The `declare` modifier can only appear on class fields.",
    DeclareClassFieldInitializer:
      "Initializers are not allowed in fields with the `declare` modifier.",
    DuplicateDeclareModuleExports:
      "Duplicate `declare module.exports` statement.",
    EnumBooleanMemberNotInitialized: function (e) {
      var t = e.memberName,
        r = e.enumName;
      return "Boolean enum members need to be initialized. Use either `"
        .concat(t, " = true,` or `")
        .concat(t, " = false,` in enum `")
        .concat(r, "`.");
    },
    EnumDuplicateMemberName: function (e) {
      var t = e.memberName,
        r = e.enumName;
      return "Enum member names need to be unique, but the name `"
        .concat(t, "` has already been used before in enum `")
        .concat(r, "`.");
    },
    EnumInconsistentMemberValues: function (e) {
      var t = e.enumName;
      return "Enum `".concat(
        t,
        "` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers."
      );
    },
    EnumInvalidExplicitType: function (e) {
      var t = e.invalidEnumType,
        r = e.enumName;
      return "Enum type `"
        .concat(
          t,
          "` is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `"
        )
        .concat(r, "`.");
    },
    EnumInvalidExplicitTypeUnknownSupplied: function (e) {
      var t = e.enumName;
      return "Supplied enum type is not valid. Use one of `boolean`, `number`, `string`, or `symbol` in enum `".concat(
        t,
        "`."
      );
    },
    EnumInvalidMemberInitializerPrimaryType: function (e) {
      var t = e.enumName,
        r = e.memberName,
        n = e.explicitType;
      return "Enum `"
        .concat(t, "` has type `")
        .concat(n, "`, so the initializer of `")
        .concat(r, "` needs to be a ")
        .concat(n, " literal.");
    },
    EnumInvalidMemberInitializerSymbolType: function (e) {
      var t = e.enumName,
        r = e.memberName;
      return "Symbol enum members cannot be initialized. Use `"
        .concat(r, ",` in enum `")
        .concat(t, "`.");
    },
    EnumInvalidMemberInitializerUnknownType: function (e) {
      var t = e.enumName,
        r = e.memberName;
      return "The enum member initializer for `"
        .concat(
          r,
          "` needs to be a literal (either a boolean, number, or string) in enum `"
        )
        .concat(t, "`.");
    },
    EnumInvalidMemberName: function (e) {
      var t = e.enumName,
        r = e.memberName,
        n = e.suggestion;
      return "Enum member names cannot start with lowercase 'a' through 'z'. Instead of using `"
        .concat(r, "`, consider using `")
        .concat(n, "`, in enum `")
        .concat(t, "`.");
    },
    EnumNumberMemberNotInitialized: function (e) {
      var t = e.enumName,
        r = e.memberName;
      return "Number enum members need to be initialized, e.g. `"
        .concat(r, " = 1` in enum `")
        .concat(t, "`.");
    },
    EnumStringMemberInconsistentlyInitailized: function (e) {
      var t = e.enumName;
      return "String enum members need to consistently either all use initializers, or use no initializers, in enum `".concat(
        t,
        "`."
      );
    },
    GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
    ImportReflectionHasImportType:
      "An `import module` declaration can not use `type` or `typeof` keyword.",
    ImportTypeShorthandOnlyInPureImport:
      "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
    InexactInsideExact:
      "Explicit inexact syntax cannot appear inside an explicit exact object type.",
    InexactInsideNonObject:
      "Explicit inexact syntax cannot appear in class or interface definitions.",
    InexactVariance: "Explicit inexact syntax cannot have variance.",
    InvalidNonTypeImportInDeclareModule:
      "Imports within a `declare module` body must always be `import type` or `import typeof`.",
    MissingTypeParamDefault:
      "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
    NestedDeclareModule:
      "`declare module` cannot be used inside another `declare module`.",
    NestedFlowComment:
      "Cannot have a flow comment inside another flow comment.",
    PatternIsOptional: Object.assign(
      {
        message:
          "A binding pattern parameter cannot be optional in an implementation signature.",
      },
      { reasonCode: "OptionalBindingPattern" }
    ),
    SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
    SpreadVariance: "Spread properties cannot have variance.",
    ThisParamAnnotationRequired:
      "A type annotation is required for the `this` parameter.",
    ThisParamBannedInConstructor:
      "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
    ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
    ThisParamMustBeFirst:
      "The `this` parameter must be the first function parameter.",
    ThisParamNoDefault: "The `this` parameter may not have a default value.",
    TypeBeforeInitializer:
      "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
    TypeCastInPattern:
      "The type cast expression is expected to be wrapped with parenthesis.",
    UnexpectedExplicitInexactInObject:
      "Explicit inexact syntax must appear at the end of an inexact object.",
    UnexpectedReservedType: function (e) {
      var t = e.reservedType;
      return "Unexpected reserved type ".concat(t, ".");
    },
    UnexpectedReservedUnderscore:
      "`_` is only allowed as a type argument to call or new.",
    UnexpectedSpaceBetweenModuloChecks:
      "Spaces between `%` and `checks` are not allowed here.",
    UnexpectedSpreadType:
      "Spread operator cannot appear in class or interface definitions.",
    UnexpectedSubtractionOperand:
      'Unexpected token, expected "number" or "bigint".',
    UnexpectedTokenAfterTypeParameter:
      "Expected an arrow function after this type parameter declaration.",
    UnexpectedTypeParameterBeforeAsyncArrowFunction:
      "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
    UnsupportedDeclareExportKind: function (e) {
      var t = e.unsupportedExportKind,
        r = e.suggestion;
      return "`declare export "
        .concat(t, "` is not supported. Use `")
        .concat(r, "` instead.");
    },
    UnsupportedStatementInDeclareModule:
      "Only declares and type imports are allowed inside declare module.",
    UnterminatedFlowComment: "Unterminated flow-comment.",
  });
function gn(e) {
  return "type" === e.importKind || "typeof" === e.importKind;
}
function bn(e) {
  return Ft(e) && 97 !== e;
}
var Tn = {
  const: "declare export var",
  let: "declare export var",
  type: "export type",
  interface: "export interface",
};
var Sn = /\*?\s*@((?:no)?flow)\b/,
  xn = {
    __proto__: null,
    quot: '"',
    amp: "&",
    apos: "'",
    lt: "<",
    gt: ">",
    nbsp: " ",
    iexcl: "¡",
    cent: "¢",
    pound: "£",
    curren: "¤",
    yen: "¥",
    brvbar: "¦",
    sect: "§",
    uml: "¨",
    copy: "©",
    ordf: "ª",
    laquo: "«",
    not: "¬",
    shy: "­",
    reg: "®",
    macr: "¯",
    deg: "°",
    plusmn: "±",
    sup2: "²",
    sup3: "³",
    acute: "´",
    micro: "µ",
    para: "¶",
    middot: "·",
    cedil: "¸",
    sup1: "¹",
    ordm: "º",
    raquo: "»",
    frac14: "¼",
    frac12: "½",
    frac34: "¾",
    iquest: "¿",
    Agrave: "À",
    Aacute: "Á",
    Acirc: "Â",
    Atilde: "Ã",
    Auml: "Ä",
    Aring: "Å",
    AElig: "Æ",
    Ccedil: "Ç",
    Egrave: "È",
    Eacute: "É",
    Ecirc: "Ê",
    Euml: "Ë",
    Igrave: "Ì",
    Iacute: "Í",
    Icirc: "Î",
    Iuml: "Ï",
    ETH: "Ð",
    Ntilde: "Ñ",
    Ograve: "Ò",
    Oacute: "Ó",
    Ocirc: "Ô",
    Otilde: "Õ",
    Ouml: "Ö",
    times: "×",
    Oslash: "Ø",
    Ugrave: "Ù",
    Uacute: "Ú",
    Ucirc: "Û",
    Uuml: "Ü",
    Yacute: "Ý",
    THORN: "Þ",
    szlig: "ß",
    agrave: "à",
    aacute: "á",
    acirc: "â",
    atilde: "ã",
    auml: "ä",
    aring: "å",
    aelig: "æ",
    ccedil: "ç",
    egrave: "è",
    eacute: "é",
    ecirc: "ê",
    euml: "ë",
    igrave: "ì",
    iacute: "í",
    icirc: "î",
    iuml: "ï",
    eth: "ð",
    ntilde: "ñ",
    ograve: "ò",
    oacute: "ó",
    ocirc: "ô",
    otilde: "õ",
    ouml: "ö",
    divide: "÷",
    oslash: "ø",
    ugrave: "ù",
    uacute: "ú",
    ucirc: "û",
    uuml: "ü",
    yacute: "ý",
    thorn: "þ",
    yuml: "ÿ",
    OElig: "Œ",
    oelig: "œ",
    Scaron: "Š",
    scaron: "š",
    Yuml: "Ÿ",
    fnof: "ƒ",
    circ: "ˆ",
    tilde: "˜",
    Alpha: "Α",
    Beta: "Β",
    Gamma: "Γ",
    Delta: "Δ",
    Epsilon: "Ε",
    Zeta: "Ζ",
    Eta: "Η",
    Theta: "Θ",
    Iota: "Ι",
    Kappa: "Κ",
    Lambda: "Λ",
    Mu: "Μ",
    Nu: "Ν",
    Xi: "Ξ",
    Omicron: "Ο",
    Pi: "Π",
    Rho: "Ρ",
    Sigma: "Σ",
    Tau: "Τ",
    Upsilon: "Υ",
    Phi: "Φ",
    Chi: "Χ",
    Psi: "Ψ",
    Omega: "Ω",
    alpha: "α",
    beta: "β",
    gamma: "γ",
    delta: "δ",
    epsilon: "ε",
    zeta: "ζ",
    eta: "η",
    theta: "θ",
    iota: "ι",
    kappa: "κ",
    lambda: "λ",
    mu: "μ",
    nu: "ν",
    xi: "ξ",
    omicron: "ο",
    pi: "π",
    rho: "ρ",
    sigmaf: "ς",
    sigma: "σ",
    tau: "τ",
    upsilon: "υ",
    phi: "φ",
    chi: "χ",
    psi: "ψ",
    omega: "ω",
    thetasym: "ϑ",
    upsih: "ϒ",
    piv: "ϖ",
    ensp: " ",
    emsp: " ",
    thinsp: " ",
    zwnj: "‌",
    zwj: "‍",
    lrm: "‎",
    rlm: "‏",
    ndash: "–",
    mdash: "—",
    lsquo: "‘",
    rsquo: "’",
    sbquo: "‚",
    ldquo: "“",
    rdquo: "”",
    bdquo: "„",
    dagger: "†",
    Dagger: "‡",
    bull: "•",
    hellip: "…",
    permil: "‰",
    prime: "′",
    Prime: "″",
    lsaquo: "‹",
    rsaquo: "›",
    oline: "‾",
    frasl: "⁄",
    euro: "€",
    image: "ℑ",
    weierp: "℘",
    real: "ℜ",
    trade: "™",
    alefsym: "ℵ",
    larr: "←",
    uarr: "↑",
    rarr: "→",
    darr: "↓",
    harr: "↔",
    crarr: "↵",
    lArr: "⇐",
    uArr: "⇑",
    rArr: "⇒",
    dArr: "⇓",
    hArr: "⇔",
    forall: "∀",
    part: "∂",
    exist: "∃",
    empty: "∅",
    nabla: "∇",
    isin: "∈",
    notin: "∉",
    ni: "∋",
    prod: "∏",
    sum: "∑",
    minus: "−",
    lowast: "∗",
    radic: "√",
    prop: "∝",
    infin: "∞",
    ang: "∠",
    and: "∧",
    or: "∨",
    cap: "∩",
    cup: "∪",
    int: "∫",
    there4: "∴",
    sim: "∼",
    cong: "≅",
    asymp: "≈",
    ne: "≠",
    equiv: "≡",
    le: "≤",
    ge: "≥",
    sub: "⊂",
    sup: "⊃",
    nsub: "⊄",
    sube: "⊆",
    supe: "⊇",
    oplus: "⊕",
    otimes: "⊗",
    perp: "⊥",
    sdot: "⋅",
    lceil: "⌈",
    rceil: "⌉",
    lfloor: "⌊",
    rfloor: "⌋",
    lang: "〈",
    rang: "〉",
    loz: "◊",
    spades: "♠",
    clubs: "♣",
    hearts: "♥",
    diams: "♦",
  },
  En = ct(Ve || (Ve = Be(["jsx"])))({
    AttributeIsEmpty:
      "JSX attributes must only be assigned a non-empty expression.",
    MissingClosingTagElement: function (e) {
      var t = e.openingTagName;
      return "Expected corresponding JSX closing tag for <".concat(t, ">.");
    },
    MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
    UnexpectedSequenceExpression:
      "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
    UnexpectedToken: function (e) {
      var t = e.unexpected,
        r = e.HTMLEntity;
      return "Unexpected token `"
        .concat(t, "`. Did you mean `")
        .concat(r, "` or `{'")
        .concat(t, "'}`?");
    },
    UnsupportedJsxValue:
      "JSX value should be either an expression or a quoted JSX text.",
    UnterminatedJsxContent: "Unterminated JSX contents.",
    UnwrappedAdjacentJSXElements:
      "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?",
  });
function Pn(e) {
  return (
    !!e && ("JSXOpeningFragment" === e.type || "JSXClosingFragment" === e.type)
  );
}
function An(e) {
  if ("JSXIdentifier" === e.type) return e.name;
  if ("JSXNamespacedName" === e.type)
    return e.namespace.name + ":" + e.name.name;
  if ("JSXMemberExpression" === e.type)
    return An(e.object) + "." + An(e.property);
  throw new Error("Node had unexpected type: " + e.type);
}
var kn = (function (e) {
    I(r, xr);
    var t = Je(r);
    function r() {
      var e;
      E(this, r);
      for (var n = arguments.length, i = new Array(n), a = 0; a < n; a++)
        i[a] = arguments[a];
      return (
        ((e = t.call.apply(t, [this].concat(i))).types = new Set()),
        (e.enums = new Set()),
        (e.constEnums = new Set()),
        (e.classes = new Set()),
        (e.exportOnlyBindings = new Set()),
        e
      );
    }
    return A(r);
  })(),
  wn = (function (e) {
    I(r, Er);
    var t = Je(r);
    function r() {
      var e;
      E(this, r);
      for (var n = arguments.length, i = new Array(n), a = 0; a < n; a++)
        i[a] = arguments[a];
      return ((e = t.call.apply(t, [this].concat(i))).importsStack = []), e;
    }
    return (
      A(r, [
        {
          key: "createScope",
          value: function (e) {
            return this.importsStack.push(new Set()), new kn(e);
          },
        },
        {
          key: "enter",
          value: function (e) {
            e == dr && this.importsStack.push(new Set()),
              Fe(N(r.prototype), "enter", this).call(this, e);
          },
        },
        {
          key: "exit",
          value: function () {
            var e = Fe(N(r.prototype), "exit", this).call(this);
            return e == dr && this.importsStack.pop(), e;
          },
        },
        {
          key: "hasImport",
          value: function (e, t) {
            var r = this.importsStack.length;
            if (this.importsStack[r - 1].has(e)) return !0;
            if (!t && r > 1)
              for (var n = 0; n < r - 1; n++)
                if (this.importsStack[n].has(e)) return !0;
            return !1;
          },
        },
        {
          key: "declareName",
          value: function (e, t, n) {
            if (t & gr)
              return (
                this.hasImport(e, !0) &&
                  this.parser.raise(pt.VarRedeclaration, {
                    at: n,
                    identifierName: e,
                  }),
                void this.importsStack[this.importsStack.length - 1].add(e)
              );
            var i = this.currentScope();
            if (t & mr)
              return (
                this.maybeExportDefined(i, e), void i.exportOnlyBindings.add(e)
              );
            Fe(N(r.prototype), "declareName", this).call(this, e, t, n),
              2 & t &&
                (1 & t ||
                  (this.checkRedeclarationInScope(i, e, t, n),
                  this.maybeExportDefined(i, e)),
                i.types.add(e)),
              256 & t && i.enums.add(e),
              512 & t && i.constEnums.add(e),
              t & yr && i.classes.add(e);
          },
        },
        {
          key: "isRedeclaredInScope",
          value: function (e, t, n) {
            return e.enums.has(t)
              ? !(256 & n) || !!(512 & n) !== e.constEnums.has(t)
              : n & yr && e.classes.has(t)
              ? !!e.lexical.has(t) && !!(1 & n)
              : !!(2 & n && e.types.has(t)) ||
                Fe(N(r.prototype), "isRedeclaredInScope", this).call(
                  this,
                  e,
                  t,
                  n
                );
          },
        },
        {
          key: "checkLocalExport",
          value: function (e) {
            var t = e.name;
            if (!this.hasImport(t)) {
              for (var n = this.scopeStack.length - 1; n >= 0; n--) {
                var i = this.scopeStack[n];
                if (i.types.has(t) || i.exportOnlyBindings.has(t)) return;
              }
              Fe(N(r.prototype), "checkLocalExport", this).call(this, e);
            }
          },
        },
      ]),
      r
    );
  })(),
  Cn = function e(t) {
    return "ParenthesizedExpression" === t.type ? e(t.expression) : t;
  },
  In = (function (e) {
    I(r, yn);
    var t = Je(r);
    function r() {
      return E(this, r), t.apply(this, arguments);
    }
    return (
      A(r, [
        {
          key: "toAssignable",
          value: function (e) {
            var t,
              r,
              n =
                arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
              i = void 0;
            switch (
              (("ParenthesizedExpression" === e.type ||
                (null != (t = e.extra) && t.parenthesized)) &&
                ((i = Cn(e)),
                n
                  ? "Identifier" === i.type
                    ? this.expressionScope.recordArrowParameterBindingError(
                        pt.InvalidParenthesizedAssignment,
                        { at: e }
                      )
                    : "MemberExpression" !== i.type &&
                      this.raise(pt.InvalidParenthesizedAssignment, { at: e })
                  : this.raise(pt.InvalidParenthesizedAssignment, { at: e })),
              e.type)
            ) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                break;
              case "ObjectExpression":
                e.type = "ObjectPattern";
                for (
                  var a = 0, s = e.properties.length, o = s - 1;
                  a < s;
                  a++
                ) {
                  var l,
                    u = e.properties[a],
                    c = a === o;
                  this.toAssignableObjectExpressionProp(u, c, n),
                    c &&
                      "RestElement" === u.type &&
                      null != (l = e.extra) &&
                      l.trailingCommaLoc &&
                      this.raise(pt.RestTrailingComma, {
                        at: e.extra.trailingCommaLoc,
                      });
                }
                break;
              case "ObjectProperty":
                var p = e.key,
                  h = e.value;
                this.isPrivateName(p) &&
                  this.classScope.usePrivateName(
                    this.getPrivateNameSV(p),
                    p.loc.start
                  ),
                  this.toAssignable(h, n);
                break;
              case "SpreadElement":
                throw new Error(
                  "Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller."
                );
              case "ArrayExpression":
                (e.type = "ArrayPattern"),
                  this.toAssignableList(
                    e.elements,
                    null == (r = e.extra) ? void 0 : r.trailingCommaLoc,
                    n
                  );
                break;
              case "AssignmentExpression":
                "=" !== e.operator &&
                  this.raise(pt.MissingEqInAssignment, { at: e.left.loc.end }),
                  (e.type = "AssignmentPattern"),
                  delete e.operator,
                  this.toAssignable(e.left, n);
                break;
              case "ParenthesizedExpression":
                this.toAssignable(i, n);
            }
          },
        },
        {
          key: "toAssignableObjectExpressionProp",
          value: function (e, t, r) {
            if ("ObjectMethod" === e.type)
              this.raise(
                "get" === e.kind || "set" === e.kind
                  ? pt.PatternHasAccessor
                  : pt.PatternHasMethod,
                { at: e.key }
              );
            else if ("SpreadElement" === e.type) {
              e.type = "RestElement";
              var n = e.argument;
              this.checkToRestConversion(n, !1),
                this.toAssignable(n, r),
                t || this.raise(pt.RestTrailingComma, { at: e });
            } else this.toAssignable(e, r);
          },
        },
        {
          key: "toAssignableList",
          value: function (e, t, r) {
            for (var n = e.length - 1, i = 0; i <= n; i++) {
              var a = e[i];
              if (a) {
                if ("SpreadElement" === a.type) {
                  a.type = "RestElement";
                  var s = a.argument;
                  this.checkToRestConversion(s, !0), this.toAssignable(s, r);
                } else this.toAssignable(a, r);
                "RestElement" === a.type &&
                  (i < n
                    ? this.raise(pt.RestTrailingComma, { at: a })
                    : t && this.raise(pt.RestTrailingComma, { at: t }));
              }
            }
          },
        },
        {
          key: "isAssignable",
          value: function (e, t) {
            var r = this;
            switch (e.type) {
              case "Identifier":
              case "ObjectPattern":
              case "ArrayPattern":
              case "AssignmentPattern":
              case "RestElement":
                return !0;
              case "ObjectExpression":
                var n = e.properties.length - 1;
                return e.properties.every(function (e, t) {
                  return (
                    "ObjectMethod" !== e.type &&
                    (t === n || "SpreadElement" !== e.type) &&
                    r.isAssignable(e)
                  );
                });
              case "ObjectProperty":
                return this.isAssignable(e.value);
              case "SpreadElement":
                return this.isAssignable(e.argument);
              case "ArrayExpression":
                return e.elements.every(function (e) {
                  return null === e || r.isAssignable(e);
                });
              case "AssignmentExpression":
                return "=" === e.operator;
              case "ParenthesizedExpression":
                return this.isAssignable(e.expression);
              case "MemberExpression":
              case "OptionalMemberExpression":
                return !t;
              default:
                return !1;
            }
          },
        },
        {
          key: "toReferencedList",
          value: function (e, t) {
            return e;
          },
        },
        {
          key: "toReferencedListDeep",
          value: function (e, t) {
            this.toReferencedList(e, t);
            var r,
              n = He(e);
            try {
              for (n.s(); !(r = n.n()).done; ) {
                var i = r.value;
                "ArrayExpression" === (null == i ? void 0 : i.type) &&
                  this.toReferencedListDeep(i.elements);
              }
            } catch (e) {
              n.e(e);
            } finally {
              n.f();
            }
          },
        },
        {
          key: "parseSpread",
          value: function (e) {
            var t = this.startNode();
            return (
              this.next(),
              (t.argument = this.parseMaybeAssignAllowIn(e, void 0)),
              this.finishNode(t, "SpreadElement")
            );
          },
        },
        {
          key: "parseRestBinding",
          value: function () {
            var e = this.startNode();
            return (
              this.next(),
              (e.argument = this.parseBindingAtom()),
              this.finishNode(e, "RestElement")
            );
          },
        },
        {
          key: "parseBindingAtom",
          value: function () {
            switch (this.state.type) {
              case 0:
                var e = this.startNode();
                return (
                  this.next(),
                  (e.elements = this.parseBindingList(3, 93, 1)),
                  this.finishNode(e, "ArrayPattern")
                );
              case 5:
                return this.parseObjectLike(8, !0);
            }
            return this.parseIdentifier();
          },
        },
        {
          key: "parseBindingList",
          value: function (e, t, r) {
            for (var n = 1 & r, i = [], a = !0; !this.eat(e); )
              if ((a ? (a = !1) : this.expect(12), n && this.match(12)))
                i.push(null);
              else {
                if (this.eat(e)) break;
                if (this.match(21)) {
                  if (
                    (i.push(
                      this.parseAssignableListItemTypes(
                        this.parseRestBinding(),
                        r
                      )
                    ),
                    !this.checkCommaAfterRest(t))
                  ) {
                    this.expect(e);
                    break;
                  }
                } else {
                  var s = [];
                  for (
                    this.match(26) &&
                    this.hasPlugin("decorators") &&
                    this.raise(pt.UnsupportedParameterDecorator, {
                      at: this.state.startLoc,
                    });
                    this.match(26);

                  )
                    s.push(this.parseDecorator());
                  i.push(this.parseAssignableListItem(r, s));
                }
              }
            return i;
          },
        },
        {
          key: "parseBindingRestProperty",
          value: function (e) {
            return (
              this.next(),
              (e.argument = this.parseIdentifier()),
              this.checkCommaAfterRest(125),
              this.finishNode(e, "RestElement")
            );
          },
        },
        {
          key: "parseBindingProperty",
          value: function () {
            var e = this.startNode(),
              t = this.state,
              r = t.type,
              n = t.startLoc;
            return 21 === r
              ? this.parseBindingRestProperty(e)
              : (136 === r
                  ? (this.expectPlugin("destructuringPrivate", n),
                    this.classScope.usePrivateName(this.state.value, n),
                    (e.key = this.parsePrivateName()))
                  : this.parsePropertyName(e),
                (e.method = !1),
                this.parseObjPropValue(e, n, !1, !1, !0, !1));
          },
        },
        {
          key: "parseAssignableListItem",
          value: function (e, t) {
            var r = this.parseMaybeDefault();
            this.parseAssignableListItemTypes(r, e);
            var n = this.parseMaybeDefault(r.loc.start, r);
            return t.length && (r.decorators = t), n;
          },
        },
        {
          key: "parseAssignableListItemTypes",
          value: function (e, t) {
            return e;
          },
        },
        {
          key: "parseMaybeDefault",
          value: function (e, t) {
            var r;
            if (
              (null != e || (e = this.state.startLoc),
              (t = null != (r = t) ? r : this.parseBindingAtom()),
              !this.eat(29))
            )
              return t;
            var n = this.startNodeAt(e);
            return (
              (n.left = t),
              (n.right = this.parseMaybeAssignAllowIn()),
              this.finishNode(n, "AssignmentPattern")
            );
          },
        },
        {
          key: "isValidLVal",
          value: function (e, t, r) {
            return (function (e, t) {
              return Object.hasOwnProperty.call(e, t) && e[t];
            })(
              {
                AssignmentPattern: "left",
                RestElement: "argument",
                ObjectProperty: "value",
                ParenthesizedExpression: "expression",
                ArrayPattern: "elements",
                ObjectPattern: "properties",
              },
              e
            );
          },
        },
        {
          key: "checkLVal",
          value: function (e, t) {
            var r,
              n = t.in,
              i = t.binding,
              a = void 0 === i ? Sr : i,
              s = t.checkClashes,
              o = void 0 !== s && s,
              l = t.strictModeChanged,
              u = void 0 !== l && l,
              c = t.hasParenthesizedAncestor,
              p = void 0 !== c && c,
              h = e.type;
            if (!this.isObjectMethod(e))
              if ("MemberExpression" !== h)
                if ("Identifier" !== h) {
                  var d = this.isValidLVal(
                    h,
                    !(p || (null != (r = e.extra) && r.parenthesized)) &&
                      "AssignmentExpression" === n.type,
                    a
                  );
                  if (!0 !== d)
                    if (!1 !== d) {
                      var f,
                        y = H(
                          Array.isArray(d)
                            ? d
                            : [d, "ParenthesizedExpression" === h],
                          2
                        ),
                        m = y[0],
                        v = y[1],
                        g =
                          "ArrayPattern" === h ||
                          "ObjectPattern" === h ||
                          "ParenthesizedExpression" === h
                            ? { type: h }
                            : n,
                        b = He([].concat(e[m]));
                      try {
                        for (b.s(); !(f = b.n()).done; ) {
                          var T = f.value;
                          T &&
                            this.checkLVal(T, {
                              in: g,
                              binding: a,
                              checkClashes: o,
                              strictModeChanged: u,
                              hasParenthesizedAncestor: v,
                            });
                        }
                      } catch (e) {
                        b.e(e);
                      } finally {
                        b.f();
                      }
                    } else {
                      var S = a === Sr ? pt.InvalidLhs : pt.InvalidLhsBinding;
                      this.raise(S, { at: e, ancestor: n });
                    }
                } else {
                  this.checkIdentifier(e, a, u);
                  var x = e.name;
                  o &&
                    (o.has(x) ? this.raise(pt.ParamDupe, { at: e }) : o.add(x));
                }
              else
                a !== Sr &&
                  this.raise(pt.InvalidPropertyBindingPattern, { at: e });
          },
        },
        {
          key: "checkIdentifier",
          value: function (e, t) {
            var r =
              arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            this.state.strict &&
              (r ? ur(e.name, this.inModule) : lr(e.name)) &&
              (t === Sr
                ? this.raise(pt.StrictEvalArguments, {
                    at: e,
                    referenceName: e.name,
                  })
                : this.raise(pt.StrictEvalArgumentsBinding, {
                    at: e,
                    bindingName: e.name,
                  })),
              t & br &&
                "let" === e.name &&
                this.raise(pt.LetInLexicalBinding, { at: e }),
              t & Sr || this.declareNameFromIdentifier(e, t);
          },
        },
        {
          key: "declareNameFromIdentifier",
          value: function (e, t) {
            this.scope.declareName(e.name, t, e.loc.start);
          },
        },
        {
          key: "checkToRestConversion",
          value: function (e, t) {
            switch (e.type) {
              case "ParenthesizedExpression":
                this.checkToRestConversion(e.expression, t);
                break;
              case "Identifier":
              case "MemberExpression":
                break;
              case "ArrayExpression":
              case "ObjectExpression":
                if (t) break;
              default:
                this.raise(pt.InvalidRestAssignmentPattern, { at: e });
            }
          },
        },
        {
          key: "checkCommaAfterRest",
          value: function (e) {
            return (
              !!this.match(12) &&
              (this.raise(
                this.lookaheadCharCode() === e
                  ? pt.RestTrailingComma
                  : pt.ElementAfterRest,
                { at: this.state.startLoc }
              ),
              !0)
            );
          },
        },
      ]),
      r
    );
  })();
function On(e) {
  if (!e) throw new Error("Assert fail");
}
var Nn = ct(Ke || (Ke = Be(["typescript"])))({
  AbstractMethodHasImplementation: function (e) {
    var t = e.methodName;
    return "Method '".concat(
      t,
      "' cannot have an implementation because it is marked abstract."
    );
  },
  AbstractPropertyHasInitializer: function (e) {
    var t = e.propertyName;
    return "Property '".concat(
      t,
      "' cannot have an initializer because it is marked abstract."
    );
  },
  AccesorCannotDeclareThisParameter:
    "'get' and 'set' accessors cannot declare 'this' parameters.",
  AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
  AccessorCannotBeOptional:
    "An 'accessor' property cannot be declared optional.",
  ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
  ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
  ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference:
    "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
  ConstructorHasTypeParameters:
    "Type parameters cannot appear on a constructor declaration.",
  DeclareAccessor: function (e) {
    var t = e.kind;
    return "'declare' is not allowed in ".concat(t, "ters.");
  },
  DeclareClassFieldHasInitializer:
    "Initializers are not allowed in ambient contexts.",
  DeclareFunctionHasImplementation:
    "An implementation cannot be declared in ambient contexts.",
  DuplicateAccessibilityModifier: function (e) {
    return e.modifier, "Accessibility modifier already seen.";
  },
  DuplicateModifier: function (e) {
    var t = e.modifier;
    return "Duplicate modifier: '".concat(t, "'.");
  },
  EmptyHeritageClauseType: function (e) {
    var t = e.token;
    return "'".concat(t, "' list cannot be empty.");
  },
  EmptyTypeArguments: "Type argument list cannot be empty.",
  EmptyTypeParameters: "Type parameter list cannot be empty.",
  ExpectedAmbientAfterExportDeclare:
    "'export declare' must be followed by an ambient declaration.",
  ImportAliasHasImportType: "An import alias can not use 'import type'.",
  ImportReflectionHasImportType:
    "An `import module` declaration can not use `type` modifier",
  IncompatibleModifiers: function (e) {
    var t = e.modifiers;
    return "'"
      .concat(t[0], "' modifier cannot be used with '")
      .concat(t[1], "' modifier.");
  },
  IndexSignatureHasAbstract:
    "Index signatures cannot have the 'abstract' modifier.",
  IndexSignatureHasAccessibility: function (e) {
    var t = e.modifier;
    return "Index signatures cannot have an accessibility modifier ('".concat(
      t,
      "')."
    );
  },
  IndexSignatureHasDeclare:
    "Index signatures cannot have the 'declare' modifier.",
  IndexSignatureHasOverride:
    "'override' modifier cannot appear on an index signature.",
  IndexSignatureHasStatic:
    "Index signatures cannot have the 'static' modifier.",
  InitializerNotAllowedInAmbientContext:
    "Initializers are not allowed in ambient contexts.",
  InvalidModifierOnTypeMember: function (e) {
    var t = e.modifier;
    return "'".concat(t, "' modifier cannot appear on a type member.");
  },
  InvalidModifierOnTypeParameter: function (e) {
    var t = e.modifier;
    return "'".concat(t, "' modifier cannot appear on a type parameter.");
  },
  InvalidModifierOnTypeParameterPositions: function (e) {
    var t = e.modifier;
    return "'".concat(
      t,
      "' modifier can only appear on a type parameter of a class, interface or type alias."
    );
  },
  InvalidModifiersOrder: function (e) {
    var t = e.orderedModifiers;
    return "'"
      .concat(t[0], "' modifier must precede '")
      .concat(t[1], "' modifier.");
  },
  InvalidPropertyAccessAfterInstantiationExpression:
    "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
  InvalidTupleMemberLabel:
    "Tuple members must be labeled with a simple identifier.",
  MissingInterfaceName:
    "'interface' declarations must be followed by an identifier.",
  MixedLabeledAndUnlabeledElements:
    "Tuple members must all have names or all not have names.",
  NonAbstractClassHasAbstractMethod:
    "Abstract methods can only appear within an abstract class.",
  NonClassMethodPropertyHasAbstractModifer:
    "'abstract' modifier can only appear on a class, method, or property declaration.",
  OptionalTypeBeforeRequired:
    "A required element cannot follow an optional element.",
  OverrideNotInSubClass:
    "This member cannot have an 'override' modifier because its containing class does not extend another class.",
  PatternIsOptional:
    "A binding pattern parameter cannot be optional in an implementation signature.",
  PrivateElementHasAbstract:
    "Private elements cannot have the 'abstract' modifier.",
  PrivateElementHasAccessibility: function (e) {
    var t = e.modifier;
    return "Private elements cannot have an accessibility modifier ('".concat(
      t,
      "')."
    );
  },
  ReadonlyForMethodSignature:
    "'readonly' modifier can only appear on a property declaration or index signature.",
  ReservedArrowTypeParam:
    "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
  ReservedTypeAssertion:
    "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
  SetAccesorCannotHaveOptionalParameter:
    "A 'set' accessor cannot have an optional parameter.",
  SetAccesorCannotHaveRestParameter:
    "A 'set' accessor cannot have rest parameter.",
  SetAccesorCannotHaveReturnType:
    "A 'set' accessor cannot have a return type annotation.",
  SingleTypeParameterWithoutTrailingComma: function (e) {
    var t = e.typeParameterName;
    return "Single type parameter "
      .concat(t, " should have a trailing comma. Example usage: <")
      .concat(t, ",>.");
  },
  StaticBlockCannotHaveModifier:
    "Static class blocks cannot have any modifier.",
  TupleOptionalAfterType:
    "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
  TypeAnnotationAfterAssign:
    "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
  TypeImportCannotSpecifyDefaultAndNamed:
    "A type-only import can specify a default import or named bindings, but not both.",
  TypeModifierIsUsedInTypeExports:
    "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
  TypeModifierIsUsedInTypeImports:
    "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
  UnexpectedParameterModifier:
    "A parameter property is only allowed in a constructor implementation.",
  UnexpectedReadonly:
    "'readonly' type modifier is only permitted on array and tuple literal types.",
  UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
  UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
  UnsupportedImportTypeArgument:
    "Argument in a type import must be a string literal.",
  UnsupportedParameterPropertyKind:
    "A parameter property may not be declared using a binding pattern.",
  UnsupportedSignatureParameterKind: function (e) {
    var t = e.type;
    return "Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ".concat(
      t,
      "."
    );
  },
});
function _n(e) {
  return "private" === e || "public" === e || "protected" === e;
}
function Dn(e) {
  return "in" === e || "out" === e;
}
function Ln(e) {
  if ("MemberExpression" !== e.type) return !1;
  var t = e.computed,
    r = e.property;
  return (
    (!t ||
      "StringLiteral" === r.type ||
      !("TemplateLiteral" !== r.type || r.expressions.length > 0)) &&
    Fn(e.object)
  );
}
function Mn(e, t) {
  var r,
    n = e.type;
  if (null != (r = e.extra) && r.parenthesized) return !1;
  if (t) {
    if ("Literal" === n) {
      var i = e.value;
      if ("string" == typeof i || "boolean" == typeof i) return !0;
    }
  } else if ("StringLiteral" === n || "BooleanLiteral" === n) return !0;
  return (
    !(
      !jn(e, t) &&
      !(function (e, t) {
        if ("UnaryExpression" === e.type) {
          var r = e.operator,
            n = e.argument;
          if ("-" === r && jn(n, t)) return !0;
        }
        return !1;
      })(e, t)
    ) ||
    ("TemplateLiteral" === n && 0 === e.expressions.length) ||
    !!Ln(e)
  );
}
function jn(e, t) {
  return t
    ? "Literal" === e.type && ("number" == typeof e.value || "bigint" in e)
    : "NumericLiteral" === e.type || "BigIntLiteral" === e.type;
}
function Fn(e) {
  return (
    "Identifier" === e.type ||
    ("MemberExpression" === e.type && !e.computed && Fn(e.object))
  );
}
var Bn = ct(We || (We = Be(["placeholders"])))({
  ClassNameIsRequired: "A class name is required.",
  UnexpectedSpace: "Unexpected space in placeholder.",
});
function Rn(e, t) {
  var r = H("string" == typeof t ? [t, {}] : t, 2),
    n = r[0],
    i = r[1],
    a = Object.keys(i),
    s = 0 === a.length;
  return e.some(function (e) {
    if ("string" == typeof e) return s && e === n;
    var t = H(e, 2),
      r = t[0],
      o = t[1];
    if (r !== n) return !1;
    for (var l = 0, u = a; l < u.length; l++) {
      var c = u[l];
      if (o[c] !== i[c]) return !1;
    }
    return !0;
  });
}
function Un(e, t, r) {
  var n = e.find(function (e) {
    return Array.isArray(e) ? e[0] === t : e === t;
  });
  return n && Array.isArray(n) && n.length > 1 ? n[1][r] : null;
}
var Vn = ["minimal", "fsharp", "hack", "smart"],
  Kn = ["^^", "@@", "^", "%", "#"],
  Wn = ["hash", "bar"];
var qn = {
    estree: function (e) {
      return (function (e) {
        I(r, e);
        var t = Je(r);
        function r() {
          return E(this, r), t.apply(this, arguments);
        }
        return (
          A(r, [
            {
              key: "parse",
              value: function () {
                var e = ft(Fe(N(r.prototype), "parse", this).call(this));
                return this.options.tokens && (e.tokens = e.tokens.map(ft)), e;
              },
            },
            {
              key: "parseRegExpLiteral",
              value: function (e) {
                var t = e.pattern,
                  r = e.flags,
                  n = null;
                try {
                  n = new RegExp(t, r);
                } catch (e) {}
                var i = this.estreeParseLiteral(n);
                return (i.regex = { pattern: t, flags: r }), i;
              },
            },
            {
              key: "parseBigIntLiteral",
              value: function (e) {
                var t;
                try {
                  t = BigInt(e);
                } catch (e) {
                  t = null;
                }
                var r = this.estreeParseLiteral(t);
                return (r.bigint = String(r.value || e)), r;
              },
            },
            {
              key: "parseDecimalLiteral",
              value: function (e) {
                var t = this.estreeParseLiteral(null);
                return (t.decimal = String(t.value || e)), t;
              },
            },
            {
              key: "estreeParseLiteral",
              value: function (e) {
                return this.parseLiteral(e, "Literal");
              },
            },
            {
              key: "parseStringLiteral",
              value: function (e) {
                return this.estreeParseLiteral(e);
              },
            },
            {
              key: "parseNumericLiteral",
              value: function (e) {
                return this.estreeParseLiteral(e);
              },
            },
            {
              key: "parseNullLiteral",
              value: function () {
                return this.estreeParseLiteral(null);
              },
            },
            {
              key: "parseBooleanLiteral",
              value: function (e) {
                return this.estreeParseLiteral(e);
              },
            },
            {
              key: "directiveToStmt",
              value: function (e) {
                var t = e.value;
                delete e.value,
                  (t.type = "Literal"),
                  (t.raw = t.extra.raw),
                  (t.value = t.extra.expressionValue);
                var r = e;
                return (
                  (r.type = "ExpressionStatement"),
                  (r.expression = t),
                  (r.directive = t.extra.rawValue),
                  delete t.extra,
                  r
                );
              },
            },
            {
              key: "initFunction",
              value: function (e, t) {
                Fe(N(r.prototype), "initFunction", this).call(this, e, t),
                  (e.expression = !1);
              },
            },
            {
              key: "checkDeclaration",
              value: function (e) {
                null != e && this.isObjectProperty(e)
                  ? this.checkDeclaration(e.value)
                  : Fe(N(r.prototype), "checkDeclaration", this).call(this, e);
              },
            },
            {
              key: "getObjectOrClassMethodParams",
              value: function (e) {
                return e.value.params;
              },
            },
            {
              key: "isValidDirective",
              value: function (e) {
                var t;
                return (
                  "ExpressionStatement" === e.type &&
                  "Literal" === e.expression.type &&
                  "string" == typeof e.expression.value &&
                  !(null != (t = e.expression.extra) && t.parenthesized)
                );
              },
            },
            {
              key: "parseBlockBody",
              value: function (e, t, n, i, a) {
                var s = this;
                Fe(N(r.prototype), "parseBlockBody", this).call(
                  this,
                  e,
                  t,
                  n,
                  i,
                  a
                );
                var o = e.directives.map(function (e) {
                  return s.directiveToStmt(e);
                });
                (e.body = o.concat(e.body)), delete e.directives;
              },
            },
            {
              key: "pushClassMethod",
              value: function (e, t, r, n, i, a) {
                this.parseMethod(t, r, n, i, a, "ClassMethod", !0),
                  t.typeParameters &&
                    ((t.value.typeParameters = t.typeParameters),
                    delete t.typeParameters),
                  e.body.push(t);
              },
            },
            {
              key: "parsePrivateName",
              value: function () {
                var e = Fe(N(r.prototype), "parsePrivateName", this).call(this);
                return this.getPluginOption("estree", "classFeatures")
                  ? this.convertPrivateNameToPrivateIdentifier(e)
                  : e;
              },
            },
            {
              key: "convertPrivateNameToPrivateIdentifier",
              value: function (e) {
                var t = Fe(N(r.prototype), "getPrivateNameSV", this).call(
                  this,
                  e
                );
                return (
                  delete e.id, (e.name = t), (e.type = "PrivateIdentifier"), e
                );
              },
            },
            {
              key: "isPrivateName",
              value: function (e) {
                return this.getPluginOption("estree", "classFeatures")
                  ? "PrivateIdentifier" === e.type
                  : Fe(N(r.prototype), "isPrivateName", this).call(this, e);
              },
            },
            {
              key: "getPrivateNameSV",
              value: function (e) {
                return this.getPluginOption("estree", "classFeatures")
                  ? e.name
                  : Fe(N(r.prototype), "getPrivateNameSV", this).call(this, e);
              },
            },
            {
              key: "parseLiteral",
              value: function (e, t) {
                var n = Fe(N(r.prototype), "parseLiteral", this).call(
                  this,
                  e,
                  t
                );
                return (n.raw = n.extra.raw), delete n.extra, n;
              },
            },
            {
              key: "parseFunctionBody",
              value: function (e, t) {
                var n =
                  arguments.length > 2 &&
                  void 0 !== arguments[2] &&
                  arguments[2];
                Fe(N(r.prototype), "parseFunctionBody", this).call(
                  this,
                  e,
                  t,
                  n
                ),
                  (e.expression = "BlockStatement" !== e.body.type);
              },
            },
            {
              key: "parseMethod",
              value: function (e, t, n, i, a, s) {
                var o =
                    arguments.length > 6 &&
                    void 0 !== arguments[6] &&
                    arguments[6],
                  l = this.startNode();
                return (
                  (l.kind = e.kind),
                  ((l = Fe(N(r.prototype), "parseMethod", this).call(
                    this,
                    l,
                    t,
                    n,
                    i,
                    a,
                    s,
                    o
                  )).type = "FunctionExpression"),
                  delete l.kind,
                  (e.value = l),
                  "ClassPrivateMethod" === s && (e.computed = !1),
                  this.finishNode(e, "MethodDefinition")
                );
              },
            },
            {
              key: "parseClassProperty",
              value: function () {
                for (
                  var e, t = arguments.length, n = new Array(t), i = 0;
                  i < t;
                  i++
                )
                  n[i] = arguments[i];
                var a = (e = Fe(
                  N(r.prototype),
                  "parseClassProperty",
                  this
                )).call.apply(e, [this].concat(n));
                return this.getPluginOption("estree", "classFeatures")
                  ? ((a.type = "PropertyDefinition"), a)
                  : a;
              },
            },
            {
              key: "parseClassPrivateProperty",
              value: function () {
                for (
                  var e, t = arguments.length, n = new Array(t), i = 0;
                  i < t;
                  i++
                )
                  n[i] = arguments[i];
                var a = (e = Fe(
                  N(r.prototype),
                  "parseClassPrivateProperty",
                  this
                )).call.apply(e, [this].concat(n));
                return this.getPluginOption("estree", "classFeatures")
                  ? ((a.type = "PropertyDefinition"), (a.computed = !1), a)
                  : a;
              },
            },
            {
              key: "parseObjectMethod",
              value: function (e, t, n, i, a) {
                var s = Fe(N(r.prototype), "parseObjectMethod", this).call(
                  this,
                  e,
                  t,
                  n,
                  i,
                  a
                );
                return (
                  s &&
                    ((s.type = "Property"),
                    "method" === s.kind && (s.kind = "init"),
                    (s.shorthand = !1)),
                  s
                );
              },
            },
            {
              key: "parseObjectProperty",
              value: function (e, t, n, i) {
                var a = Fe(N(r.prototype), "parseObjectProperty", this).call(
                  this,
                  e,
                  t,
                  n,
                  i
                );
                return a && ((a.kind = "init"), (a.type = "Property")), a;
              },
            },
            {
              key: "isValidLVal",
              value: function (e, t, n) {
                return "Property" === e
                  ? "value"
                  : Fe(N(r.prototype), "isValidLVal", this).call(this, e, t, n);
              },
            },
            {
              key: "isAssignable",
              value: function (e, t) {
                return null != e && this.isObjectProperty(e)
                  ? this.isAssignable(e.value, t)
                  : Fe(N(r.prototype), "isAssignable", this).call(this, e, t);
              },
            },
            {
              key: "toAssignable",
              value: function (e) {
                var t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1];
                if (null != e && this.isObjectProperty(e)) {
                  var n = e.key,
                    i = e.value;
                  this.isPrivateName(n) &&
                    this.classScope.usePrivateName(
                      this.getPrivateNameSV(n),
                      n.loc.start
                    ),
                    this.toAssignable(i, t);
                } else
                  Fe(N(r.prototype), "toAssignable", this).call(this, e, t);
              },
            },
            {
              key: "toAssignableObjectExpressionProp",
              value: function (e, t, n) {
                "get" === e.kind || "set" === e.kind
                  ? this.raise(pt.PatternHasAccessor, { at: e.key })
                  : e.method
                  ? this.raise(pt.PatternHasMethod, { at: e.key })
                  : Fe(
                      N(r.prototype),
                      "toAssignableObjectExpressionProp",
                      this
                    ).call(this, e, t, n);
              },
            },
            {
              key: "finishCallExpression",
              value: function (e, t) {
                var n = Fe(N(r.prototype), "finishCallExpression", this).call(
                  this,
                  e,
                  t
                );
                if ("Import" === n.callee.type) {
                  var i;
                  if (
                    ((n.type = "ImportExpression"),
                    (n.source = n.arguments[0]),
                    this.hasPlugin("importAssertions"))
                  )
                    n.attributes = null != (i = n.arguments[1]) ? i : null;
                  delete n.arguments, delete n.callee;
                }
                return n;
              },
            },
            {
              key: "toReferencedArguments",
              value: function (e) {
                "ImportExpression" !== e.type &&
                  Fe(N(r.prototype), "toReferencedArguments", this).call(
                    this,
                    e
                  );
              },
            },
            {
              key: "parseExport",
              value: function (e, t) {
                var n = this.state.lastTokStartLoc,
                  i = Fe(N(r.prototype), "parseExport", this).call(this, e, t);
                switch (i.type) {
                  case "ExportAllDeclaration":
                    i.exported = null;
                    break;
                  case "ExportNamedDeclaration":
                    1 === i.specifiers.length &&
                      "ExportNamespaceSpecifier" === i.specifiers[0].type &&
                      ((i.type = "ExportAllDeclaration"),
                      (i.exported = i.specifiers[0].exported),
                      delete i.specifiers);
                  case "ExportDefaultDeclaration":
                    var a,
                      s = i.declaration;
                    "ClassDeclaration" === (null == s ? void 0 : s.type) &&
                      (null == (a = s.decorators) ? void 0 : a.length) > 0 &&
                      s.start === i.start &&
                      this.resetStartLocation(i, n);
                }
                return i;
              },
            },
            {
              key: "parseSubscript",
              value: function (e, t, n, i) {
                var a = Fe(N(r.prototype), "parseSubscript", this).call(
                  this,
                  e,
                  t,
                  n,
                  i
                );
                if (i.optionalChainMember) {
                  if (
                    (("OptionalMemberExpression" !== a.type &&
                      "OptionalCallExpression" !== a.type) ||
                      (a.type = a.type.substring(8)),
                    i.stop)
                  ) {
                    var s = this.startNodeAtNode(a);
                    return (
                      (s.expression = a), this.finishNode(s, "ChainExpression")
                    );
                  }
                } else
                  ("MemberExpression" !== a.type &&
                    "CallExpression" !== a.type) ||
                    (a.optional = !1);
                return a;
              },
            },
            {
              key: "hasPropertyAsPrivateName",
              value: function (e) {
                return (
                  "ChainExpression" === e.type && (e = e.expression),
                  Fe(N(r.prototype), "hasPropertyAsPrivateName", this).call(
                    this,
                    e
                  )
                );
              },
            },
            {
              key: "isObjectProperty",
              value: function (e) {
                return "Property" === e.type && "init" === e.kind && !e.method;
              },
            },
            {
              key: "isObjectMethod",
              value: function (e) {
                return e.method || "get" === e.kind || "set" === e.kind;
              },
            },
            {
              key: "finishNodeAt",
              value: function (e, t, n) {
                return ft(
                  Fe(N(r.prototype), "finishNodeAt", this).call(this, e, t, n)
                );
              },
            },
            {
              key: "resetStartLocation",
              value: function (e, t) {
                Fe(N(r.prototype), "resetStartLocation", this).call(this, e, t),
                  ft(e);
              },
            },
            {
              key: "resetEndLocation",
              value: function (e) {
                var t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : this.state.lastTokEndLoc;
                Fe(N(r.prototype), "resetEndLocation", this).call(this, e, t),
                  ft(e);
              },
            },
          ]),
          r
        );
      })(e);
    },
    jsx: function (e) {
      return (function (e) {
        I(r, e);
        var t = Je(r);
        function r() {
          return E(this, r), t.apply(this, arguments);
        }
        return (
          A(r, [
            {
              key: "jsxReadToken",
              value: function () {
                for (var e = "", t = this.state.pos; ; ) {
                  if (this.state.pos >= this.length)
                    throw this.raise(En.UnterminatedJsxContent, {
                      at: this.state.startLoc,
                    });
                  var n = this.input.charCodeAt(this.state.pos);
                  switch (n) {
                    case 60:
                    case 123:
                      return this.state.pos === this.state.start
                        ? void (60 === n && this.state.canStartJSXElement
                            ? (++this.state.pos, this.finishToken(140))
                            : Fe(N(r.prototype), "getTokenFromCode", this).call(
                                this,
                                n
                              ))
                        : ((e += this.input.slice(t, this.state.pos)),
                          void this.finishToken(139, e));
                    case 38:
                      (e += this.input.slice(t, this.state.pos)),
                        (e += this.jsxReadEntity()),
                        (t = this.state.pos);
                      break;
                    default:
                      Dr(n)
                        ? ((e += this.input.slice(t, this.state.pos)),
                          (e += this.jsxReadNewLine(!0)),
                          (t = this.state.pos))
                        : ++this.state.pos;
                  }
                }
              },
            },
            {
              key: "jsxReadNewLine",
              value: function (e) {
                var t,
                  r = this.input.charCodeAt(this.state.pos);
                return (
                  ++this.state.pos,
                  13 === r && 10 === this.input.charCodeAt(this.state.pos)
                    ? (++this.state.pos, (t = e ? "\n" : "\r\n"))
                    : (t = String.fromCharCode(r)),
                  ++this.state.curLine,
                  (this.state.lineStart = this.state.pos),
                  t
                );
              },
            },
            {
              key: "jsxReadString",
              value: function (e) {
                for (var t = "", r = ++this.state.pos; ; ) {
                  if (this.state.pos >= this.length)
                    throw this.raise(pt.UnterminatedString, {
                      at: this.state.startLoc,
                    });
                  var n = this.input.charCodeAt(this.state.pos);
                  if (n === e) break;
                  38 === n
                    ? ((t += this.input.slice(r, this.state.pos)),
                      (t += this.jsxReadEntity()),
                      (r = this.state.pos))
                    : Dr(n)
                    ? ((t += this.input.slice(r, this.state.pos)),
                      (t += this.jsxReadNewLine(!1)),
                      (r = this.state.pos))
                    : ++this.state.pos;
                }
                (t += this.input.slice(r, this.state.pos++)),
                  this.finishToken(131, t);
              },
            },
            {
              key: "jsxReadEntity",
              value: function () {
                var e = ++this.state.pos;
                if (35 === this.codePointAtPos(this.state.pos)) {
                  ++this.state.pos;
                  var t = 10;
                  120 === this.codePointAtPos(this.state.pos) &&
                    ((t = 16), ++this.state.pos);
                  var r = this.readInt(t, void 0, !1, "bail");
                  if (null !== r && 59 === this.codePointAtPos(this.state.pos))
                    return ++this.state.pos, String.fromCodePoint(r);
                } else {
                  for (
                    var n = 0, i = !1;
                    n++ < 10 &&
                    this.state.pos < this.length &&
                    !(i = 59 == this.codePointAtPos(this.state.pos));

                  )
                    ++this.state.pos;
                  if (i) {
                    var a = this.input.slice(e, this.state.pos),
                      s = xn[a];
                    if ((++this.state.pos, s)) return s;
                  }
                }
                return (this.state.pos = e), "&";
              },
            },
            {
              key: "jsxReadWord",
              value: function () {
                var e,
                  t = this.state.pos;
                do {
                  e = this.input.charCodeAt(++this.state.pos);
                } while (er(e) || 45 === e);
                this.finishToken(138, this.input.slice(t, this.state.pos));
              },
            },
            {
              key: "jsxParseIdentifier",
              value: function () {
                var e = this.startNode();
                return (
                  this.match(138)
                    ? (e.name = this.state.value)
                    : Vt(this.state.type)
                    ? (e.name = Kt(this.state.type))
                    : this.unexpected(),
                  this.next(),
                  this.finishNode(e, "JSXIdentifier")
                );
              },
            },
            {
              key: "jsxParseNamespacedName",
              value: function () {
                var e = this.state.startLoc,
                  t = this.jsxParseIdentifier();
                if (!this.eat(14)) return t;
                var r = this.startNodeAt(e);
                return (
                  (r.namespace = t),
                  (r.name = this.jsxParseIdentifier()),
                  this.finishNode(r, "JSXNamespacedName")
                );
              },
            },
            {
              key: "jsxParseElementName",
              value: function () {
                var e = this.state.startLoc,
                  t = this.jsxParseNamespacedName();
                if ("JSXNamespacedName" === t.type) return t;
                for (; this.eat(16); ) {
                  var r = this.startNodeAt(e);
                  (r.object = t),
                    (r.property = this.jsxParseIdentifier()),
                    (t = this.finishNode(r, "JSXMemberExpression"));
                }
                return t;
              },
            },
            {
              key: "jsxParseAttributeValue",
              value: function () {
                var e;
                switch (this.state.type) {
                  case 5:
                    return (
                      (e = this.startNode()),
                      this.setContext(mt.brace),
                      this.next(),
                      "JSXEmptyExpression" ===
                        (e = this.jsxParseExpressionContainer(e, mt.j_oTag))
                          .expression.type &&
                        this.raise(En.AttributeIsEmpty, { at: e }),
                      e
                    );
                  case 140:
                  case 131:
                    return this.parseExprAtom();
                  default:
                    throw this.raise(En.UnsupportedJsxValue, {
                      at: this.state.startLoc,
                    });
                }
              },
            },
            {
              key: "jsxParseEmptyExpression",
              value: function () {
                var e = this.startNodeAt(this.state.lastTokEndLoc);
                return this.finishNodeAt(
                  e,
                  "JSXEmptyExpression",
                  this.state.startLoc
                );
              },
            },
            {
              key: "jsxParseSpreadChild",
              value: function (e) {
                return (
                  this.next(),
                  (e.expression = this.parseExpression()),
                  this.setContext(mt.j_expr),
                  (this.state.canStartJSXElement = !0),
                  this.expect(8),
                  this.finishNode(e, "JSXSpreadChild")
                );
              },
            },
            {
              key: "jsxParseExpressionContainer",
              value: function (e, t) {
                if (this.match(8))
                  e.expression = this.jsxParseEmptyExpression();
                else {
                  var r = this.parseExpression();
                  e.expression = r;
                }
                return (
                  this.setContext(t),
                  (this.state.canStartJSXElement = !0),
                  this.expect(8),
                  this.finishNode(e, "JSXExpressionContainer")
                );
              },
            },
            {
              key: "jsxParseAttribute",
              value: function () {
                var e = this.startNode();
                return this.match(5)
                  ? (this.setContext(mt.brace),
                    this.next(),
                    this.expect(21),
                    (e.argument = this.parseMaybeAssignAllowIn()),
                    this.setContext(mt.j_oTag),
                    (this.state.canStartJSXElement = !0),
                    this.expect(8),
                    this.finishNode(e, "JSXSpreadAttribute"))
                  : ((e.name = this.jsxParseNamespacedName()),
                    (e.value = this.eat(29)
                      ? this.jsxParseAttributeValue()
                      : null),
                    this.finishNode(e, "JSXAttribute"));
              },
            },
            {
              key: "jsxParseOpeningElementAt",
              value: function (e) {
                var t = this.startNodeAt(e);
                return this.eat(141)
                  ? this.finishNode(t, "JSXOpeningFragment")
                  : ((t.name = this.jsxParseElementName()),
                    this.jsxParseOpeningElementAfterName(t));
              },
            },
            {
              key: "jsxParseOpeningElementAfterName",
              value: function (e) {
                for (var t = []; !this.match(56) && !this.match(141); )
                  t.push(this.jsxParseAttribute());
                return (
                  (e.attributes = t),
                  (e.selfClosing = this.eat(56)),
                  this.expect(141),
                  this.finishNode(e, "JSXOpeningElement")
                );
              },
            },
            {
              key: "jsxParseClosingElementAt",
              value: function (e) {
                var t = this.startNodeAt(e);
                return this.eat(141)
                  ? this.finishNode(t, "JSXClosingFragment")
                  : ((t.name = this.jsxParseElementName()),
                    this.expect(141),
                    this.finishNode(t, "JSXClosingElement"));
              },
            },
            {
              key: "jsxParseElementAt",
              value: function (e) {
                var t = this.startNodeAt(e),
                  r = [],
                  n = this.jsxParseOpeningElementAt(e),
                  i = null;
                if (!n.selfClosing) {
                  e: for (;;)
                    switch (this.state.type) {
                      case 140:
                        if (
                          ((e = this.state.startLoc), this.next(), this.eat(56))
                        ) {
                          i = this.jsxParseClosingElementAt(e);
                          break e;
                        }
                        r.push(this.jsxParseElementAt(e));
                        break;
                      case 139:
                        r.push(this.parseExprAtom());
                        break;
                      case 5:
                        var a = this.startNode();
                        this.setContext(mt.brace),
                          this.next(),
                          this.match(21)
                            ? r.push(this.jsxParseSpreadChild(a))
                            : r.push(
                                this.jsxParseExpressionContainer(a, mt.j_expr)
                              );
                        break;
                      default:
                        this.unexpected();
                    }
                  Pn(n) && !Pn(i) && null !== i
                    ? this.raise(En.MissingClosingTagFragment, { at: i })
                    : !Pn(n) && Pn(i)
                    ? this.raise(En.MissingClosingTagElement, {
                        at: i,
                        openingTagName: An(n.name),
                      })
                    : Pn(n) ||
                      Pn(i) ||
                      (An(i.name) !== An(n.name) &&
                        this.raise(En.MissingClosingTagElement, {
                          at: i,
                          openingTagName: An(n.name),
                        }));
                }
                if (
                  (Pn(n)
                    ? ((t.openingFragment = n), (t.closingFragment = i))
                    : ((t.openingElement = n), (t.closingElement = i)),
                  (t.children = r),
                  this.match(47))
                )
                  throw this.raise(En.UnwrappedAdjacentJSXElements, {
                    at: this.state.startLoc,
                  });
                return Pn(n)
                  ? this.finishNode(t, "JSXFragment")
                  : this.finishNode(t, "JSXElement");
              },
            },
            {
              key: "jsxParseElement",
              value: function () {
                var e = this.state.startLoc;
                return this.next(), this.jsxParseElementAt(e);
              },
            },
            {
              key: "setContext",
              value: function (e) {
                var t = this.state.context;
                t[t.length - 1] = e;
              },
            },
            {
              key: "parseExprAtom",
              value: function (e) {
                return this.match(139)
                  ? this.parseLiteral(this.state.value, "JSXText")
                  : this.match(140)
                  ? this.jsxParseElement()
                  : this.match(47) &&
                    33 !== this.input.charCodeAt(this.state.pos)
                  ? (this.replaceToken(140), this.jsxParseElement())
                  : Fe(N(r.prototype), "parseExprAtom", this).call(this, e);
              },
            },
            {
              key: "skipSpace",
              value: function () {
                this.curContext().preserveSpace ||
                  Fe(N(r.prototype), "skipSpace", this).call(this);
              },
            },
            {
              key: "getTokenFromCode",
              value: function (e) {
                var t = this.curContext();
                if (t !== mt.j_expr) {
                  if (t === mt.j_oTag || t === mt.j_cTag) {
                    if (Zt(e)) return void this.jsxReadWord();
                    if (62 === e)
                      return ++this.state.pos, void this.finishToken(141);
                    if ((34 === e || 39 === e) && t === mt.j_oTag)
                      return void this.jsxReadString(e);
                  }
                  if (
                    60 === e &&
                    this.state.canStartJSXElement &&
                    33 !== this.input.charCodeAt(this.state.pos + 1)
                  )
                    return ++this.state.pos, void this.finishToken(140);
                  Fe(N(r.prototype), "getTokenFromCode", this).call(this, e);
                } else this.jsxReadToken();
              },
            },
            {
              key: "updateContext",
              value: function (e) {
                var t = this.state,
                  r = t.context,
                  n = t.type;
                if (56 === n && 140 === e)
                  r.splice(-2, 2, mt.j_cTag),
                    (this.state.canStartJSXElement = !1);
                else if (140 === n) r.push(mt.j_oTag);
                else if (141 === n) {
                  var i = r[r.length - 1];
                  (i === mt.j_oTag && 56 === e) || i === mt.j_cTag
                    ? (r.pop(),
                      (this.state.canStartJSXElement =
                        r[r.length - 1] === mt.j_expr))
                    : (this.setContext(mt.j_expr),
                      (this.state.canStartJSXElement = !0));
                } else this.state.canStartJSXElement = Ot[n];
              },
            },
          ]),
          r
        );
      })(e);
    },
    flow: function (e) {
      return (function (e) {
        I(r, e);
        var t = Je(r);
        function r() {
          var e;
          E(this, r);
          for (var n = arguments.length, i = new Array(n), a = 0; a < n; a++)
            i[a] = arguments[a];
          return (
            ((e = t.call.apply(t, [this].concat(i))).flowPragma = void 0), e
          );
        }
        return (
          A(r, [
            {
              key: "getScopeHandler",
              value: function () {
                return Ar;
              },
            },
            {
              key: "shouldParseTypes",
              value: function () {
                return (
                  this.getPluginOption("flow", "all") ||
                  "flow" === this.flowPragma
                );
              },
            },
            {
              key: "shouldParseEnums",
              value: function () {
                return !!this.getPluginOption("flow", "enums");
              },
            },
            {
              key: "finishToken",
              value: function (e, t) {
                131 !== e &&
                  13 !== e &&
                  28 !== e &&
                  void 0 === this.flowPragma &&
                  (this.flowPragma = null),
                  Fe(N(r.prototype), "finishToken", this).call(this, e, t);
              },
            },
            {
              key: "addComment",
              value: function (e) {
                if (void 0 === this.flowPragma) {
                  var t = Sn.exec(e.value);
                  if (t)
                    if ("flow" === t[1]) this.flowPragma = "flow";
                    else {
                      if ("noflow" !== t[1])
                        throw new Error("Unexpected flow pragma");
                      this.flowPragma = "noflow";
                    }
                  else;
                }
                Fe(N(r.prototype), "addComment", this).call(this, e);
              },
            },
            {
              key: "flowParseTypeInitialiser",
              value: function (e) {
                var t = this.state.inType;
                (this.state.inType = !0), this.expect(e || 14);
                var r = this.flowParseType();
                return (this.state.inType = t), r;
              },
            },
            {
              key: "flowParsePredicate",
              value: function () {
                var e = this.startNode(),
                  t = this.state.startLoc;
                return (
                  this.next(),
                  this.expectContextual(108),
                  this.state.lastTokStart > t.index + 1 &&
                    this.raise(vn.UnexpectedSpaceBetweenModuloChecks, {
                      at: t,
                    }),
                  this.eat(10)
                    ? ((e.value = Fe(
                        N(r.prototype),
                        "parseExpression",
                        this
                      ).call(this)),
                      this.expect(11),
                      this.finishNode(e, "DeclaredPredicate"))
                    : this.finishNode(e, "InferredPredicate")
                );
              },
            },
            {
              key: "flowParseTypeAndPredicateInitialiser",
              value: function () {
                var e = this.state.inType;
                (this.state.inType = !0), this.expect(14);
                var t = null,
                  r = null;
                return (
                  this.match(54)
                    ? ((this.state.inType = e), (r = this.flowParsePredicate()))
                    : ((t = this.flowParseType()),
                      (this.state.inType = e),
                      this.match(54) && (r = this.flowParsePredicate())),
                  [t, r]
                );
              },
            },
            {
              key: "flowParseDeclareClass",
              value: function (e) {
                return (
                  this.next(),
                  this.flowParseInterfaceish(e, !0),
                  this.finishNode(e, "DeclareClass")
                );
              },
            },
            {
              key: "flowParseDeclareFunction",
              value: function (e) {
                this.next();
                var t = (e.id = this.parseIdentifier()),
                  r = this.startNode(),
                  n = this.startNode();
                this.match(47)
                  ? (r.typeParameters =
                      this.flowParseTypeParameterDeclaration())
                  : (r.typeParameters = null),
                  this.expect(10);
                var i = this.flowParseFunctionTypeParams();
                (r.params = i.params),
                  (r.rest = i.rest),
                  (r.this = i._this),
                  this.expect(11);
                var a = H(this.flowParseTypeAndPredicateInitialiser(), 2);
                return (
                  (r.returnType = a[0]),
                  (e.predicate = a[1]),
                  (n.typeAnnotation = this.finishNode(
                    r,
                    "FunctionTypeAnnotation"
                  )),
                  (t.typeAnnotation = this.finishNode(n, "TypeAnnotation")),
                  this.resetEndLocation(t),
                  this.semicolon(),
                  this.scope.declareName(e.id.name, 2048, e.id.loc.start),
                  this.finishNode(e, "DeclareFunction")
                );
              },
            },
            {
              key: "flowParseDeclare",
              value: function (e, t) {
                return this.match(80)
                  ? this.flowParseDeclareClass(e)
                  : this.match(68)
                  ? this.flowParseDeclareFunction(e)
                  : this.match(74)
                  ? this.flowParseDeclareVariable(e)
                  : this.eatContextual(125)
                  ? this.match(16)
                    ? this.flowParseDeclareModuleExports(e)
                    : (t &&
                        this.raise(vn.NestedDeclareModule, {
                          at: this.state.lastTokStartLoc,
                        }),
                      this.flowParseDeclareModule(e))
                  : this.isContextual(128)
                  ? this.flowParseDeclareTypeAlias(e)
                  : this.isContextual(129)
                  ? this.flowParseDeclareOpaqueType(e)
                  : this.isContextual(127)
                  ? this.flowParseDeclareInterface(e)
                  : this.match(82)
                  ? this.flowParseDeclareExportDeclaration(e, t)
                  : void this.unexpected();
              },
            },
            {
              key: "flowParseDeclareVariable",
              value: function (e) {
                return (
                  this.next(),
                  (e.id = this.flowParseTypeAnnotatableIdentifier(!0)),
                  this.scope.declareName(e.id.name, 5, e.id.loc.start),
                  this.semicolon(),
                  this.finishNode(e, "DeclareVariable")
                );
              },
            },
            {
              key: "flowParseDeclareModule",
              value: function (e) {
                var t = this;
                this.scope.enter(0),
                  this.match(131)
                    ? (e.id = Fe(N(r.prototype), "parseExprAtom", this).call(
                        this
                      ))
                    : (e.id = this.parseIdentifier());
                var n = (e.body = this.startNode()),
                  i = (n.body = []);
                for (this.expect(5); !this.match(8); ) {
                  var a = this.startNode();
                  this.match(83)
                    ? (this.next(),
                      this.isContextual(128) ||
                        this.match(87) ||
                        this.raise(vn.InvalidNonTypeImportInDeclareModule, {
                          at: this.state.lastTokStartLoc,
                        }),
                      Fe(N(r.prototype), "parseImport", this).call(this, a))
                    : (this.expectContextual(
                        123,
                        vn.UnsupportedStatementInDeclareModule
                      ),
                      (a = this.flowParseDeclare(a, !0))),
                    i.push(a);
                }
                this.scope.exit(),
                  this.expect(8),
                  this.finishNode(n, "BlockStatement");
                var s = null,
                  o = !1;
                return (
                  i.forEach(function (e) {
                    !(function (e) {
                      return (
                        "DeclareExportAllDeclaration" === e.type ||
                        ("DeclareExportDeclaration" === e.type &&
                          (!e.declaration ||
                            ("TypeAlias" !== e.declaration.type &&
                              "InterfaceDeclaration" !== e.declaration.type)))
                      );
                    })(e)
                      ? "DeclareModuleExports" === e.type &&
                        (o &&
                          t.raise(vn.DuplicateDeclareModuleExports, { at: e }),
                        "ES" === s &&
                          t.raise(vn.AmbiguousDeclareModuleKind, { at: e }),
                        (s = "CommonJS"),
                        (o = !0))
                      : ("CommonJS" === s &&
                          t.raise(vn.AmbiguousDeclareModuleKind, { at: e }),
                        (s = "ES"));
                  }),
                  (e.kind = s || "CommonJS"),
                  this.finishNode(e, "DeclareModule")
                );
              },
            },
            {
              key: "flowParseDeclareExportDeclaration",
              value: function (e, t) {
                if ((this.expect(82), this.eat(65)))
                  return (
                    this.match(68) || this.match(80)
                      ? (e.declaration = this.flowParseDeclare(
                          this.startNode()
                        ))
                      : ((e.declaration = this.flowParseType()),
                        this.semicolon()),
                    (e.default = !0),
                    this.finishNode(e, "DeclareExportDeclaration")
                  );
                if (
                  this.match(75) ||
                  this.isLet() ||
                  ((this.isContextual(128) || this.isContextual(127)) && !t)
                ) {
                  var r = this.state.value;
                  throw this.raise(vn.UnsupportedDeclareExportKind, {
                    at: this.state.startLoc,
                    unsupportedExportKind: r,
                    suggestion: Tn[r],
                  });
                }
                return this.match(74) ||
                  this.match(68) ||
                  this.match(80) ||
                  this.isContextual(129)
                  ? ((e.declaration = this.flowParseDeclare(this.startNode())),
                    (e.default = !1),
                    this.finishNode(e, "DeclareExportDeclaration"))
                  : this.match(55) ||
                    this.match(5) ||
                    this.isContextual(127) ||
                    this.isContextual(128) ||
                    this.isContextual(129)
                  ? ("ExportNamedDeclaration" ===
                      (e = this.parseExport(e, null)).type &&
                      ((e.type = "ExportDeclaration"),
                      (e.default = !1),
                      delete e.exportKind),
                    (e.type = "Declare" + e.type),
                    e)
                  : void this.unexpected();
              },
            },
            {
              key: "flowParseDeclareModuleExports",
              value: function (e) {
                return (
                  this.next(),
                  this.expectContextual(109),
                  (e.typeAnnotation = this.flowParseTypeAnnotation()),
                  this.semicolon(),
                  this.finishNode(e, "DeclareModuleExports")
                );
              },
            },
            {
              key: "flowParseDeclareTypeAlias",
              value: function (e) {
                this.next();
                var t = this.flowParseTypeAlias(e);
                return (t.type = "DeclareTypeAlias"), t;
              },
            },
            {
              key: "flowParseDeclareOpaqueType",
              value: function (e) {
                this.next();
                var t = this.flowParseOpaqueType(e, !0);
                return (t.type = "DeclareOpaqueType"), t;
              },
            },
            {
              key: "flowParseDeclareInterface",
              value: function (e) {
                return (
                  this.next(),
                  this.flowParseInterfaceish(e, !1),
                  this.finishNode(e, "DeclareInterface")
                );
              },
            },
            {
              key: "flowParseInterfaceish",
              value: function (e, t) {
                if (
                  ((e.id = this.flowParseRestrictedIdentifier(!t, !0)),
                  this.scope.declareName(
                    e.id.name,
                    t ? 17 : Tr,
                    e.id.loc.start
                  ),
                  this.match(47)
                    ? (e.typeParameters =
                        this.flowParseTypeParameterDeclaration())
                    : (e.typeParameters = null),
                  (e.extends = []),
                  this.eat(81))
                )
                  do {
                    e.extends.push(this.flowParseInterfaceExtends());
                  } while (!t && this.eat(12));
                if (t) {
                  if (
                    ((e.implements = []),
                    (e.mixins = []),
                    this.eatContextual(115))
                  )
                    do {
                      e.mixins.push(this.flowParseInterfaceExtends());
                    } while (this.eat(12));
                  if (this.eatContextual(111))
                    do {
                      e.implements.push(this.flowParseInterfaceExtends());
                    } while (this.eat(12));
                }
                e.body = this.flowParseObjectType({
                  allowStatic: t,
                  allowExact: !1,
                  allowSpread: !1,
                  allowProto: t,
                  allowInexact: !1,
                });
              },
            },
            {
              key: "flowParseInterfaceExtends",
              value: function () {
                var e = this.startNode();
                return (
                  (e.id = this.flowParseQualifiedTypeIdentifier()),
                  this.match(47)
                    ? (e.typeParameters =
                        this.flowParseTypeParameterInstantiation())
                    : (e.typeParameters = null),
                  this.finishNode(e, "InterfaceExtends")
                );
              },
            },
            {
              key: "flowParseInterface",
              value: function (e) {
                return (
                  this.flowParseInterfaceish(e, !1),
                  this.finishNode(e, "InterfaceDeclaration")
                );
              },
            },
            {
              key: "checkNotUnderscore",
              value: function (e) {
                "_" === e &&
                  this.raise(vn.UnexpectedReservedUnderscore, {
                    at: this.state.startLoc,
                  });
              },
            },
            {
              key: "checkReservedType",
              value: function (e, t, r) {
                mn.has(e) &&
                  this.raise(
                    r ? vn.AssignReservedType : vn.UnexpectedReservedType,
                    { at: t, reservedType: e }
                  );
              },
            },
            {
              key: "flowParseRestrictedIdentifier",
              value: function (e, t) {
                return (
                  this.checkReservedType(
                    this.state.value,
                    this.state.startLoc,
                    t
                  ),
                  this.parseIdentifier(e)
                );
              },
            },
            {
              key: "flowParseTypeAlias",
              value: function (e) {
                return (
                  (e.id = this.flowParseRestrictedIdentifier(!1, !0)),
                  this.scope.declareName(e.id.name, Tr, e.id.loc.start),
                  this.match(47)
                    ? (e.typeParameters =
                        this.flowParseTypeParameterDeclaration())
                    : (e.typeParameters = null),
                  (e.right = this.flowParseTypeInitialiser(29)),
                  this.semicolon(),
                  this.finishNode(e, "TypeAlias")
                );
              },
            },
            {
              key: "flowParseOpaqueType",
              value: function (e, t) {
                return (
                  this.expectContextual(128),
                  (e.id = this.flowParseRestrictedIdentifier(!0, !0)),
                  this.scope.declareName(e.id.name, Tr, e.id.loc.start),
                  this.match(47)
                    ? (e.typeParameters =
                        this.flowParseTypeParameterDeclaration())
                    : (e.typeParameters = null),
                  (e.supertype = null),
                  this.match(14) &&
                    (e.supertype = this.flowParseTypeInitialiser(14)),
                  (e.impltype = null),
                  t || (e.impltype = this.flowParseTypeInitialiser(29)),
                  this.semicolon(),
                  this.finishNode(e, "OpaqueType")
                );
              },
            },
            {
              key: "flowParseTypeParameter",
              value: function () {
                var e =
                    arguments.length > 0 &&
                    void 0 !== arguments[0] &&
                    arguments[0],
                  t = this.state.startLoc,
                  r = this.startNode(),
                  n = this.flowParseVariance(),
                  i = this.flowParseTypeAnnotatableIdentifier();
                return (
                  (r.name = i.name),
                  (r.variance = n),
                  (r.bound = i.typeAnnotation),
                  this.match(29)
                    ? (this.eat(29), (r.default = this.flowParseType()))
                    : e && this.raise(vn.MissingTypeParamDefault, { at: t }),
                  this.finishNode(r, "TypeParameter")
                );
              },
            },
            {
              key: "flowParseTypeParameterDeclaration",
              value: function () {
                var e = this.state.inType,
                  t = this.startNode();
                (t.params = []),
                  (this.state.inType = !0),
                  this.match(47) || this.match(140)
                    ? this.next()
                    : this.unexpected();
                var r = !1;
                do {
                  var n = this.flowParseTypeParameter(r);
                  t.params.push(n),
                    n.default && (r = !0),
                    this.match(48) || this.expect(12);
                } while (!this.match(48));
                return (
                  this.expect(48),
                  (this.state.inType = e),
                  this.finishNode(t, "TypeParameterDeclaration")
                );
              },
            },
            {
              key: "flowParseTypeParameterInstantiation",
              value: function () {
                var e = this.startNode(),
                  t = this.state.inType;
                (e.params = []), (this.state.inType = !0), this.expect(47);
                var r = this.state.noAnonFunctionType;
                for (this.state.noAnonFunctionType = !1; !this.match(48); )
                  e.params.push(this.flowParseType()),
                    this.match(48) || this.expect(12);
                return (
                  (this.state.noAnonFunctionType = r),
                  this.expect(48),
                  (this.state.inType = t),
                  this.finishNode(e, "TypeParameterInstantiation")
                );
              },
            },
            {
              key: "flowParseTypeParameterInstantiationCallOrNew",
              value: function () {
                var e = this.startNode(),
                  t = this.state.inType;
                for (
                  e.params = [], this.state.inType = !0, this.expect(47);
                  !this.match(48);

                )
                  e.params.push(this.flowParseTypeOrImplicitInstantiation()),
                    this.match(48) || this.expect(12);
                return (
                  this.expect(48),
                  (this.state.inType = t),
                  this.finishNode(e, "TypeParameterInstantiation")
                );
              },
            },
            {
              key: "flowParseInterfaceType",
              value: function () {
                var e = this.startNode();
                if (
                  (this.expectContextual(127), (e.extends = []), this.eat(81))
                )
                  do {
                    e.extends.push(this.flowParseInterfaceExtends());
                  } while (this.eat(12));
                return (
                  (e.body = this.flowParseObjectType({
                    allowStatic: !1,
                    allowExact: !1,
                    allowSpread: !1,
                    allowProto: !1,
                    allowInexact: !1,
                  })),
                  this.finishNode(e, "InterfaceTypeAnnotation")
                );
              },
            },
            {
              key: "flowParseObjectPropertyKey",
              value: function () {
                return this.match(132) || this.match(131)
                  ? Fe(N(r.prototype), "parseExprAtom", this).call(this)
                  : this.parseIdentifier(!0);
              },
            },
            {
              key: "flowParseObjectTypeIndexer",
              value: function (e, t, r) {
                return (
                  (e.static = t),
                  14 === this.lookahead().type
                    ? ((e.id = this.flowParseObjectPropertyKey()),
                      (e.key = this.flowParseTypeInitialiser()))
                    : ((e.id = null), (e.key = this.flowParseType())),
                  this.expect(3),
                  (e.value = this.flowParseTypeInitialiser()),
                  (e.variance = r),
                  this.finishNode(e, "ObjectTypeIndexer")
                );
              },
            },
            {
              key: "flowParseObjectTypeInternalSlot",
              value: function (e, t) {
                return (
                  (e.static = t),
                  (e.id = this.flowParseObjectPropertyKey()),
                  this.expect(3),
                  this.expect(3),
                  this.match(47) || this.match(10)
                    ? ((e.method = !0),
                      (e.optional = !1),
                      (e.value = this.flowParseObjectTypeMethodish(
                        this.startNodeAt(e.loc.start)
                      )))
                    : ((e.method = !1),
                      this.eat(17) && (e.optional = !0),
                      (e.value = this.flowParseTypeInitialiser())),
                  this.finishNode(e, "ObjectTypeInternalSlot")
                );
              },
            },
            {
              key: "flowParseObjectTypeMethodish",
              value: function (e) {
                for (
                  e.params = [],
                    e.rest = null,
                    e.typeParameters = null,
                    e.this = null,
                    this.match(47) &&
                      (e.typeParameters =
                        this.flowParseTypeParameterDeclaration()),
                    this.expect(10),
                    this.match(78) &&
                      ((e.this = this.flowParseFunctionTypeParam(!0)),
                      (e.this.name = null),
                      this.match(11) || this.expect(12));
                  !this.match(11) && !this.match(21);

                )
                  e.params.push(this.flowParseFunctionTypeParam(!1)),
                    this.match(11) || this.expect(12);
                return (
                  this.eat(21) &&
                    (e.rest = this.flowParseFunctionTypeParam(!1)),
                  this.expect(11),
                  (e.returnType = this.flowParseTypeInitialiser()),
                  this.finishNode(e, "FunctionTypeAnnotation")
                );
              },
            },
            {
              key: "flowParseObjectTypeCallProperty",
              value: function (e, t) {
                var r = this.startNode();
                return (
                  (e.static = t),
                  (e.value = this.flowParseObjectTypeMethodish(r)),
                  this.finishNode(e, "ObjectTypeCallProperty")
                );
              },
            },
            {
              key: "flowParseObjectType",
              value: function (e) {
                var t = e.allowStatic,
                  r = e.allowExact,
                  n = e.allowSpread,
                  i = e.allowProto,
                  a = e.allowInexact,
                  s = this.state.inType;
                this.state.inType = !0;
                var o,
                  l,
                  u = this.startNode();
                (u.callProperties = []),
                  (u.properties = []),
                  (u.indexers = []),
                  (u.internalSlots = []);
                var c = !1;
                for (
                  r && this.match(6)
                    ? (this.expect(6), (o = 9), (l = !0))
                    : (this.expect(5), (o = 8), (l = !1)),
                    u.exact = l;
                  !this.match(o);

                ) {
                  var p = !1,
                    h = null,
                    d = null,
                    f = this.startNode();
                  if (i && this.isContextual(116)) {
                    var y = this.lookahead();
                    14 !== y.type &&
                      17 !== y.type &&
                      (this.next(), (h = this.state.startLoc), (t = !1));
                  }
                  if (t && this.isContextual(104)) {
                    var m = this.lookahead();
                    14 !== m.type && 17 !== m.type && (this.next(), (p = !0));
                  }
                  var v = this.flowParseVariance();
                  if (this.eat(0))
                    null != h && this.unexpected(h),
                      this.eat(0)
                        ? (v && this.unexpected(v.loc.start),
                          u.internalSlots.push(
                            this.flowParseObjectTypeInternalSlot(f, p)
                          ))
                        : u.indexers.push(
                            this.flowParseObjectTypeIndexer(f, p, v)
                          );
                  else if (this.match(10) || this.match(47))
                    null != h && this.unexpected(h),
                      v && this.unexpected(v.loc.start),
                      u.callProperties.push(
                        this.flowParseObjectTypeCallProperty(f, p)
                      );
                  else {
                    var g = "init";
                    if (this.isContextual(98) || this.isContextual(103))
                      Bt(this.lookahead().type) &&
                        ((g = this.state.value), this.next());
                    var b = this.flowParseObjectTypeProperty(
                      f,
                      p,
                      h,
                      v,
                      g,
                      n,
                      null != a ? a : !l
                    );
                    null === b
                      ? ((c = !0), (d = this.state.lastTokStartLoc))
                      : u.properties.push(b);
                  }
                  this.flowObjectTypeSemicolon(),
                    !d ||
                      this.match(8) ||
                      this.match(9) ||
                      this.raise(vn.UnexpectedExplicitInexactInObject, {
                        at: d,
                      });
                }
                this.expect(o), n && (u.inexact = c);
                var T = this.finishNode(u, "ObjectTypeAnnotation");
                return (this.state.inType = s), T;
              },
            },
            {
              key: "flowParseObjectTypeProperty",
              value: function (e, t, r, n, i, a, s) {
                if (this.eat(21))
                  return this.match(12) ||
                    this.match(13) ||
                    this.match(8) ||
                    this.match(9)
                    ? (a
                        ? s ||
                          this.raise(vn.InexactInsideExact, {
                            at: this.state.lastTokStartLoc,
                          })
                        : this.raise(vn.InexactInsideNonObject, {
                            at: this.state.lastTokStartLoc,
                          }),
                      n && this.raise(vn.InexactVariance, { at: n }),
                      null)
                    : (a ||
                        this.raise(vn.UnexpectedSpreadType, {
                          at: this.state.lastTokStartLoc,
                        }),
                      null != r && this.unexpected(r),
                      n && this.raise(vn.SpreadVariance, { at: n }),
                      (e.argument = this.flowParseType()),
                      this.finishNode(e, "ObjectTypeSpreadProperty"));
                (e.key = this.flowParseObjectPropertyKey()),
                  (e.static = t),
                  (e.proto = null != r),
                  (e.kind = i);
                var o = !1;
                return (
                  this.match(47) || this.match(10)
                    ? ((e.method = !0),
                      null != r && this.unexpected(r),
                      n && this.unexpected(n.loc.start),
                      (e.value = this.flowParseObjectTypeMethodish(
                        this.startNodeAt(e.loc.start)
                      )),
                      ("get" !== i && "set" !== i) ||
                        this.flowCheckGetterSetterParams(e),
                      !a &&
                        "constructor" === e.key.name &&
                        e.value.this &&
                        this.raise(vn.ThisParamBannedInConstructor, {
                          at: e.value.this,
                        }))
                    : ("init" !== i && this.unexpected(),
                      (e.method = !1),
                      this.eat(17) && (o = !0),
                      (e.value = this.flowParseTypeInitialiser()),
                      (e.variance = n)),
                  (e.optional = o),
                  this.finishNode(e, "ObjectTypeProperty")
                );
              },
            },
            {
              key: "flowCheckGetterSetterParams",
              value: function (e) {
                var t = "get" === e.kind ? 0 : 1,
                  r = e.value.params.length + (e.value.rest ? 1 : 0);
                e.value.this &&
                  this.raise(
                    "get" === e.kind
                      ? vn.GetterMayNotHaveThisParam
                      : vn.SetterMayNotHaveThisParam,
                    { at: e.value.this }
                  ),
                  r !== t &&
                    this.raise(
                      "get" === e.kind ? pt.BadGetterArity : pt.BadSetterArity,
                      { at: e }
                    ),
                  "set" === e.kind &&
                    e.value.rest &&
                    this.raise(pt.BadSetterRestParameter, { at: e });
              },
            },
            {
              key: "flowObjectTypeSemicolon",
              value: function () {
                this.eat(13) ||
                  this.eat(12) ||
                  this.match(8) ||
                  this.match(9) ||
                  this.unexpected();
              },
            },
            {
              key: "flowParseQualifiedTypeIdentifier",
              value: function (e, t) {
                null != e || (e = this.state.startLoc);
                for (
                  var r = t || this.flowParseRestrictedIdentifier(!0);
                  this.eat(16);

                ) {
                  var n = this.startNodeAt(e);
                  (n.qualification = r),
                    (n.id = this.flowParseRestrictedIdentifier(!0)),
                    (r = this.finishNode(n, "QualifiedTypeIdentifier"));
                }
                return r;
              },
            },
            {
              key: "flowParseGenericType",
              value: function (e, t) {
                var r = this.startNodeAt(e);
                return (
                  (r.typeParameters = null),
                  (r.id = this.flowParseQualifiedTypeIdentifier(e, t)),
                  this.match(47) &&
                    (r.typeParameters =
                      this.flowParseTypeParameterInstantiation()),
                  this.finishNode(r, "GenericTypeAnnotation")
                );
              },
            },
            {
              key: "flowParseTypeofType",
              value: function () {
                var e = this.startNode();
                return (
                  this.expect(87),
                  (e.argument = this.flowParsePrimaryType()),
                  this.finishNode(e, "TypeofTypeAnnotation")
                );
              },
            },
            {
              key: "flowParseTupleType",
              value: function () {
                var e = this.startNode();
                for (
                  e.types = [], this.expect(0);
                  this.state.pos < this.length &&
                  !this.match(3) &&
                  (e.types.push(this.flowParseType()), !this.match(3));

                )
                  this.expect(12);
                return (
                  this.expect(3), this.finishNode(e, "TupleTypeAnnotation")
                );
              },
            },
            {
              key: "flowParseFunctionTypeParam",
              value: function (e) {
                var t = null,
                  r = !1,
                  n = null,
                  i = this.startNode(),
                  a = this.lookahead(),
                  s = 78 === this.state.type;
                return (
                  14 === a.type || 17 === a.type
                    ? (s &&
                        !e &&
                        this.raise(vn.ThisParamMustBeFirst, { at: i }),
                      (t = this.parseIdentifier(s)),
                      this.eat(17) &&
                        ((r = !0),
                        s &&
                          this.raise(vn.ThisParamMayNotBeOptional, { at: i })),
                      (n = this.flowParseTypeInitialiser()))
                    : (n = this.flowParseType()),
                  (i.name = t),
                  (i.optional = r),
                  (i.typeAnnotation = n),
                  this.finishNode(i, "FunctionTypeParam")
                );
              },
            },
            {
              key: "reinterpretTypeAsFunctionTypeParam",
              value: function (e) {
                var t = this.startNodeAt(e.loc.start);
                return (
                  (t.name = null),
                  (t.optional = !1),
                  (t.typeAnnotation = e),
                  this.finishNode(t, "FunctionTypeParam")
                );
              },
            },
            {
              key: "flowParseFunctionTypeParams",
              value: function () {
                var e =
                    arguments.length > 0 && void 0 !== arguments[0]
                      ? arguments[0]
                      : [],
                  t = null,
                  r = null;
                for (
                  this.match(78) &&
                  (((r = this.flowParseFunctionTypeParam(!0)).name = null),
                  this.match(11) || this.expect(12));
                  !this.match(11) && !this.match(21);

                )
                  e.push(this.flowParseFunctionTypeParam(!1)),
                    this.match(11) || this.expect(12);
                return (
                  this.eat(21) && (t = this.flowParseFunctionTypeParam(!1)),
                  { params: e, rest: t, _this: r }
                );
              },
            },
            {
              key: "flowIdentToTypeAnnotation",
              value: function (e, t, r) {
                switch (r.name) {
                  case "any":
                    return this.finishNode(t, "AnyTypeAnnotation");
                  case "bool":
                  case "boolean":
                    return this.finishNode(t, "BooleanTypeAnnotation");
                  case "mixed":
                    return this.finishNode(t, "MixedTypeAnnotation");
                  case "empty":
                    return this.finishNode(t, "EmptyTypeAnnotation");
                  case "number":
                    return this.finishNode(t, "NumberTypeAnnotation");
                  case "string":
                    return this.finishNode(t, "StringTypeAnnotation");
                  case "symbol":
                    return this.finishNode(t, "SymbolTypeAnnotation");
                  default:
                    return (
                      this.checkNotUnderscore(r.name),
                      this.flowParseGenericType(e, r)
                    );
                }
              },
            },
            {
              key: "flowParsePrimaryType",
              value: function () {
                var e,
                  t,
                  n = this.state.startLoc,
                  i = this.startNode(),
                  a = !1,
                  s = this.state.noAnonFunctionType;
                switch (this.state.type) {
                  case 5:
                    return this.flowParseObjectType({
                      allowStatic: !1,
                      allowExact: !1,
                      allowSpread: !0,
                      allowProto: !1,
                      allowInexact: !0,
                    });
                  case 6:
                    return this.flowParseObjectType({
                      allowStatic: !1,
                      allowExact: !0,
                      allowSpread: !0,
                      allowProto: !1,
                      allowInexact: !1,
                    });
                  case 0:
                    return (
                      (this.state.noAnonFunctionType = !1),
                      (t = this.flowParseTupleType()),
                      (this.state.noAnonFunctionType = s),
                      t
                    );
                  case 47:
                    return (
                      (i.typeParameters =
                        this.flowParseTypeParameterDeclaration()),
                      this.expect(10),
                      (e = this.flowParseFunctionTypeParams()),
                      (i.params = e.params),
                      (i.rest = e.rest),
                      (i.this = e._this),
                      this.expect(11),
                      this.expect(19),
                      (i.returnType = this.flowParseType()),
                      this.finishNode(i, "FunctionTypeAnnotation")
                    );
                  case 10:
                    if ((this.next(), !this.match(11) && !this.match(21)))
                      if (jt(this.state.type) || this.match(78)) {
                        var o = this.lookahead().type;
                        a = 17 !== o && 14 !== o;
                      } else a = !0;
                    if (a) {
                      if (
                        ((this.state.noAnonFunctionType = !1),
                        (t = this.flowParseType()),
                        (this.state.noAnonFunctionType = s),
                        this.state.noAnonFunctionType ||
                          !(
                            this.match(12) ||
                            (this.match(11) && 19 === this.lookahead().type)
                          ))
                      )
                        return this.expect(11), t;
                      this.eat(12);
                    }
                    return (
                      (e = t
                        ? this.flowParseFunctionTypeParams([
                            this.reinterpretTypeAsFunctionTypeParam(t),
                          ])
                        : this.flowParseFunctionTypeParams()),
                      (i.params = e.params),
                      (i.rest = e.rest),
                      (i.this = e._this),
                      this.expect(11),
                      this.expect(19),
                      (i.returnType = this.flowParseType()),
                      (i.typeParameters = null),
                      this.finishNode(i, "FunctionTypeAnnotation")
                    );
                  case 131:
                    return this.parseLiteral(
                      this.state.value,
                      "StringLiteralTypeAnnotation"
                    );
                  case 85:
                  case 86:
                    return (
                      (i.value = this.match(85)),
                      this.next(),
                      this.finishNode(i, "BooleanLiteralTypeAnnotation")
                    );
                  case 53:
                    if ("-" === this.state.value) {
                      if ((this.next(), this.match(132)))
                        return this.parseLiteralAtNode(
                          -this.state.value,
                          "NumberLiteralTypeAnnotation",
                          i
                        );
                      if (this.match(133))
                        return this.parseLiteralAtNode(
                          -this.state.value,
                          "BigIntLiteralTypeAnnotation",
                          i
                        );
                      throw this.raise(vn.UnexpectedSubtractionOperand, {
                        at: this.state.startLoc,
                      });
                    }
                    return void this.unexpected();
                  case 132:
                    return this.parseLiteral(
                      this.state.value,
                      "NumberLiteralTypeAnnotation"
                    );
                  case 133:
                    return this.parseLiteral(
                      this.state.value,
                      "BigIntLiteralTypeAnnotation"
                    );
                  case 88:
                    return (
                      this.next(), this.finishNode(i, "VoidTypeAnnotation")
                    );
                  case 84:
                    return (
                      this.next(),
                      this.finishNode(i, "NullLiteralTypeAnnotation")
                    );
                  case 78:
                    return (
                      this.next(), this.finishNode(i, "ThisTypeAnnotation")
                    );
                  case 55:
                    return (
                      this.next(), this.finishNode(i, "ExistsTypeAnnotation")
                    );
                  case 87:
                    return this.flowParseTypeofType();
                  default:
                    if (Vt(this.state.type)) {
                      var l = Kt(this.state.type);
                      return (
                        this.next(),
                        Fe(N(r.prototype), "createIdentifier", this).call(
                          this,
                          i,
                          l
                        )
                      );
                    }
                    if (jt(this.state.type))
                      return this.isContextual(127)
                        ? this.flowParseInterfaceType()
                        : this.flowIdentToTypeAnnotation(
                            n,
                            i,
                            this.parseIdentifier()
                          );
                }
                this.unexpected();
              },
            },
            {
              key: "flowParsePostfixType",
              value: function () {
                for (
                  var e = this.state.startLoc,
                    t = this.flowParsePrimaryType(),
                    r = !1;
                  (this.match(0) || this.match(18)) &&
                  !this.canInsertSemicolon();

                ) {
                  var n = this.startNodeAt(e),
                    i = this.eat(18);
                  (r = r || i),
                    this.expect(0),
                    !i && this.match(3)
                      ? ((n.elementType = t),
                        this.next(),
                        (t = this.finishNode(n, "ArrayTypeAnnotation")))
                      : ((n.objectType = t),
                        (n.indexType = this.flowParseType()),
                        this.expect(3),
                        r
                          ? ((n.optional = i),
                            (t = this.finishNode(
                              n,
                              "OptionalIndexedAccessType"
                            )))
                          : (t = this.finishNode(n, "IndexedAccessType")));
                }
                return t;
              },
            },
            {
              key: "flowParsePrefixType",
              value: function () {
                var e = this.startNode();
                return this.eat(17)
                  ? ((e.typeAnnotation = this.flowParsePrefixType()),
                    this.finishNode(e, "NullableTypeAnnotation"))
                  : this.flowParsePostfixType();
              },
            },
            {
              key: "flowParseAnonFunctionWithoutParens",
              value: function () {
                var e = this.flowParsePrefixType();
                if (!this.state.noAnonFunctionType && this.eat(19)) {
                  var t = this.startNodeAt(e.loc.start);
                  return (
                    (t.params = [this.reinterpretTypeAsFunctionTypeParam(e)]),
                    (t.rest = null),
                    (t.this = null),
                    (t.returnType = this.flowParseType()),
                    (t.typeParameters = null),
                    this.finishNode(t, "FunctionTypeAnnotation")
                  );
                }
                return e;
              },
            },
            {
              key: "flowParseIntersectionType",
              value: function () {
                var e = this.startNode();
                this.eat(45);
                var t = this.flowParseAnonFunctionWithoutParens();
                for (e.types = [t]; this.eat(45); )
                  e.types.push(this.flowParseAnonFunctionWithoutParens());
                return 1 === e.types.length
                  ? t
                  : this.finishNode(e, "IntersectionTypeAnnotation");
              },
            },
            {
              key: "flowParseUnionType",
              value: function () {
                var e = this.startNode();
                this.eat(43);
                var t = this.flowParseIntersectionType();
                for (e.types = [t]; this.eat(43); )
                  e.types.push(this.flowParseIntersectionType());
                return 1 === e.types.length
                  ? t
                  : this.finishNode(e, "UnionTypeAnnotation");
              },
            },
            {
              key: "flowParseType",
              value: function () {
                var e = this.state.inType;
                this.state.inType = !0;
                var t = this.flowParseUnionType();
                return (this.state.inType = e), t;
              },
            },
            {
              key: "flowParseTypeOrImplicitInstantiation",
              value: function () {
                if (130 === this.state.type && "_" === this.state.value) {
                  var e = this.state.startLoc,
                    t = this.parseIdentifier();
                  return this.flowParseGenericType(e, t);
                }
                return this.flowParseType();
              },
            },
            {
              key: "flowParseTypeAnnotation",
              value: function () {
                var e = this.startNode();
                return (
                  (e.typeAnnotation = this.flowParseTypeInitialiser()),
                  this.finishNode(e, "TypeAnnotation")
                );
              },
            },
            {
              key: "flowParseTypeAnnotatableIdentifier",
              value: function (e) {
                var t = e
                  ? this.parseIdentifier()
                  : this.flowParseRestrictedIdentifier();
                return (
                  this.match(14) &&
                    ((t.typeAnnotation = this.flowParseTypeAnnotation()),
                    this.resetEndLocation(t)),
                  t
                );
              },
            },
            {
              key: "typeCastToParameter",
              value: function (e) {
                return (
                  (e.expression.typeAnnotation = e.typeAnnotation),
                  this.resetEndLocation(e.expression, e.typeAnnotation.loc.end),
                  e.expression
                );
              },
            },
            {
              key: "flowParseVariance",
              value: function () {
                var e = null;
                return this.match(53)
                  ? ((e = this.startNode()),
                    "+" === this.state.value
                      ? (e.kind = "plus")
                      : (e.kind = "minus"),
                    this.next(),
                    this.finishNode(e, "Variance"))
                  : e;
              },
            },
            {
              key: "parseFunctionBody",
              value: function (e, t) {
                var n = this,
                  i =
                    arguments.length > 2 &&
                    void 0 !== arguments[2] &&
                    arguments[2];
                t
                  ? this.forwardNoArrowParamsConversionAt(e, function () {
                      return Fe(N(r.prototype), "parseFunctionBody", n).call(
                        n,
                        e,
                        !0,
                        i
                      );
                    })
                  : Fe(N(r.prototype), "parseFunctionBody", this).call(
                      this,
                      e,
                      !1,
                      i
                    );
              },
            },
            {
              key: "parseFunctionBodyAndFinish",
              value: function (e, t) {
                var n =
                  arguments.length > 2 &&
                  void 0 !== arguments[2] &&
                  arguments[2];
                if (this.match(14)) {
                  var i = this.startNode(),
                    a = H(this.flowParseTypeAndPredicateInitialiser(), 2);
                  (i.typeAnnotation = a[0]),
                    (e.predicate = a[1]),
                    (e.returnType = i.typeAnnotation
                      ? this.finishNode(i, "TypeAnnotation")
                      : null);
                }
                return Fe(
                  N(r.prototype),
                  "parseFunctionBodyAndFinish",
                  this
                ).call(this, e, t, n);
              },
            },
            {
              key: "parseStatementLike",
              value: function (e) {
                if (this.state.strict && this.isContextual(127)) {
                  if (Ft(this.lookahead().type)) {
                    var t = this.startNode();
                    return this.next(), this.flowParseInterface(t);
                  }
                } else if (this.shouldParseEnums() && this.isContextual(124)) {
                  var n = this.startNode();
                  return this.next(), this.flowParseEnumDeclaration(n);
                }
                var i = Fe(N(r.prototype), "parseStatementLike", this).call(
                  this,
                  e
                );
                return (
                  void 0 !== this.flowPragma ||
                    this.isValidDirective(i) ||
                    (this.flowPragma = null),
                  i
                );
              },
            },
            {
              key: "parseExpressionStatement",
              value: function (e, t, n) {
                if ("Identifier" === t.type)
                  if ("declare" === t.name) {
                    if (
                      this.match(80) ||
                      jt(this.state.type) ||
                      this.match(68) ||
                      this.match(74) ||
                      this.match(82)
                    )
                      return this.flowParseDeclare(e);
                  } else if (jt(this.state.type)) {
                    if ("interface" === t.name)
                      return this.flowParseInterface(e);
                    if ("type" === t.name) return this.flowParseTypeAlias(e);
                    if ("opaque" === t.name)
                      return this.flowParseOpaqueType(e, !1);
                  }
                return Fe(
                  N(r.prototype),
                  "parseExpressionStatement",
                  this
                ).call(this, e, t, n);
              },
            },
            {
              key: "shouldParseExportDeclaration",
              value: function () {
                var e = this.state.type;
                return Ut(e) || (this.shouldParseEnums() && 124 === e)
                  ? !this.state.containsEsc
                  : Fe(
                      N(r.prototype),
                      "shouldParseExportDeclaration",
                      this
                    ).call(this);
              },
            },
            {
              key: "isExportDefaultSpecifier",
              value: function () {
                var e = this.state.type;
                return Ut(e) || (this.shouldParseEnums() && 124 === e)
                  ? this.state.containsEsc
                  : Fe(N(r.prototype), "isExportDefaultSpecifier", this).call(
                      this
                    );
              },
            },
            {
              key: "parseExportDefaultExpression",
              value: function () {
                if (this.shouldParseEnums() && this.isContextual(124)) {
                  var e = this.startNode();
                  return this.next(), this.flowParseEnumDeclaration(e);
                }
                return Fe(
                  N(r.prototype),
                  "parseExportDefaultExpression",
                  this
                ).call(this);
              },
            },
            {
              key: "parseConditional",
              value: function (e, t, r) {
                var n = this;
                if (!this.match(17)) return e;
                if (this.state.maybeInArrowParameters) {
                  var i = this.lookaheadCharCode();
                  if (44 === i || 61 === i || 58 === i || 41 === i)
                    return this.setOptionalParametersError(r), e;
                }
                this.expect(17);
                var a = this.state.clone(),
                  s = this.state.noArrowAt,
                  o = this.startNodeAt(t),
                  l = this.tryParseConditionalConsequent(),
                  u = l.consequent,
                  c = l.failed,
                  p = H(this.getArrowLikeExpressions(u), 2),
                  h = p[0],
                  d = p[1];
                if (c || d.length > 0) {
                  var f = K(s);
                  if (d.length > 0) {
                    (this.state = a), (this.state.noArrowAt = f);
                    for (var y = 0; y < d.length; y++) f.push(d[y].start);
                    var m = this.tryParseConditionalConsequent();
                    (u = m.consequent), (c = m.failed);
                    var v = H(this.getArrowLikeExpressions(u), 2);
                    (h = v[0]), (d = v[1]);
                  }
                  if (
                    (c &&
                      h.length > 1 &&
                      this.raise(vn.AmbiguousConditionalArrow, {
                        at: a.startLoc,
                      }),
                    c && 1 === h.length)
                  ) {
                    (this.state = a),
                      f.push(h[0].start),
                      (this.state.noArrowAt = f);
                    var g = this.tryParseConditionalConsequent();
                    (u = g.consequent), (c = g.failed);
                  }
                }
                return (
                  this.getArrowLikeExpressions(u, !0),
                  (this.state.noArrowAt = s),
                  this.expect(14),
                  (o.test = e),
                  (o.consequent = u),
                  (o.alternate = this.forwardNoArrowParamsConversionAt(
                    o,
                    function () {
                      return n.parseMaybeAssign(void 0, void 0);
                    }
                  )),
                  this.finishNode(o, "ConditionalExpression")
                );
              },
            },
            {
              key: "tryParseConditionalConsequent",
              value: function () {
                this.state.noArrowParamsConversionAt.push(this.state.start);
                var e = this.parseMaybeAssignAllowIn(),
                  t = !this.match(14);
                return (
                  this.state.noArrowParamsConversionAt.pop(),
                  { consequent: e, failed: t }
                );
              },
            },
            {
              key: "getArrowLikeExpressions",
              value: function (e, t) {
                for (var r = this, n = [e], i = []; 0 !== n.length; ) {
                  var a = n.pop();
                  "ArrowFunctionExpression" === a.type
                    ? (a.typeParameters || !a.returnType
                        ? this.finishArrowValidation(a)
                        : i.push(a),
                      n.push(a.body))
                    : "ConditionalExpression" === a.type &&
                      (n.push(a.consequent), n.push(a.alternate));
                }
                return t
                  ? (i.forEach(function (e) {
                      return r.finishArrowValidation(e);
                    }),
                    [i, []])
                  : (function (e, t) {
                      for (var r = [], n = [], i = 0; i < e.length; i++)
                        (t(e[i], i, e) ? r : n).push(e[i]);
                      return [r, n];
                    })(i, function (e) {
                      return e.params.every(function (e) {
                        return r.isAssignable(e, !0);
                      });
                    });
              },
            },
            {
              key: "finishArrowValidation",
              value: function (e) {
                var t;
                this.toAssignableList(
                  e.params,
                  null == (t = e.extra) ? void 0 : t.trailingCommaLoc,
                  !1
                ),
                  this.scope.enter(6),
                  Fe(N(r.prototype), "checkParams", this).call(this, e, !1, !0),
                  this.scope.exit();
              },
            },
            {
              key: "forwardNoArrowParamsConversionAt",
              value: function (e, t) {
                var r;
                return (
                  -1 !== this.state.noArrowParamsConversionAt.indexOf(e.start)
                    ? (this.state.noArrowParamsConversionAt.push(
                        this.state.start
                      ),
                      (r = t()),
                      this.state.noArrowParamsConversionAt.pop())
                    : (r = t()),
                  r
                );
              },
            },
            {
              key: "parseParenItem",
              value: function (e, t) {
                if (
                  ((e = Fe(N(r.prototype), "parseParenItem", this).call(
                    this,
                    e,
                    t
                  )),
                  this.eat(17) && ((e.optional = !0), this.resetEndLocation(e)),
                  this.match(14))
                ) {
                  var n = this.startNodeAt(t);
                  return (
                    (n.expression = e),
                    (n.typeAnnotation = this.flowParseTypeAnnotation()),
                    this.finishNode(n, "TypeCastExpression")
                  );
                }
                return e;
              },
            },
            {
              key: "assertModuleNodeAllowed",
              value: function (e) {
                ("ImportDeclaration" === e.type &&
                  ("type" === e.importKind || "typeof" === e.importKind)) ||
                  ("ExportNamedDeclaration" === e.type &&
                    "type" === e.exportKind) ||
                  ("ExportAllDeclaration" === e.type &&
                    "type" === e.exportKind) ||
                  Fe(N(r.prototype), "assertModuleNodeAllowed", this).call(
                    this,
                    e
                  );
              },
            },
            {
              key: "parseExport",
              value: function (e, t) {
                var n = Fe(N(r.prototype), "parseExport", this).call(
                  this,
                  e,
                  t
                );
                return (
                  ("ExportNamedDeclaration" !== n.type &&
                    "ExportAllDeclaration" !== n.type) ||
                    (n.exportKind = n.exportKind || "value"),
                  n
                );
              },
            },
            {
              key: "parseExportDeclaration",
              value: function (e) {
                if (this.isContextual(128)) {
                  e.exportKind = "type";
                  var t = this.startNode();
                  return (
                    this.next(),
                    this.match(5)
                      ? ((e.specifiers = this.parseExportSpecifiers(!0)),
                        Fe(N(r.prototype), "parseExportFrom", this).call(
                          this,
                          e
                        ),
                        null)
                      : this.flowParseTypeAlias(t)
                  );
                }
                if (this.isContextual(129)) {
                  e.exportKind = "type";
                  var n = this.startNode();
                  return this.next(), this.flowParseOpaqueType(n, !1);
                }
                if (this.isContextual(127)) {
                  e.exportKind = "type";
                  var i = this.startNode();
                  return this.next(), this.flowParseInterface(i);
                }
                if (this.shouldParseEnums() && this.isContextual(124)) {
                  e.exportKind = "value";
                  var a = this.startNode();
                  return this.next(), this.flowParseEnumDeclaration(a);
                }
                return Fe(N(r.prototype), "parseExportDeclaration", this).call(
                  this,
                  e
                );
              },
            },
            {
              key: "eatExportStar",
              value: function (e) {
                return (
                  !!Fe(N(r.prototype), "eatExportStar", this).call(this, e) ||
                  (!(!this.isContextual(128) || 55 !== this.lookahead().type) &&
                    ((e.exportKind = "type"), this.next(), this.next(), !0))
                );
              },
            },
            {
              key: "maybeParseExportNamespaceSpecifier",
              value: function (e) {
                var t = this.state.startLoc,
                  n = Fe(
                    N(r.prototype),
                    "maybeParseExportNamespaceSpecifier",
                    this
                  ).call(this, e);
                return n && "type" === e.exportKind && this.unexpected(t), n;
              },
            },
            {
              key: "parseClassId",
              value: function (e, t, n) {
                Fe(N(r.prototype), "parseClassId", this).call(this, e, t, n),
                  this.match(47) &&
                    (e.typeParameters =
                      this.flowParseTypeParameterDeclaration());
              },
            },
            {
              key: "parseClassMember",
              value: function (e, t, n) {
                var i = this.state.startLoc;
                if (this.isContextual(123)) {
                  if (
                    Fe(
                      N(r.prototype),
                      "parseClassMemberFromModifier",
                      this
                    ).call(this, e, t)
                  )
                    return;
                  t.declare = !0;
                }
                Fe(N(r.prototype), "parseClassMember", this).call(
                  this,
                  e,
                  t,
                  n
                ),
                  t.declare &&
                    ("ClassProperty" !== t.type &&
                    "ClassPrivateProperty" !== t.type &&
                    "PropertyDefinition" !== t.type
                      ? this.raise(vn.DeclareClassElement, { at: i })
                      : t.value &&
                        this.raise(vn.DeclareClassFieldInitializer, {
                          at: t.value,
                        }));
              },
            },
            {
              key: "isIterator",
              value: function (e) {
                return "iterator" === e || "asyncIterator" === e;
              },
            },
            {
              key: "readIterator",
              value: function () {
                var e = Fe(N(r.prototype), "readWord1", this).call(this),
                  t = "@@" + e;
                (this.isIterator(e) && this.state.inType) ||
                  this.raise(pt.InvalidIdentifier, {
                    at: this.state.curPosition(),
                    identifierName: t,
                  }),
                  this.finishToken(130, t);
              },
            },
            {
              key: "getTokenFromCode",
              value: function (e) {
                var t = this.input.charCodeAt(this.state.pos + 1);
                123 === e && 124 === t
                  ? this.finishOp(6, 2)
                  : !this.state.inType || (62 !== e && 60 !== e)
                  ? this.state.inType && 63 === e
                    ? 46 === t
                      ? this.finishOp(18, 2)
                      : this.finishOp(17, 1)
                    : !(function (e, t, r) {
                        return 64 === e && 64 === t && Zt(r);
                      })(e, t, this.input.charCodeAt(this.state.pos + 2))
                    ? Fe(N(r.prototype), "getTokenFromCode", this).call(this, e)
                    : ((this.state.pos += 2), this.readIterator())
                  : this.finishOp(62 === e ? 48 : 47, 1);
              },
            },
            {
              key: "isAssignable",
              value: function (e, t) {
                return "TypeCastExpression" === e.type
                  ? this.isAssignable(e.expression, t)
                  : Fe(N(r.prototype), "isAssignable", this).call(this, e, t);
              },
            },
            {
              key: "toAssignable",
              value: function (e) {
                var t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1];
                t ||
                  "AssignmentExpression" !== e.type ||
                  "TypeCastExpression" !== e.left.type ||
                  (e.left = this.typeCastToParameter(e.left)),
                  Fe(N(r.prototype), "toAssignable", this).call(this, e, t);
              },
            },
            {
              key: "toAssignableList",
              value: function (e, t, n) {
                for (var i = 0; i < e.length; i++) {
                  var a = e[i];
                  "TypeCastExpression" === (null == a ? void 0 : a.type) &&
                    (e[i] = this.typeCastToParameter(a));
                }
                Fe(N(r.prototype), "toAssignableList", this).call(
                  this,
                  e,
                  t,
                  n
                );
              },
            },
            {
              key: "toReferencedList",
              value: function (e, t) {
                for (var r = 0; r < e.length; r++) {
                  var n,
                    i = e[r];
                  !i ||
                    "TypeCastExpression" !== i.type ||
                    (null != (n = i.extra) && n.parenthesized) ||
                    (!(e.length > 1) && t) ||
                    this.raise(vn.TypeCastInPattern, { at: i.typeAnnotation });
                }
                return e;
              },
            },
            {
              key: "parseArrayLike",
              value: function (e, t, n, i) {
                var a = Fe(N(r.prototype), "parseArrayLike", this).call(
                  this,
                  e,
                  t,
                  n,
                  i
                );
                return (
                  t &&
                    !this.state.maybeInArrowParameters &&
                    this.toReferencedList(a.elements),
                  a
                );
              },
            },
            {
              key: "isValidLVal",
              value: function (e, t, n) {
                return (
                  "TypeCastExpression" === e ||
                  Fe(N(r.prototype), "isValidLVal", this).call(this, e, t, n)
                );
              },
            },
            {
              key: "parseClassProperty",
              value: function (e) {
                return (
                  this.match(14) &&
                    (e.typeAnnotation = this.flowParseTypeAnnotation()),
                  Fe(N(r.prototype), "parseClassProperty", this).call(this, e)
                );
              },
            },
            {
              key: "parseClassPrivateProperty",
              value: function (e) {
                return (
                  this.match(14) &&
                    (e.typeAnnotation = this.flowParseTypeAnnotation()),
                  Fe(N(r.prototype), "parseClassPrivateProperty", this).call(
                    this,
                    e
                  )
                );
              },
            },
            {
              key: "isClassMethod",
              value: function () {
                return (
                  this.match(47) ||
                  Fe(N(r.prototype), "isClassMethod", this).call(this)
                );
              },
            },
            {
              key: "isClassProperty",
              value: function () {
                return (
                  this.match(14) ||
                  Fe(N(r.prototype), "isClassProperty", this).call(this)
                );
              },
            },
            {
              key: "isNonstaticConstructor",
              value: function (e) {
                return (
                  !this.match(14) &&
                  Fe(N(r.prototype), "isNonstaticConstructor", this).call(
                    this,
                    e
                  )
                );
              },
            },
            {
              key: "pushClassMethod",
              value: function (e, t, n, i, a, s) {
                if (
                  (t.variance && this.unexpected(t.variance.loc.start),
                  delete t.variance,
                  this.match(47) &&
                    (t.typeParameters =
                      this.flowParseTypeParameterDeclaration()),
                  Fe(N(r.prototype), "pushClassMethod", this).call(
                    this,
                    e,
                    t,
                    n,
                    i,
                    a,
                    s
                  ),
                  t.params && a)
                ) {
                  var o = t.params;
                  o.length > 0 &&
                    this.isThisParam(o[0]) &&
                    this.raise(vn.ThisParamBannedInConstructor, { at: t });
                } else if (
                  "MethodDefinition" === t.type &&
                  a &&
                  t.value.params
                ) {
                  var l = t.value.params;
                  l.length > 0 &&
                    this.isThisParam(l[0]) &&
                    this.raise(vn.ThisParamBannedInConstructor, { at: t });
                }
              },
            },
            {
              key: "pushClassPrivateMethod",
              value: function (e, t, n, i) {
                t.variance && this.unexpected(t.variance.loc.start),
                  delete t.variance,
                  this.match(47) &&
                    (t.typeParameters =
                      this.flowParseTypeParameterDeclaration()),
                  Fe(N(r.prototype), "pushClassPrivateMethod", this).call(
                    this,
                    e,
                    t,
                    n,
                    i
                  );
              },
            },
            {
              key: "parseClassSuper",
              value: function (e) {
                if (
                  (Fe(N(r.prototype), "parseClassSuper", this).call(this, e),
                  e.superClass &&
                    this.match(47) &&
                    (e.superTypeParameters =
                      this.flowParseTypeParameterInstantiation()),
                  this.isContextual(111))
                ) {
                  this.next();
                  var t = (e.implements = []);
                  do {
                    var n = this.startNode();
                    (n.id = this.flowParseRestrictedIdentifier(!0)),
                      this.match(47)
                        ? (n.typeParameters =
                            this.flowParseTypeParameterInstantiation())
                        : (n.typeParameters = null),
                      t.push(this.finishNode(n, "ClassImplements"));
                  } while (this.eat(12));
                }
              },
            },
            {
              key: "checkGetterSetterParams",
              value: function (e) {
                Fe(N(r.prototype), "checkGetterSetterParams", this).call(
                  this,
                  e
                );
                var t = this.getObjectOrClassMethodParams(e);
                if (t.length > 0) {
                  var n = t[0];
                  this.isThisParam(n) && "get" === e.kind
                    ? this.raise(vn.GetterMayNotHaveThisParam, { at: n })
                    : this.isThisParam(n) &&
                      this.raise(vn.SetterMayNotHaveThisParam, { at: n });
                }
              },
            },
            {
              key: "parsePropertyNamePrefixOperator",
              value: function (e) {
                e.variance = this.flowParseVariance();
              },
            },
            {
              key: "parseObjPropValue",
              value: function (e, t, n, i, a, s, o) {
                var l;
                e.variance && this.unexpected(e.variance.loc.start),
                  delete e.variance,
                  this.match(47) &&
                    !s &&
                    ((l = this.flowParseTypeParameterDeclaration()),
                    this.match(10) || this.unexpected());
                var u = Fe(N(r.prototype), "parseObjPropValue", this).call(
                  this,
                  e,
                  t,
                  n,
                  i,
                  a,
                  s,
                  o
                );
                return l && ((u.value || u).typeParameters = l), u;
              },
            },
            {
              key: "parseAssignableListItemTypes",
              value: function (e) {
                return (
                  this.eat(17) &&
                    ("Identifier" !== e.type &&
                      this.raise(vn.PatternIsOptional, { at: e }),
                    this.isThisParam(e) &&
                      this.raise(vn.ThisParamMayNotBeOptional, { at: e }),
                    (e.optional = !0)),
                  this.match(14)
                    ? (e.typeAnnotation = this.flowParseTypeAnnotation())
                    : this.isThisParam(e) &&
                      this.raise(vn.ThisParamAnnotationRequired, { at: e }),
                  this.match(29) &&
                    this.isThisParam(e) &&
                    this.raise(vn.ThisParamNoDefault, { at: e }),
                  this.resetEndLocation(e),
                  e
                );
              },
            },
            {
              key: "parseMaybeDefault",
              value: function (e, t) {
                var n = Fe(N(r.prototype), "parseMaybeDefault", this).call(
                  this,
                  e,
                  t
                );
                return (
                  "AssignmentPattern" === n.type &&
                    n.typeAnnotation &&
                    n.right.start < n.typeAnnotation.start &&
                    this.raise(vn.TypeBeforeInitializer, {
                      at: n.typeAnnotation,
                    }),
                  n
                );
              },
            },
            {
              key: "shouldParseDefaultImport",
              value: function (e) {
                return gn(e)
                  ? bn(this.state.type)
                  : Fe(N(r.prototype), "shouldParseDefaultImport", this).call(
                      this,
                      e
                    );
              },
            },
            {
              key: "checkImportReflection",
              value: function (e) {
                Fe(N(r.prototype), "checkImportReflection", this).call(this, e),
                  e.module &&
                    "value" !== e.importKind &&
                    this.raise(vn.ImportReflectionHasImportType, {
                      at: e.specifiers[0].loc.start,
                    });
              },
            },
            {
              key: "parseImportSpecifierLocal",
              value: function (e, t, r) {
                (t.local = gn(e)
                  ? this.flowParseRestrictedIdentifier(!0, !0)
                  : this.parseIdentifier()),
                  e.specifiers.push(this.finishImportSpecifier(t, r));
              },
            },
            {
              key: "maybeParseDefaultImportSpecifier",
              value: function (e) {
                e.importKind = "value";
                var t = null;
                if (
                  (this.match(87)
                    ? (t = "typeof")
                    : this.isContextual(128) && (t = "type"),
                  t)
                ) {
                  var n = this.lookahead(),
                    i = n.type;
                  "type" === t && 55 === i && this.unexpected(null, n.type),
                    (bn(i) || 5 === i || 55 === i) &&
                      (this.next(), (e.importKind = t));
                }
                return Fe(
                  N(r.prototype),
                  "maybeParseDefaultImportSpecifier",
                  this
                ).call(this, e);
              },
            },
            {
              key: "parseImportSpecifier",
              value: function (e, t, r, n, i) {
                var a = e.imported,
                  s = null;
                "Identifier" === a.type &&
                  ("type" === a.name
                    ? (s = "type")
                    : "typeof" === a.name && (s = "typeof"));
                var o = !1;
                if (
                  this.isContextual(93) &&
                  !this.isLookaheadContextual("as")
                ) {
                  var l = this.parseIdentifier(!0);
                  null === s || Ft(this.state.type)
                    ? ((e.imported = a),
                      (e.importKind = null),
                      (e.local = this.parseIdentifier()))
                    : ((e.imported = l), (e.importKind = s), (e.local = dn(l)));
                } else {
                  if (null !== s && Ft(this.state.type))
                    (e.imported = this.parseIdentifier(!0)), (e.importKind = s);
                  else {
                    if (t)
                      throw this.raise(pt.ImportBindingIsString, {
                        at: e,
                        importName: a.value,
                      });
                    (e.imported = a), (e.importKind = null);
                  }
                  this.eatContextual(93)
                    ? (e.local = this.parseIdentifier())
                    : ((o = !0), (e.local = dn(e.imported)));
                }
                var u = gn(e);
                return (
                  r &&
                    u &&
                    this.raise(vn.ImportTypeShorthandOnlyInPureImport, {
                      at: e,
                    }),
                  (r || u) &&
                    this.checkReservedType(e.local.name, e.local.loc.start, !0),
                  !o ||
                    r ||
                    u ||
                    this.checkReservedWord(e.local.name, e.loc.start, !0, !0),
                  this.finishImportSpecifier(e, "ImportSpecifier")
                );
              },
            },
            {
              key: "parseBindingAtom",
              value: function () {
                return 78 === this.state.type
                  ? this.parseIdentifier(!0)
                  : Fe(N(r.prototype), "parseBindingAtom", this).call(this);
              },
            },
            {
              key: "parseFunctionParams",
              value: function (e, t) {
                var n = e.kind;
                "get" !== n &&
                  "set" !== n &&
                  this.match(47) &&
                  (e.typeParameters = this.flowParseTypeParameterDeclaration()),
                  Fe(N(r.prototype), "parseFunctionParams", this).call(
                    this,
                    e,
                    t
                  );
              },
            },
            {
              key: "parseVarId",
              value: function (e, t) {
                Fe(N(r.prototype), "parseVarId", this).call(this, e, t),
                  this.match(14) &&
                    ((e.id.typeAnnotation = this.flowParseTypeAnnotation()),
                    this.resetEndLocation(e.id));
              },
            },
            {
              key: "parseAsyncArrowFromCallExpression",
              value: function (e, t) {
                if (this.match(14)) {
                  var n = this.state.noAnonFunctionType;
                  (this.state.noAnonFunctionType = !0),
                    (e.returnType = this.flowParseTypeAnnotation()),
                    (this.state.noAnonFunctionType = n);
                }
                return Fe(
                  N(r.prototype),
                  "parseAsyncArrowFromCallExpression",
                  this
                ).call(this, e, t);
              },
            },
            {
              key: "shouldParseAsyncArrow",
              value: function () {
                return (
                  this.match(14) ||
                  Fe(N(r.prototype), "shouldParseAsyncArrow", this).call(this)
                );
              },
            },
            {
              key: "parseMaybeAssign",
              value: function (e, t) {
                var n,
                  i,
                  a = this,
                  s = null;
                if (
                  this.hasPlugin("jsx") &&
                  (this.match(140) || this.match(47))
                ) {
                  if (
                    ((s = this.state.clone()),
                    !(i = this.tryParse(function () {
                      return Fe(N(r.prototype), "parseMaybeAssign", a).call(
                        a,
                        e,
                        t
                      );
                    }, s)).error)
                  )
                    return i.node;
                  var o = this.state.context,
                    l = o[o.length - 1];
                  (l !== mt.j_oTag && l !== mt.j_expr) || o.pop();
                }
                if ((null != (n = i) && n.error) || this.match(47)) {
                  var u, c, p;
                  s = s || this.state.clone();
                  var h = this.tryParse(function (n) {
                      var i;
                      p = a.flowParseTypeParameterDeclaration();
                      var s = a.forwardNoArrowParamsConversionAt(
                        p,
                        function () {
                          var n = Fe(
                            N(r.prototype),
                            "parseMaybeAssign",
                            a
                          ).call(a, e, t);
                          return a.resetStartLocationFromNode(n, p), n;
                        }
                      );
                      null != (i = s.extra) && i.parenthesized && n();
                      var o = a.maybeUnwrapTypeCastExpression(s);
                      return (
                        "ArrowFunctionExpression" !== o.type && n(),
                        (o.typeParameters = p),
                        a.resetStartLocationFromNode(o, p),
                        s
                      );
                    }, s),
                    d = null;
                  if (
                    h.node &&
                    "ArrowFunctionExpression" ===
                      this.maybeUnwrapTypeCastExpression(h.node).type
                  ) {
                    if (!h.error && !h.aborted)
                      return (
                        h.node.async &&
                          this.raise(
                            vn.UnexpectedTypeParameterBeforeAsyncArrowFunction,
                            { at: p }
                          ),
                        h.node
                      );
                    d = h.node;
                  }
                  if (null != (u = i) && u.node)
                    return (this.state = i.failState), i.node;
                  if (d) return (this.state = h.failState), d;
                  if (null != (c = i) && c.thrown) throw i.error;
                  if (h.thrown) throw h.error;
                  throw this.raise(vn.UnexpectedTokenAfterTypeParameter, {
                    at: p,
                  });
                }
                return Fe(N(r.prototype), "parseMaybeAssign", this).call(
                  this,
                  e,
                  t
                );
              },
            },
            {
              key: "parseArrow",
              value: function (e) {
                var t = this;
                if (this.match(14)) {
                  var n = this.tryParse(function () {
                    var r = t.state.noAnonFunctionType;
                    t.state.noAnonFunctionType = !0;
                    var n = t.startNode(),
                      i = H(t.flowParseTypeAndPredicateInitialiser(), 2);
                    return (
                      (n.typeAnnotation = i[0]),
                      (e.predicate = i[1]),
                      (t.state.noAnonFunctionType = r),
                      t.canInsertSemicolon() && t.unexpected(),
                      t.match(19) || t.unexpected(),
                      n
                    );
                  });
                  if (n.thrown) return null;
                  n.error && (this.state = n.failState),
                    (e.returnType = n.node.typeAnnotation
                      ? this.finishNode(n.node, "TypeAnnotation")
                      : null);
                }
                return Fe(N(r.prototype), "parseArrow", this).call(this, e);
              },
            },
            {
              key: "shouldParseArrow",
              value: function (e) {
                return (
                  this.match(14) ||
                  Fe(N(r.prototype), "shouldParseArrow", this).call(this, e)
                );
              },
            },
            {
              key: "setArrowFunctionParameters",
              value: function (e, t) {
                -1 !== this.state.noArrowParamsConversionAt.indexOf(e.start)
                  ? (e.params = t)
                  : Fe(N(r.prototype), "setArrowFunctionParameters", this).call(
                      this,
                      e,
                      t
                    );
              },
            },
            {
              key: "checkParams",
              value: function (e, t, n) {
                var i =
                  !(arguments.length > 3 && void 0 !== arguments[3]) ||
                  arguments[3];
                if (
                  !n ||
                  -1 === this.state.noArrowParamsConversionAt.indexOf(e.start)
                ) {
                  for (var a = 0; a < e.params.length; a++)
                    this.isThisParam(e.params[a]) &&
                      a > 0 &&
                      this.raise(vn.ThisParamMustBeFirst, { at: e.params[a] });
                  Fe(N(r.prototype), "checkParams", this).call(
                    this,
                    e,
                    t,
                    n,
                    i
                  );
                }
              },
            },
            {
              key: "parseParenAndDistinguishExpression",
              value: function (e) {
                return Fe(
                  N(r.prototype),
                  "parseParenAndDistinguishExpression",
                  this
                ).call(
                  this,
                  e && -1 === this.state.noArrowAt.indexOf(this.state.start)
                );
              },
            },
            {
              key: "parseSubscripts",
              value: function (e, t, n) {
                var i = this;
                if (
                  "Identifier" === e.type &&
                  "async" === e.name &&
                  -1 !== this.state.noArrowAt.indexOf(t.index)
                ) {
                  this.next();
                  var a = this.startNodeAt(t);
                  (a.callee = e),
                    (a.arguments = Fe(
                      N(r.prototype),
                      "parseCallExpressionArguments",
                      this
                    ).call(this, 11, !1)),
                    (e = this.finishNode(a, "CallExpression"));
                } else if (
                  "Identifier" === e.type &&
                  "async" === e.name &&
                  this.match(47)
                ) {
                  var s = this.state.clone(),
                    o = this.tryParse(function (e) {
                      return i.parseAsyncArrowWithTypeParameters(t) || e();
                    }, s);
                  if (!o.error && !o.aborted) return o.node;
                  var l = this.tryParse(function () {
                    return Fe(N(r.prototype), "parseSubscripts", i).call(
                      i,
                      e,
                      t,
                      n
                    );
                  }, s);
                  if (l.node && !l.error) return l.node;
                  if (o.node) return (this.state = o.failState), o.node;
                  if (l.node) return (this.state = l.failState), l.node;
                  throw o.error || l.error;
                }
                return Fe(N(r.prototype), "parseSubscripts", this).call(
                  this,
                  e,
                  t,
                  n
                );
              },
            },
            {
              key: "parseSubscript",
              value: function (e, t, n, i) {
                var a = this;
                if (this.match(18) && this.isLookaheadToken_lt()) {
                  if (((i.optionalChainMember = !0), n))
                    return (i.stop = !0), e;
                  this.next();
                  var s = this.startNodeAt(t);
                  return (
                    (s.callee = e),
                    (s.typeArguments =
                      this.flowParseTypeParameterInstantiation()),
                    this.expect(10),
                    (s.arguments = this.parseCallExpressionArguments(11, !1)),
                    (s.optional = !0),
                    this.finishCallExpression(s, !0)
                  );
                }
                if (!n && this.shouldParseTypes() && this.match(47)) {
                  var o = this.startNodeAt(t);
                  o.callee = e;
                  var l = this.tryParse(function () {
                    return (
                      (o.typeArguments =
                        a.flowParseTypeParameterInstantiationCallOrNew()),
                      a.expect(10),
                      (o.arguments = Fe(
                        N(r.prototype),
                        "parseCallExpressionArguments",
                        a
                      ).call(a, 11, !1)),
                      i.optionalChainMember && (o.optional = !1),
                      a.finishCallExpression(o, i.optionalChainMember)
                    );
                  });
                  if (l.node)
                    return l.error && (this.state = l.failState), l.node;
                }
                return Fe(N(r.prototype), "parseSubscript", this).call(
                  this,
                  e,
                  t,
                  n,
                  i
                );
              },
            },
            {
              key: "parseNewCallee",
              value: function (e) {
                var t = this;
                Fe(N(r.prototype), "parseNewCallee", this).call(this, e);
                var n = null;
                this.shouldParseTypes() &&
                  this.match(47) &&
                  (n = this.tryParse(function () {
                    return t.flowParseTypeParameterInstantiationCallOrNew();
                  }).node),
                  (e.typeArguments = n);
              },
            },
            {
              key: "parseAsyncArrowWithTypeParameters",
              value: function (e) {
                var t = this.startNodeAt(e);
                if ((this.parseFunctionParams(t, !1), this.parseArrow(t)))
                  return Fe(N(r.prototype), "parseArrowExpression", this).call(
                    this,
                    t,
                    void 0,
                    !0
                  );
              },
            },
            {
              key: "readToken_mult_modulo",
              value: function (e) {
                var t = this.input.charCodeAt(this.state.pos + 1);
                if (42 === e && 47 === t && this.state.hasFlowComment)
                  return (
                    (this.state.hasFlowComment = !1),
                    (this.state.pos += 2),
                    void this.nextToken()
                  );
                Fe(N(r.prototype), "readToken_mult_modulo", this).call(this, e);
              },
            },
            {
              key: "readToken_pipe_amp",
              value: function (e) {
                var t = this.input.charCodeAt(this.state.pos + 1);
                124 !== e || 125 !== t
                  ? Fe(N(r.prototype), "readToken_pipe_amp", this).call(this, e)
                  : this.finishOp(9, 2);
              },
            },
            {
              key: "parseTopLevel",
              value: function (e, t) {
                var n = Fe(N(r.prototype), "parseTopLevel", this).call(
                  this,
                  e,
                  t
                );
                return (
                  this.state.hasFlowComment &&
                    this.raise(vn.UnterminatedFlowComment, {
                      at: this.state.curPosition(),
                    }),
                  n
                );
              },
            },
            {
              key: "skipBlockComment",
              value: function () {
                if (!this.hasPlugin("flowComments") || !this.skipFlowComment())
                  return Fe(N(r.prototype), "skipBlockComment", this).call(
                    this,
                    this.state.hasFlowComment ? "*-/" : "*/"
                  );
                if (this.state.hasFlowComment)
                  throw this.raise(vn.NestedFlowComment, {
                    at: this.state.startLoc,
                  });
                this.hasFlowCommentCompletion();
                var e = this.skipFlowComment();
                e && ((this.state.pos += e), (this.state.hasFlowComment = !0));
              },
            },
            {
              key: "skipFlowComment",
              value: function () {
                for (
                  var e = this.state.pos, t = 2;
                  [32, 9].includes(this.input.charCodeAt(e + t));

                )
                  t++;
                var r = this.input.charCodeAt(t + e),
                  n = this.input.charCodeAt(t + e + 1);
                return 58 === r && 58 === n
                  ? t + 2
                  : "flow-include" === this.input.slice(t + e, t + e + 12)
                  ? t + 12
                  : 58 === r && 58 !== n && t;
              },
            },
            {
              key: "hasFlowCommentCompletion",
              value: function () {
                if (-1 === this.input.indexOf("*/", this.state.pos))
                  throw this.raise(pt.UnterminatedComment, {
                    at: this.state.curPosition(),
                  });
              },
            },
            {
              key: "flowEnumErrorBooleanMemberNotInitialized",
              value: function (e, t) {
                var r = t.enumName,
                  n = t.memberName;
                this.raise(vn.EnumBooleanMemberNotInitialized, {
                  at: e,
                  memberName: n,
                  enumName: r,
                });
              },
            },
            {
              key: "flowEnumErrorInvalidMemberInitializer",
              value: function (e, t) {
                return this.raise(
                  t.explicitType
                    ? "symbol" === t.explicitType
                      ? vn.EnumInvalidMemberInitializerSymbolType
                      : vn.EnumInvalidMemberInitializerPrimaryType
                    : vn.EnumInvalidMemberInitializerUnknownType,
                  Object.assign({ at: e }, t)
                );
              },
            },
            {
              key: "flowEnumErrorNumberMemberNotInitialized",
              value: function (e, t) {
                var r = t.enumName,
                  n = t.memberName;
                this.raise(vn.EnumNumberMemberNotInitialized, {
                  at: e,
                  enumName: r,
                  memberName: n,
                });
              },
            },
            {
              key: "flowEnumErrorStringMemberInconsistentlyInitailized",
              value: function (e, t) {
                var r = t.enumName;
                this.raise(vn.EnumStringMemberInconsistentlyInitailized, {
                  at: e,
                  enumName: r,
                });
              },
            },
            {
              key: "flowEnumMemberInit",
              value: function () {
                var e = this,
                  t = this.state.startLoc,
                  r = function () {
                    return e.match(12) || e.match(8);
                  };
                switch (this.state.type) {
                  case 132:
                    var n = this.parseNumericLiteral(this.state.value);
                    return r()
                      ? { type: "number", loc: n.loc.start, value: n }
                      : { type: "invalid", loc: t };
                  case 131:
                    var i = this.parseStringLiteral(this.state.value);
                    return r()
                      ? { type: "string", loc: i.loc.start, value: i }
                      : { type: "invalid", loc: t };
                  case 85:
                  case 86:
                    var a = this.parseBooleanLiteral(this.match(85));
                    return r()
                      ? { type: "boolean", loc: a.loc.start, value: a }
                      : { type: "invalid", loc: t };
                  default:
                    return { type: "invalid", loc: t };
                }
              },
            },
            {
              key: "flowEnumMemberRaw",
              value: function () {
                var e = this.state.startLoc;
                return {
                  id: this.parseIdentifier(!0),
                  init: this.eat(29)
                    ? this.flowEnumMemberInit()
                    : { type: "none", loc: e },
                };
              },
            },
            {
              key: "flowEnumCheckExplicitTypeMismatch",
              value: function (e, t, r) {
                var n = t.explicitType;
                null !== n &&
                  n !== r &&
                  this.flowEnumErrorInvalidMemberInitializer(e, t);
              },
            },
            {
              key: "flowEnumMembers",
              value: function (e) {
                for (
                  var t = e.enumName,
                    r = e.explicitType,
                    n = new Set(),
                    i = {
                      booleanMembers: [],
                      numberMembers: [],
                      stringMembers: [],
                      defaultedMembers: [],
                    },
                    a = !1;
                  !this.match(8);

                ) {
                  if (this.eat(21)) {
                    a = !0;
                    break;
                  }
                  var s = this.startNode(),
                    o = this.flowEnumMemberRaw(),
                    l = o.id,
                    u = o.init,
                    c = l.name;
                  if ("" !== c) {
                    /^[a-z]/.test(c) &&
                      this.raise(vn.EnumInvalidMemberName, {
                        at: l,
                        memberName: c,
                        suggestion: c[0].toUpperCase() + c.slice(1),
                        enumName: t,
                      }),
                      n.has(c) &&
                        this.raise(vn.EnumDuplicateMemberName, {
                          at: l,
                          memberName: c,
                          enumName: t,
                        }),
                      n.add(c);
                    var p = { enumName: t, explicitType: r, memberName: c };
                    switch (((s.id = l), u.type)) {
                      case "boolean":
                        this.flowEnumCheckExplicitTypeMismatch(
                          u.loc,
                          p,
                          "boolean"
                        ),
                          (s.init = u.value),
                          i.booleanMembers.push(
                            this.finishNode(s, "EnumBooleanMember")
                          );
                        break;
                      case "number":
                        this.flowEnumCheckExplicitTypeMismatch(
                          u.loc,
                          p,
                          "number"
                        ),
                          (s.init = u.value),
                          i.numberMembers.push(
                            this.finishNode(s, "EnumNumberMember")
                          );
                        break;
                      case "string":
                        this.flowEnumCheckExplicitTypeMismatch(
                          u.loc,
                          p,
                          "string"
                        ),
                          (s.init = u.value),
                          i.stringMembers.push(
                            this.finishNode(s, "EnumStringMember")
                          );
                        break;
                      case "invalid":
                        throw this.flowEnumErrorInvalidMemberInitializer(
                          u.loc,
                          p
                        );
                      case "none":
                        switch (r) {
                          case "boolean":
                            this.flowEnumErrorBooleanMemberNotInitialized(
                              u.loc,
                              p
                            );
                            break;
                          case "number":
                            this.flowEnumErrorNumberMemberNotInitialized(
                              u.loc,
                              p
                            );
                            break;
                          default:
                            i.defaultedMembers.push(
                              this.finishNode(s, "EnumDefaultedMember")
                            );
                        }
                    }
                    this.match(8) || this.expect(12);
                  }
                }
                return { members: i, hasUnknownMembers: a };
              },
            },
            {
              key: "flowEnumStringMembers",
              value: function (e, t, r) {
                var n = r.enumName;
                if (0 === e.length) return t;
                if (0 === t.length) return e;
                if (t.length > e.length) {
                  var i,
                    a = He(e);
                  try {
                    for (a.s(); !(i = a.n()).done; ) {
                      var s = i.value;
                      this.flowEnumErrorStringMemberInconsistentlyInitailized(
                        s,
                        { enumName: n }
                      );
                    }
                  } catch (e) {
                    a.e(e);
                  } finally {
                    a.f();
                  }
                  return t;
                }
                var o,
                  l = He(t);
                try {
                  for (l.s(); !(o = l.n()).done; ) {
                    var u = o.value;
                    this.flowEnumErrorStringMemberInconsistentlyInitailized(u, {
                      enumName: n,
                    });
                  }
                } catch (e) {
                  l.e(e);
                } finally {
                  l.f();
                }
                return e;
              },
            },
            {
              key: "flowEnumParseExplicitType",
              value: function (e) {
                var t = e.enumName;
                if (!this.eatContextual(101)) return null;
                if (!jt(this.state.type))
                  throw this.raise(vn.EnumInvalidExplicitTypeUnknownSupplied, {
                    at: this.state.startLoc,
                    enumName: t,
                  });
                var r = this.state.value;
                return (
                  this.next(),
                  "boolean" !== r &&
                    "number" !== r &&
                    "string" !== r &&
                    "symbol" !== r &&
                    this.raise(vn.EnumInvalidExplicitType, {
                      at: this.state.startLoc,
                      enumName: t,
                      invalidEnumType: r,
                    }),
                  r
                );
              },
            },
            {
              key: "flowEnumBody",
              value: function (e, t) {
                var r = this,
                  n = t.name,
                  i = t.loc.start,
                  a = this.flowEnumParseExplicitType({ enumName: n });
                this.expect(5);
                var s = this.flowEnumMembers({ enumName: n, explicitType: a }),
                  o = s.members,
                  l = s.hasUnknownMembers;
                switch (((e.hasUnknownMembers = l), a)) {
                  case "boolean":
                    return (
                      (e.explicitType = !0),
                      (e.members = o.booleanMembers),
                      this.expect(8),
                      this.finishNode(e, "EnumBooleanBody")
                    );
                  case "number":
                    return (
                      (e.explicitType = !0),
                      (e.members = o.numberMembers),
                      this.expect(8),
                      this.finishNode(e, "EnumNumberBody")
                    );
                  case "string":
                    return (
                      (e.explicitType = !0),
                      (e.members = this.flowEnumStringMembers(
                        o.stringMembers,
                        o.defaultedMembers,
                        { enumName: n }
                      )),
                      this.expect(8),
                      this.finishNode(e, "EnumStringBody")
                    );
                  case "symbol":
                    return (
                      (e.members = o.defaultedMembers),
                      this.expect(8),
                      this.finishNode(e, "EnumSymbolBody")
                    );
                  default:
                    var u = function () {
                      return (
                        (e.members = []),
                        r.expect(8),
                        r.finishNode(e, "EnumStringBody")
                      );
                    };
                    e.explicitType = !1;
                    var c = o.booleanMembers.length,
                      p = o.numberMembers.length,
                      h = o.stringMembers.length,
                      d = o.defaultedMembers.length;
                    if (c || p || h || d) {
                      if (c || p) {
                        if (!p && !h && c >= d) {
                          var f,
                            y = He(o.defaultedMembers);
                          try {
                            for (y.s(); !(f = y.n()).done; ) {
                              var m = f.value;
                              this.flowEnumErrorBooleanMemberNotInitialized(
                                m.loc.start,
                                { enumName: n, memberName: m.id.name }
                              );
                            }
                          } catch (e) {
                            y.e(e);
                          } finally {
                            y.f();
                          }
                          return (
                            (e.members = o.booleanMembers),
                            this.expect(8),
                            this.finishNode(e, "EnumBooleanBody")
                          );
                        }
                        if (!c && !h && p >= d) {
                          var v,
                            g = He(o.defaultedMembers);
                          try {
                            for (g.s(); !(v = g.n()).done; ) {
                              var b = v.value;
                              this.flowEnumErrorNumberMemberNotInitialized(
                                b.loc.start,
                                { enumName: n, memberName: b.id.name }
                              );
                            }
                          } catch (e) {
                            g.e(e);
                          } finally {
                            g.f();
                          }
                          return (
                            (e.members = o.numberMembers),
                            this.expect(8),
                            this.finishNode(e, "EnumNumberBody")
                          );
                        }
                        return (
                          this.raise(vn.EnumInconsistentMemberValues, {
                            at: i,
                            enumName: n,
                          }),
                          u()
                        );
                      }
                      return (
                        (e.members = this.flowEnumStringMembers(
                          o.stringMembers,
                          o.defaultedMembers,
                          { enumName: n }
                        )),
                        this.expect(8),
                        this.finishNode(e, "EnumStringBody")
                      );
                    }
                    return u();
                }
              },
            },
            {
              key: "flowParseEnumDeclaration",
              value: function (e) {
                var t = this.parseIdentifier();
                return (
                  (e.id = t),
                  (e.body = this.flowEnumBody(this.startNode(), t)),
                  this.finishNode(e, "EnumDeclaration")
                );
              },
            },
            {
              key: "isLookaheadToken_lt",
              value: function () {
                var e = this.nextTokenStart();
                if (60 === this.input.charCodeAt(e)) {
                  var t = this.input.charCodeAt(e + 1);
                  return 60 !== t && 61 !== t;
                }
                return !1;
              },
            },
            {
              key: "maybeUnwrapTypeCastExpression",
              value: function (e) {
                return "TypeCastExpression" === e.type ? e.expression : e;
              },
            },
          ]),
          r
        );
      })(e);
    },
    typescript: function (e) {
      return (function (e) {
        I(r, e);
        var t = Je(r);
        function r() {
          var e;
          E(this, r);
          for (var n = arguments.length, i = new Array(n), a = 0; a < n; a++)
            i[a] = arguments[a];
          return (
            ((e = t.call.apply(t, [this].concat(i))).tsParseInOutModifiers =
              e.tsParseModifiers.bind(w(e), {
                allowedModifiers: ["in", "out"],
                disallowedModifiers: [
                  "const",
                  "public",
                  "private",
                  "protected",
                  "readonly",
                  "declare",
                  "abstract",
                  "override",
                ],
                errorTemplate: Nn.InvalidModifierOnTypeParameter,
              })),
            (e.tsParseConstModifier = e.tsParseModifiers.bind(w(e), {
              allowedModifiers: ["const"],
              disallowedModifiers: ["in", "out"],
              errorTemplate: Nn.InvalidModifierOnTypeParameterPositions,
            })),
            (e.tsParseInOutConstModifiers = e.tsParseModifiers.bind(w(e), {
              allowedModifiers: ["in", "out", "const"],
              disallowedModifiers: [
                "public",
                "private",
                "protected",
                "readonly",
                "declare",
                "abstract",
                "override",
              ],
              errorTemplate: Nn.InvalidModifierOnTypeParameter,
            })),
            e
          );
        }
        return (
          A(r, [
            {
              key: "getScopeHandler",
              value: function () {
                return wn;
              },
            },
            {
              key: "tsIsIdentifier",
              value: function () {
                return jt(this.state.type);
              },
            },
            {
              key: "tsTokenCanFollowModifier",
              value: function () {
                return (
                  (this.match(0) ||
                    this.match(5) ||
                    this.match(55) ||
                    this.match(21) ||
                    this.match(136) ||
                    this.isLiteralPropertyName()) &&
                  !this.hasPrecedingLineBreak()
                );
              },
            },
            {
              key: "tsNextTokenCanFollowModifier",
              value: function () {
                return this.next(), this.tsTokenCanFollowModifier();
              },
            },
            {
              key: "tsParseModifier",
              value: function (e, t) {
                if (
                  jt(this.state.type) ||
                  58 === this.state.type ||
                  75 === this.state.type
                ) {
                  var r = this.state.value;
                  if (-1 !== e.indexOf(r)) {
                    if (t && this.tsIsStartOfStaticBlocks()) return;
                    if (
                      this.tsTryParse(
                        this.tsNextTokenCanFollowModifier.bind(this)
                      )
                    )
                      return r;
                  }
                }
              },
            },
            {
              key: "tsParseModifiers",
              value: function (e, t) {
                for (
                  var r = this,
                    n = e.allowedModifiers,
                    i = e.disallowedModifiers,
                    a = e.stopOnStartOfClassStaticBlock,
                    s = e.errorTemplate,
                    o = void 0 === s ? Nn.InvalidModifierOnTypeMember : s,
                    l = function (e, n, i, a) {
                      n === i &&
                        t[a] &&
                        r.raise(Nn.InvalidModifiersOrder, {
                          at: e,
                          orderedModifiers: [i, a],
                        });
                    },
                    u = function (e, n, i, a) {
                      ((t[i] && n === a) || (t[a] && n === i)) &&
                        r.raise(Nn.IncompatibleModifiers, {
                          at: e,
                          modifiers: [i, a],
                        });
                    };
                  ;

                ) {
                  var c = this.state.startLoc,
                    p = this.tsParseModifier(n.concat(null != i ? i : []), a);
                  if (!p) break;
                  _n(p)
                    ? t.accessibility
                      ? this.raise(Nn.DuplicateAccessibilityModifier, {
                          at: c,
                          modifier: p,
                        })
                      : (l(c, p, p, "override"),
                        l(c, p, p, "static"),
                        l(c, p, p, "readonly"),
                        (t.accessibility = p))
                    : Dn(p)
                    ? (t[p] &&
                        this.raise(Nn.DuplicateModifier, {
                          at: c,
                          modifier: p,
                        }),
                      (t[p] = !0),
                      l(c, p, "in", "out"))
                    : (Object.hasOwnProperty.call(t, p)
                        ? this.raise(Nn.DuplicateModifier, {
                            at: c,
                            modifier: p,
                          })
                        : (l(c, p, "static", "readonly"),
                          l(c, p, "static", "override"),
                          l(c, p, "override", "readonly"),
                          l(c, p, "abstract", "override"),
                          u(c, p, "declare", "override"),
                          u(c, p, "static", "abstract")),
                      (t[p] = !0)),
                    null != i &&
                      i.includes(p) &&
                      this.raise(o, { at: c, modifier: p });
                }
              },
            },
            {
              key: "tsIsListTerminator",
              value: function (e) {
                switch (e) {
                  case "EnumMembers":
                  case "TypeMembers":
                    return this.match(8);
                  case "HeritageClauseElement":
                    return this.match(5);
                  case "TupleElementTypes":
                    return this.match(3);
                  case "TypeParametersOrArguments":
                    return this.match(48);
                }
              },
            },
            {
              key: "tsParseList",
              value: function (e, t) {
                for (var r = []; !this.tsIsListTerminator(e); ) r.push(t());
                return r;
              },
            },
            {
              key: "tsParseDelimitedList",
              value: function (e, t, r) {
                return (function (e) {
                  if (null == e)
                    throw new Error("Unexpected ".concat(e, " value."));
                  return e;
                })(this.tsParseDelimitedListWorker(e, t, !0, r));
              },
            },
            {
              key: "tsParseDelimitedListWorker",
              value: function (e, t, r, n) {
                for (var i = [], a = -1; !this.tsIsListTerminator(e); ) {
                  a = -1;
                  var s = t();
                  if (null == s) return;
                  if ((i.push(s), !this.eat(12))) {
                    if (this.tsIsListTerminator(e)) break;
                    return void (r && this.expect(12));
                  }
                  a = this.state.lastTokStart;
                }
                return n && (n.value = a), i;
              },
            },
            {
              key: "tsParseBracketedList",
              value: function (e, t, r, n, i) {
                n || (r ? this.expect(0) : this.expect(47));
                var a = this.tsParseDelimitedList(e, t, i);
                return r ? this.expect(3) : this.expect(48), a;
              },
            },
            {
              key: "tsParseImportType",
              value: function () {
                var e = this.startNode();
                return (
                  this.expect(83),
                  this.expect(10),
                  this.match(131) ||
                    this.raise(Nn.UnsupportedImportTypeArgument, {
                      at: this.state.startLoc,
                    }),
                  (e.argument = Fe(N(r.prototype), "parseExprAtom", this).call(
                    this
                  )),
                  this.expect(11),
                  this.eat(16) && (e.qualifier = this.tsParseEntityName()),
                  this.match(47) &&
                    (e.typeParameters = this.tsParseTypeArguments()),
                  this.finishNode(e, "TSImportType")
                );
              },
            },
            {
              key: "tsParseEntityName",
              value: function () {
                for (
                  var e =
                      !(arguments.length > 0 && void 0 !== arguments[0]) ||
                      arguments[0],
                    t = this.parseIdentifier(e);
                  this.eat(16);

                ) {
                  var r = this.startNodeAtNode(t);
                  (r.left = t),
                    (r.right = this.parseIdentifier(e)),
                    (t = this.finishNode(r, "TSQualifiedName"));
                }
                return t;
              },
            },
            {
              key: "tsParseTypeReference",
              value: function () {
                var e = this.startNode();
                return (
                  (e.typeName = this.tsParseEntityName()),
                  !this.hasPrecedingLineBreak() &&
                    this.match(47) &&
                    (e.typeParameters = this.tsParseTypeArguments()),
                  this.finishNode(e, "TSTypeReference")
                );
              },
            },
            {
              key: "tsParseThisTypePredicate",
              value: function (e) {
                this.next();
                var t = this.startNodeAtNode(e);
                return (
                  (t.parameterName = e),
                  (t.typeAnnotation = this.tsParseTypeAnnotation(!1)),
                  (t.asserts = !1),
                  this.finishNode(t, "TSTypePredicate")
                );
              },
            },
            {
              key: "tsParseThisTypeNode",
              value: function () {
                var e = this.startNode();
                return this.next(), this.finishNode(e, "TSThisType");
              },
            },
            {
              key: "tsParseTypeQuery",
              value: function () {
                var e = this.startNode();
                return (
                  this.expect(87),
                  this.match(83)
                    ? (e.exprName = this.tsParseImportType())
                    : (e.exprName = this.tsParseEntityName()),
                  !this.hasPrecedingLineBreak() &&
                    this.match(47) &&
                    (e.typeParameters = this.tsParseTypeArguments()),
                  this.finishNode(e, "TSTypeQuery")
                );
              },
            },
            {
              key: "tsParseTypeParameter",
              value: function (e) {
                var t = this.startNode();
                return (
                  e(t),
                  (t.name = this.tsParseTypeParameterName()),
                  (t.constraint = this.tsEatThenParseType(81)),
                  (t.default = this.tsEatThenParseType(29)),
                  this.finishNode(t, "TSTypeParameter")
                );
              },
            },
            {
              key: "tsTryParseTypeParameters",
              value: function (e) {
                if (this.match(47)) return this.tsParseTypeParameters(e);
              },
            },
            {
              key: "tsParseTypeParameters",
              value: function (e) {
                var t = this.startNode();
                this.match(47) || this.match(140)
                  ? this.next()
                  : this.unexpected();
                var r = { value: -1 };
                return (
                  (t.params = this.tsParseBracketedList(
                    "TypeParametersOrArguments",
                    this.tsParseTypeParameter.bind(this, e),
                    !1,
                    !0,
                    r
                  )),
                  0 === t.params.length &&
                    this.raise(Nn.EmptyTypeParameters, { at: t }),
                  -1 !== r.value && this.addExtra(t, "trailingComma", r.value),
                  this.finishNode(t, "TSTypeParameterDeclaration")
                );
              },
            },
            {
              key: "tsFillSignature",
              value: function (e, t) {
                var r = 19 === e,
                  n = "typeAnnotation";
                (t.typeParameters = this.tsTryParseTypeParameters(
                  this.tsParseConstModifier
                )),
                  this.expect(10),
                  (t.parameters = this.tsParseBindingListForSignature()),
                  (r || this.match(e)) &&
                    (t[n] = this.tsParseTypeOrTypePredicateAnnotation(e));
              },
            },
            {
              key: "tsParseBindingListForSignature",
              value: function () {
                var e,
                  t = Fe(N(r.prototype), "parseBindingList", this).call(
                    this,
                    11,
                    41,
                    2
                  ),
                  n = He(t);
                try {
                  for (n.s(); !(e = n.n()).done; ) {
                    var i = e.value,
                      a = i.type;
                    ("AssignmentPattern" !== a &&
                      "TSParameterProperty" !== a) ||
                      this.raise(Nn.UnsupportedSignatureParameterKind, {
                        at: i,
                        type: a,
                      });
                  }
                } catch (e) {
                  n.e(e);
                } finally {
                  n.f();
                }
                return t;
              },
            },
            {
              key: "tsParseTypeMemberSemicolon",
              value: function () {
                this.eat(12) || this.isLineTerminator() || this.expect(13);
              },
            },
            {
              key: "tsParseSignatureMember",
              value: function (e, t) {
                return (
                  this.tsFillSignature(14, t),
                  this.tsParseTypeMemberSemicolon(),
                  this.finishNode(t, e)
                );
              },
            },
            {
              key: "tsIsUnambiguouslyIndexSignature",
              value: function () {
                return (
                  this.next(),
                  !!jt(this.state.type) && (this.next(), this.match(14))
                );
              },
            },
            {
              key: "tsTryParseIndexSignature",
              value: function (e) {
                if (
                  this.match(0) &&
                  this.tsLookAhead(
                    this.tsIsUnambiguouslyIndexSignature.bind(this)
                  )
                ) {
                  this.expect(0);
                  var t = this.parseIdentifier();
                  (t.typeAnnotation = this.tsParseTypeAnnotation()),
                    this.resetEndLocation(t),
                    this.expect(3),
                    (e.parameters = [t]);
                  var r = this.tsTryParseTypeAnnotation();
                  return (
                    r && (e.typeAnnotation = r),
                    this.tsParseTypeMemberSemicolon(),
                    this.finishNode(e, "TSIndexSignature")
                  );
                }
              },
            },
            {
              key: "tsParsePropertyOrMethodSignature",
              value: function (e, t) {
                this.eat(17) && (e.optional = !0);
                var r = e;
                if (this.match(10) || this.match(47)) {
                  t && this.raise(Nn.ReadonlyForMethodSignature, { at: e });
                  var n = r;
                  n.kind &&
                    this.match(47) &&
                    this.raise(Nn.AccesorCannotHaveTypeParameters, {
                      at: this.state.curPosition(),
                    }),
                    this.tsFillSignature(14, n),
                    this.tsParseTypeMemberSemicolon();
                  var i = "parameters",
                    a = "typeAnnotation";
                  if ("get" === n.kind)
                    n[i].length > 0 &&
                      (this.raise(pt.BadGetterArity, {
                        at: this.state.curPosition(),
                      }),
                      this.isThisParam(n[i][0]) &&
                        this.raise(Nn.AccesorCannotDeclareThisParameter, {
                          at: this.state.curPosition(),
                        }));
                  else if ("set" === n.kind) {
                    if (1 !== n[i].length)
                      this.raise(pt.BadSetterArity, {
                        at: this.state.curPosition(),
                      });
                    else {
                      var s = n[i][0];
                      this.isThisParam(s) &&
                        this.raise(Nn.AccesorCannotDeclareThisParameter, {
                          at: this.state.curPosition(),
                        }),
                        "Identifier" === s.type &&
                          s.optional &&
                          this.raise(Nn.SetAccesorCannotHaveOptionalParameter, {
                            at: this.state.curPosition(),
                          }),
                        "RestElement" === s.type &&
                          this.raise(Nn.SetAccesorCannotHaveRestParameter, {
                            at: this.state.curPosition(),
                          });
                    }
                    n[a] &&
                      this.raise(Nn.SetAccesorCannotHaveReturnType, {
                        at: n[a],
                      });
                  } else n.kind = "method";
                  return this.finishNode(n, "TSMethodSignature");
                }
                var o = r;
                t && (o.readonly = !0);
                var l = this.tsTryParseTypeAnnotation();
                return (
                  l && (o.typeAnnotation = l),
                  this.tsParseTypeMemberSemicolon(),
                  this.finishNode(o, "TSPropertySignature")
                );
              },
            },
            {
              key: "tsParseTypeMember",
              value: function () {
                var e = this.startNode();
                if (this.match(10) || this.match(47))
                  return this.tsParseSignatureMember(
                    "TSCallSignatureDeclaration",
                    e
                  );
                if (this.match(77)) {
                  var t = this.startNode();
                  return (
                    this.next(),
                    this.match(10) || this.match(47)
                      ? this.tsParseSignatureMember(
                          "TSConstructSignatureDeclaration",
                          e
                        )
                      : ((e.key = this.createIdentifier(t, "new")),
                        this.tsParsePropertyOrMethodSignature(e, !1))
                  );
                }
                this.tsParseModifiers(
                  {
                    allowedModifiers: ["readonly"],
                    disallowedModifiers: [
                      "declare",
                      "abstract",
                      "private",
                      "protected",
                      "public",
                      "static",
                      "override",
                    ],
                  },
                  e
                );
                var n = this.tsTryParseIndexSignature(e);
                return (
                  n ||
                  (Fe(N(r.prototype), "parsePropertyName", this).call(this, e),
                  e.computed ||
                    "Identifier" !== e.key.type ||
                    ("get" !== e.key.name && "set" !== e.key.name) ||
                    !this.tsTokenCanFollowModifier() ||
                    ((e.kind = e.key.name),
                    Fe(N(r.prototype), "parsePropertyName", this).call(
                      this,
                      e
                    )),
                  this.tsParsePropertyOrMethodSignature(e, !!e.readonly))
                );
              },
            },
            {
              key: "tsParseTypeLiteral",
              value: function () {
                var e = this.startNode();
                return (
                  (e.members = this.tsParseObjectTypeMembers()),
                  this.finishNode(e, "TSTypeLiteral")
                );
              },
            },
            {
              key: "tsParseObjectTypeMembers",
              value: function () {
                this.expect(5);
                var e = this.tsParseList(
                  "TypeMembers",
                  this.tsParseTypeMember.bind(this)
                );
                return this.expect(8), e;
              },
            },
            {
              key: "tsIsStartOfMappedType",
              value: function () {
                return (
                  this.next(),
                  this.eat(53)
                    ? this.isContextual(120)
                    : (this.isContextual(120) && this.next(),
                      !!this.match(0) &&
                        (this.next(),
                        !!this.tsIsIdentifier() &&
                          (this.next(), this.match(58))))
                );
              },
            },
            {
              key: "tsParseMappedTypeParameter",
              value: function () {
                var e = this.startNode();
                return (
                  (e.name = this.tsParseTypeParameterName()),
                  (e.constraint = this.tsExpectThenParseType(58)),
                  this.finishNode(e, "TSTypeParameter")
                );
              },
            },
            {
              key: "tsParseMappedType",
              value: function () {
                var e = this.startNode();
                return (
                  this.expect(5),
                  this.match(53)
                    ? ((e.readonly = this.state.value),
                      this.next(),
                      this.expectContextual(120))
                    : this.eatContextual(120) && (e.readonly = !0),
                  this.expect(0),
                  (e.typeParameter = this.tsParseMappedTypeParameter()),
                  (e.nameType = this.eatContextual(93)
                    ? this.tsParseType()
                    : null),
                  this.expect(3),
                  this.match(53)
                    ? ((e.optional = this.state.value),
                      this.next(),
                      this.expect(17))
                    : this.eat(17) && (e.optional = !0),
                  (e.typeAnnotation = this.tsTryParseType()),
                  this.semicolon(),
                  this.expect(8),
                  this.finishNode(e, "TSMappedType")
                );
              },
            },
            {
              key: "tsParseTupleType",
              value: function () {
                var e = this,
                  t = this.startNode();
                t.elementTypes = this.tsParseBracketedList(
                  "TupleElementTypes",
                  this.tsParseTupleElementType.bind(this),
                  !0,
                  !1
                );
                var r = !1,
                  n = null;
                return (
                  t.elementTypes.forEach(function (t) {
                    var i = t.type;
                    !r ||
                      "TSRestType" === i ||
                      "TSOptionalType" === i ||
                      ("TSNamedTupleMember" === i && t.optional) ||
                      e.raise(Nn.OptionalTypeBeforeRequired, { at: t }),
                      r ||
                        (r =
                          ("TSNamedTupleMember" === i && t.optional) ||
                          "TSOptionalType" === i);
                    var a = i;
                    "TSRestType" === i && (a = (t = t.typeAnnotation).type);
                    var s = "TSNamedTupleMember" === a;
                    null != n || (n = s),
                      n !== s &&
                        e.raise(Nn.MixedLabeledAndUnlabeledElements, { at: t });
                  }),
                  this.finishNode(t, "TSTupleType")
                );
              },
            },
            {
              key: "tsParseTupleElementType",
              value: function () {
                var e,
                  t,
                  r,
                  n,
                  i,
                  a = this.state.startLoc,
                  s = this.eat(21),
                  o = Ft(this.state.type) ? this.lookaheadCharCode() : null;
                if (58 === o)
                  (e = !0),
                    (r = !1),
                    (t = this.parseIdentifier(!0)),
                    this.expect(14),
                    (n = this.tsParseType());
                else if (63 === o) {
                  r = !0;
                  var l = this.state.startLoc,
                    u = this.state.value,
                    c = this.tsParseNonArrayType();
                  58 === this.lookaheadCharCode()
                    ? ((e = !0),
                      (t = this.createIdentifier(this.startNodeAt(l), u)),
                      this.expect(17),
                      this.expect(14),
                      (n = this.tsParseType()))
                    : ((e = !1), (n = c), this.expect(17));
                } else
                  (n = this.tsParseType()),
                    (r = this.eat(17)),
                    (e = this.eat(14));
                if (e)
                  t
                    ? (((i = this.startNodeAtNode(t)).optional = r),
                      (i.label = t),
                      (i.elementType = n),
                      this.eat(17) &&
                        ((i.optional = !0),
                        this.raise(Nn.TupleOptionalAfterType, {
                          at: this.state.lastTokStartLoc,
                        })))
                    : (((i = this.startNodeAtNode(n)).optional = r),
                      this.raise(Nn.InvalidTupleMemberLabel, { at: n }),
                      (i.label = n),
                      (i.elementType = this.tsParseType())),
                    (n = this.finishNode(i, "TSNamedTupleMember"));
                else if (r) {
                  var p = this.startNodeAtNode(n);
                  (p.typeAnnotation = n),
                    (n = this.finishNode(p, "TSOptionalType"));
                }
                if (s) {
                  var h = this.startNodeAt(a);
                  (h.typeAnnotation = n),
                    (n = this.finishNode(h, "TSRestType"));
                }
                return n;
              },
            },
            {
              key: "tsParseParenthesizedType",
              value: function () {
                var e = this.startNode();
                return (
                  this.expect(10),
                  (e.typeAnnotation = this.tsParseType()),
                  this.expect(11),
                  this.finishNode(e, "TSParenthesizedType")
                );
              },
            },
            {
              key: "tsParseFunctionOrConstructorType",
              value: function (e, t) {
                var r = this,
                  n = this.startNode();
                return (
                  "TSConstructorType" === e &&
                    ((n.abstract = !!t), t && this.next(), this.next()),
                  this.tsInAllowConditionalTypesContext(function () {
                    return r.tsFillSignature(19, n);
                  }),
                  this.finishNode(n, e)
                );
              },
            },
            {
              key: "tsParseLiteralTypeNode",
              value: function () {
                var e = this.startNode();
                switch (this.state.type) {
                  case 132:
                  case 133:
                  case 131:
                  case 85:
                  case 86:
                    e.literal = Fe(N(r.prototype), "parseExprAtom", this).call(
                      this
                    );
                    break;
                  default:
                    this.unexpected();
                }
                return this.finishNode(e, "TSLiteralType");
              },
            },
            {
              key: "tsParseTemplateLiteralType",
              value: function () {
                var e = this.startNode();
                return (
                  (e.literal = Fe(N(r.prototype), "parseTemplate", this).call(
                    this,
                    !1
                  )),
                  this.finishNode(e, "TSLiteralType")
                );
              },
            },
            {
              key: "parseTemplateSubstitution",
              value: function () {
                return this.state.inType
                  ? this.tsParseType()
                  : Fe(N(r.prototype), "parseTemplateSubstitution", this).call(
                      this
                    );
              },
            },
            {
              key: "tsParseThisTypeOrThisTypePredicate",
              value: function () {
                var e = this.tsParseThisTypeNode();
                return this.isContextual(114) && !this.hasPrecedingLineBreak()
                  ? this.tsParseThisTypePredicate(e)
                  : e;
              },
            },
            {
              key: "tsParseNonArrayType",
              value: function () {
                switch (this.state.type) {
                  case 131:
                  case 132:
                  case 133:
                  case 85:
                  case 86:
                    return this.tsParseLiteralTypeNode();
                  case 53:
                    if ("-" === this.state.value) {
                      var e = this.startNode(),
                        t = this.lookahead();
                      return (
                        132 !== t.type && 133 !== t.type && this.unexpected(),
                        (e.literal = this.parseMaybeUnary()),
                        this.finishNode(e, "TSLiteralType")
                      );
                    }
                    break;
                  case 78:
                    return this.tsParseThisTypeOrThisTypePredicate();
                  case 87:
                    return this.tsParseTypeQuery();
                  case 83:
                    return this.tsParseImportType();
                  case 5:
                    return this.tsLookAhead(
                      this.tsIsStartOfMappedType.bind(this)
                    )
                      ? this.tsParseMappedType()
                      : this.tsParseTypeLiteral();
                  case 0:
                    return this.tsParseTupleType();
                  case 10:
                    return this.tsParseParenthesizedType();
                  case 25:
                  case 24:
                    return this.tsParseTemplateLiteralType();
                  default:
                    var r = this.state.type;
                    if (jt(r) || 88 === r || 84 === r) {
                      var n =
                        88 === r
                          ? "TSVoidKeyword"
                          : 84 === r
                          ? "TSNullKeyword"
                          : (function (e) {
                              switch (e) {
                                case "any":
                                  return "TSAnyKeyword";
                                case "boolean":
                                  return "TSBooleanKeyword";
                                case "bigint":
                                  return "TSBigIntKeyword";
                                case "never":
                                  return "TSNeverKeyword";
                                case "number":
                                  return "TSNumberKeyword";
                                case "object":
                                  return "TSObjectKeyword";
                                case "string":
                                  return "TSStringKeyword";
                                case "symbol":
                                  return "TSSymbolKeyword";
                                case "undefined":
                                  return "TSUndefinedKeyword";
                                case "unknown":
                                  return "TSUnknownKeyword";
                                default:
                                  return;
                              }
                            })(this.state.value);
                      if (void 0 !== n && 46 !== this.lookaheadCharCode()) {
                        var i = this.startNode();
                        return this.next(), this.finishNode(i, n);
                      }
                      return this.tsParseTypeReference();
                    }
                }
                this.unexpected();
              },
            },
            {
              key: "tsParseArrayTypeOrHigher",
              value: function () {
                for (
                  var e = this.tsParseNonArrayType();
                  !this.hasPrecedingLineBreak() && this.eat(0);

                )
                  if (this.match(3)) {
                    var t = this.startNodeAtNode(e);
                    (t.elementType = e),
                      this.expect(3),
                      (e = this.finishNode(t, "TSArrayType"));
                  } else {
                    var r = this.startNodeAtNode(e);
                    (r.objectType = e),
                      (r.indexType = this.tsParseType()),
                      this.expect(3),
                      (e = this.finishNode(r, "TSIndexedAccessType"));
                  }
                return e;
              },
            },
            {
              key: "tsParseTypeOperator",
              value: function () {
                var e = this.startNode(),
                  t = this.state.value;
                return (
                  this.next(),
                  (e.operator = t),
                  (e.typeAnnotation = this.tsParseTypeOperatorOrHigher()),
                  "readonly" === t && this.tsCheckTypeAnnotationForReadOnly(e),
                  this.finishNode(e, "TSTypeOperator")
                );
              },
            },
            {
              key: "tsCheckTypeAnnotationForReadOnly",
              value: function (e) {
                switch (e.typeAnnotation.type) {
                  case "TSTupleType":
                  case "TSArrayType":
                    return;
                  default:
                    this.raise(Nn.UnexpectedReadonly, { at: e });
                }
              },
            },
            {
              key: "tsParseInferType",
              value: function () {
                var e = this,
                  t = this.startNode();
                this.expectContextual(113);
                var r = this.startNode();
                return (
                  (r.name = this.tsParseTypeParameterName()),
                  (r.constraint = this.tsTryParse(function () {
                    return e.tsParseConstraintForInferType();
                  })),
                  (t.typeParameter = this.finishNode(r, "TSTypeParameter")),
                  this.finishNode(t, "TSInferType")
                );
              },
            },
            {
              key: "tsParseConstraintForInferType",
              value: function () {
                var e = this;
                if (this.eat(81)) {
                  var t = this.tsInDisallowConditionalTypesContext(function () {
                    return e.tsParseType();
                  });
                  if (
                    this.state.inDisallowConditionalTypesContext ||
                    !this.match(17)
                  )
                    return t;
                }
              },
            },
            {
              key: "tsParseTypeOperatorOrHigher",
              value: function () {
                var e,
                  t = this;
                return (e = this.state.type) >= 119 &&
                  e <= 121 &&
                  !this.state.containsEsc
                  ? this.tsParseTypeOperator()
                  : this.isContextual(113)
                  ? this.tsParseInferType()
                  : this.tsInAllowConditionalTypesContext(function () {
                      return t.tsParseArrayTypeOrHigher();
                    });
              },
            },
            {
              key: "tsParseUnionOrIntersectionType",
              value: function (e, t, r) {
                var n = this.startNode(),
                  i = this.eat(r),
                  a = [];
                do {
                  a.push(t());
                } while (this.eat(r));
                return 1 !== a.length || i
                  ? ((n.types = a), this.finishNode(n, e))
                  : a[0];
              },
            },
            {
              key: "tsParseIntersectionTypeOrHigher",
              value: function () {
                return this.tsParseUnionOrIntersectionType(
                  "TSIntersectionType",
                  this.tsParseTypeOperatorOrHigher.bind(this),
                  45
                );
              },
            },
            {
              key: "tsParseUnionTypeOrHigher",
              value: function () {
                return this.tsParseUnionOrIntersectionType(
                  "TSUnionType",
                  this.tsParseIntersectionTypeOrHigher.bind(this),
                  43
                );
              },
            },
            {
              key: "tsIsStartOfFunctionType",
              value: function () {
                return (
                  !!this.match(47) ||
                  (this.match(10) &&
                    this.tsLookAhead(
                      this.tsIsUnambiguouslyStartOfFunctionType.bind(this)
                    ))
                );
              },
            },
            {
              key: "tsSkipParameterStart",
              value: function () {
                if (jt(this.state.type) || this.match(78))
                  return this.next(), !0;
                if (this.match(5)) {
                  var e = this.state.errors,
                    t = e.length;
                  try {
                    return this.parseObjectLike(8, !0), e.length === t;
                  } catch (e) {
                    return !1;
                  }
                }
                if (this.match(0)) {
                  this.next();
                  var n = this.state.errors,
                    i = n.length;
                  try {
                    return (
                      Fe(N(r.prototype), "parseBindingList", this).call(
                        this,
                        3,
                        93,
                        1
                      ),
                      n.length === i
                    );
                  } catch (e) {
                    return !1;
                  }
                }
                return !1;
              },
            },
            {
              key: "tsIsUnambiguouslyStartOfFunctionType",
              value: function () {
                if ((this.next(), this.match(11) || this.match(21))) return !0;
                if (this.tsSkipParameterStart()) {
                  if (
                    this.match(14) ||
                    this.match(12) ||
                    this.match(17) ||
                    this.match(29)
                  )
                    return !0;
                  if (this.match(11) && (this.next(), this.match(19)))
                    return !0;
                }
                return !1;
              },
            },
            {
              key: "tsParseTypeOrTypePredicateAnnotation",
              value: function (e) {
                var t = this;
                return this.tsInType(function () {
                  var r = t.startNode();
                  t.expect(e);
                  var n = t.startNode(),
                    i = !!t.tsTryParse(t.tsParseTypePredicateAsserts.bind(t));
                  if (i && t.match(78)) {
                    var a = t.tsParseThisTypeOrThisTypePredicate();
                    return (
                      "TSThisType" === a.type
                        ? ((n.parameterName = a),
                          (n.asserts = !0),
                          (n.typeAnnotation = null),
                          (a = t.finishNode(n, "TSTypePredicate")))
                        : (t.resetStartLocationFromNode(a, n),
                          (a.asserts = !0)),
                      (r.typeAnnotation = a),
                      t.finishNode(r, "TSTypeAnnotation")
                    );
                  }
                  var s =
                    t.tsIsIdentifier() &&
                    t.tsTryParse(t.tsParseTypePredicatePrefix.bind(t));
                  if (!s)
                    return i
                      ? ((n.parameterName = t.parseIdentifier()),
                        (n.asserts = i),
                        (n.typeAnnotation = null),
                        (r.typeAnnotation = t.finishNode(n, "TSTypePredicate")),
                        t.finishNode(r, "TSTypeAnnotation"))
                      : t.tsParseTypeAnnotation(!1, r);
                  var o = t.tsParseTypeAnnotation(!1);
                  return (
                    (n.parameterName = s),
                    (n.typeAnnotation = o),
                    (n.asserts = i),
                    (r.typeAnnotation = t.finishNode(n, "TSTypePredicate")),
                    t.finishNode(r, "TSTypeAnnotation")
                  );
                });
              },
            },
            {
              key: "tsTryParseTypeOrTypePredicateAnnotation",
              value: function () {
                if (this.match(14))
                  return this.tsParseTypeOrTypePredicateAnnotation(14);
              },
            },
            {
              key: "tsTryParseTypeAnnotation",
              value: function () {
                if (this.match(14)) return this.tsParseTypeAnnotation();
              },
            },
            {
              key: "tsTryParseType",
              value: function () {
                return this.tsEatThenParseType(14);
              },
            },
            {
              key: "tsParseTypePredicatePrefix",
              value: function () {
                var e = this.parseIdentifier();
                if (this.isContextual(114) && !this.hasPrecedingLineBreak())
                  return this.next(), e;
              },
            },
            {
              key: "tsParseTypePredicateAsserts",
              value: function () {
                if (107 !== this.state.type) return !1;
                var e = this.state.containsEsc;
                return (
                  this.next(),
                  !(!jt(this.state.type) && !this.match(78)) &&
                    (e &&
                      this.raise(pt.InvalidEscapedReservedWord, {
                        at: this.state.lastTokStartLoc,
                        reservedWord: "asserts",
                      }),
                    !0)
                );
              },
            },
            {
              key: "tsParseTypeAnnotation",
              value: function () {
                var e = this,
                  t =
                    !(arguments.length > 0 && void 0 !== arguments[0]) ||
                    arguments[0],
                  r =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : this.startNode();
                return (
                  this.tsInType(function () {
                    t && e.expect(14), (r.typeAnnotation = e.tsParseType());
                  }),
                  this.finishNode(r, "TSTypeAnnotation")
                );
              },
            },
            {
              key: "tsParseType",
              value: function () {
                var e = this;
                On(this.state.inType);
                var t = this.tsParseNonConditionalType();
                if (
                  this.state.inDisallowConditionalTypesContext ||
                  this.hasPrecedingLineBreak() ||
                  !this.eat(81)
                )
                  return t;
                var r = this.startNodeAtNode(t);
                return (
                  (r.checkType = t),
                  (r.extendsType = this.tsInDisallowConditionalTypesContext(
                    function () {
                      return e.tsParseNonConditionalType();
                    }
                  )),
                  this.expect(17),
                  (r.trueType = this.tsInAllowConditionalTypesContext(
                    function () {
                      return e.tsParseType();
                    }
                  )),
                  this.expect(14),
                  (r.falseType = this.tsInAllowConditionalTypesContext(
                    function () {
                      return e.tsParseType();
                    }
                  )),
                  this.finishNode(r, "TSConditionalType")
                );
              },
            },
            {
              key: "isAbstractConstructorSignature",
              value: function () {
                return this.isContextual(122) && 77 === this.lookahead().type;
              },
            },
            {
              key: "tsParseNonConditionalType",
              value: function () {
                return this.tsIsStartOfFunctionType()
                  ? this.tsParseFunctionOrConstructorType("TSFunctionType")
                  : this.match(77)
                  ? this.tsParseFunctionOrConstructorType("TSConstructorType")
                  : this.isAbstractConstructorSignature()
                  ? this.tsParseFunctionOrConstructorType(
                      "TSConstructorType",
                      !0
                    )
                  : this.tsParseUnionTypeOrHigher();
              },
            },
            {
              key: "tsParseTypeAssertion",
              value: function () {
                var e = this;
                this.getPluginOption(
                  "typescript",
                  "disallowAmbiguousJSXLike"
                ) &&
                  this.raise(Nn.ReservedTypeAssertion, {
                    at: this.state.startLoc,
                  });
                var t = this.startNode();
                return (
                  (t.typeAnnotation = this.tsInType(function () {
                    return (
                      e.next(),
                      e.match(75) ? e.tsParseTypeReference() : e.tsParseType()
                    );
                  })),
                  this.expect(48),
                  (t.expression = this.parseMaybeUnary()),
                  this.finishNode(t, "TSTypeAssertion")
                );
              },
            },
            {
              key: "tsParseHeritageClause",
              value: function (e) {
                var t = this,
                  r = this.state.startLoc,
                  n = this.tsParseDelimitedList(
                    "HeritageClauseElement",
                    function () {
                      var e = t.startNode();
                      return (
                        (e.expression = t.tsParseEntityName()),
                        t.match(47) &&
                          (e.typeParameters = t.tsParseTypeArguments()),
                        t.finishNode(e, "TSExpressionWithTypeArguments")
                      );
                    }
                  );
                return (
                  n.length ||
                    this.raise(Nn.EmptyHeritageClauseType, { at: r, token: e }),
                  n
                );
              },
            },
            {
              key: "tsParseInterfaceDeclaration",
              value: function (e) {
                var t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : {};
                if (this.hasFollowingLineBreak()) return null;
                this.expectContextual(127),
                  t.declare && (e.declare = !0),
                  jt(this.state.type)
                    ? ((e.id = this.parseIdentifier()),
                      this.checkIdentifier(e.id, 130))
                    : ((e.id = null),
                      this.raise(Nn.MissingInterfaceName, {
                        at: this.state.startLoc,
                      })),
                  (e.typeParameters = this.tsTryParseTypeParameters(
                    this.tsParseInOutConstModifiers
                  )),
                  this.eat(81) &&
                    (e.extends = this.tsParseHeritageClause("extends"));
                var r = this.startNode();
                return (
                  (r.body = this.tsInType(
                    this.tsParseObjectTypeMembers.bind(this)
                  )),
                  (e.body = this.finishNode(r, "TSInterfaceBody")),
                  this.finishNode(e, "TSInterfaceDeclaration")
                );
              },
            },
            {
              key: "tsParseTypeAliasDeclaration",
              value: function (e) {
                var t = this;
                return (
                  (e.id = this.parseIdentifier()),
                  this.checkIdentifier(e.id, 2),
                  (e.typeAnnotation = this.tsInType(function () {
                    if (
                      ((e.typeParameters = t.tsTryParseTypeParameters(
                        t.tsParseInOutModifiers
                      )),
                      t.expect(29),
                      t.isContextual(112) && 16 !== t.lookahead().type)
                    ) {
                      var r = t.startNode();
                      return t.next(), t.finishNode(r, "TSIntrinsicKeyword");
                    }
                    return t.tsParseType();
                  })),
                  this.semicolon(),
                  this.finishNode(e, "TSTypeAliasDeclaration")
                );
              },
            },
            {
              key: "tsInNoContext",
              value: function (e) {
                var t = this.state.context;
                this.state.context = [t[0]];
                try {
                  return e();
                } finally {
                  this.state.context = t;
                }
              },
            },
            {
              key: "tsInType",
              value: function (e) {
                var t = this.state.inType;
                this.state.inType = !0;
                try {
                  return e();
                } finally {
                  this.state.inType = t;
                }
              },
            },
            {
              key: "tsInDisallowConditionalTypesContext",
              value: function (e) {
                var t = this.state.inDisallowConditionalTypesContext;
                this.state.inDisallowConditionalTypesContext = !0;
                try {
                  return e();
                } finally {
                  this.state.inDisallowConditionalTypesContext = t;
                }
              },
            },
            {
              key: "tsInAllowConditionalTypesContext",
              value: function (e) {
                var t = this.state.inDisallowConditionalTypesContext;
                this.state.inDisallowConditionalTypesContext = !1;
                try {
                  return e();
                } finally {
                  this.state.inDisallowConditionalTypesContext = t;
                }
              },
            },
            {
              key: "tsEatThenParseType",
              value: function (e) {
                if (this.match(e)) return this.tsNextThenParseType();
              },
            },
            {
              key: "tsExpectThenParseType",
              value: function (e) {
                var t = this;
                return this.tsInType(function () {
                  return t.expect(e), t.tsParseType();
                });
              },
            },
            {
              key: "tsNextThenParseType",
              value: function () {
                var e = this;
                return this.tsInType(function () {
                  return e.next(), e.tsParseType();
                });
              },
            },
            {
              key: "tsParseEnumMember",
              value: function () {
                var e = this.startNode();
                return (
                  (e.id = this.match(131)
                    ? Fe(N(r.prototype), "parseStringLiteral", this).call(
                        this,
                        this.state.value
                      )
                    : this.parseIdentifier(!0)),
                  this.eat(29) &&
                    (e.initializer = Fe(
                      N(r.prototype),
                      "parseMaybeAssignAllowIn",
                      this
                    ).call(this)),
                  this.finishNode(e, "TSEnumMember")
                );
              },
            },
            {
              key: "tsParseEnumDeclaration",
              value: function (e) {
                var t =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : {};
                return (
                  t.const && (e.const = !0),
                  t.declare && (e.declare = !0),
                  this.expectContextual(124),
                  (e.id = this.parseIdentifier()),
                  this.checkIdentifier(e.id, e.const ? 8971 : 8459),
                  this.expect(5),
                  (e.members = this.tsParseDelimitedList(
                    "EnumMembers",
                    this.tsParseEnumMember.bind(this)
                  )),
                  this.expect(8),
                  this.finishNode(e, "TSEnumDeclaration")
                );
              },
            },
            {
              key: "tsParseModuleBlock",
              value: function () {
                var e = this.startNode();
                return (
                  this.scope.enter(0),
                  this.expect(5),
                  Fe(N(r.prototype), "parseBlockOrModuleBlockBody", this).call(
                    this,
                    (e.body = []),
                    void 0,
                    !0,
                    8
                  ),
                  this.scope.exit(),
                  this.finishNode(e, "TSModuleBlock")
                );
              },
            },
            {
              key: "tsParseModuleOrNamespaceDeclaration",
              value: function (e) {
                var t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1];
                if (
                  ((e.id = this.parseIdentifier()),
                  t || this.checkIdentifier(e.id, 1024),
                  this.eat(16))
                ) {
                  var r = this.startNode();
                  this.tsParseModuleOrNamespaceDeclaration(r, !0), (e.body = r);
                } else
                  this.scope.enter(dr),
                    this.prodParam.enter(0),
                    (e.body = this.tsParseModuleBlock()),
                    this.prodParam.exit(),
                    this.scope.exit();
                return this.finishNode(e, "TSModuleDeclaration");
              },
            },
            {
              key: "tsParseAmbientExternalModuleDeclaration",
              value: function (e) {
                return (
                  this.isContextual(110)
                    ? ((e.global = !0), (e.id = this.parseIdentifier()))
                    : this.match(131)
                    ? (e.id = Fe(
                        N(r.prototype),
                        "parseStringLiteral",
                        this
                      ).call(this, this.state.value))
                    : this.unexpected(),
                  this.match(5)
                    ? (this.scope.enter(dr),
                      this.prodParam.enter(0),
                      (e.body = this.tsParseModuleBlock()),
                      this.prodParam.exit(),
                      this.scope.exit())
                    : this.semicolon(),
                  this.finishNode(e, "TSModuleDeclaration")
                );
              },
            },
            {
              key: "tsParseImportEqualsDeclaration",
              value: function (e, t) {
                (e.isExport = t || !1),
                  (e.id = this.parseIdentifier()),
                  this.checkIdentifier(e.id, gr),
                  this.expect(29);
                var r = this.tsParseModuleReference();
                return (
                  "type" === e.importKind &&
                    "TSExternalModuleReference" !== r.type &&
                    this.raise(Nn.ImportAliasHasImportType, { at: r }),
                  (e.moduleReference = r),
                  this.semicolon(),
                  this.finishNode(e, "TSImportEqualsDeclaration")
                );
              },
            },
            {
              key: "tsIsExternalModuleReference",
              value: function () {
                return (
                  this.isContextual(117) && 40 === this.lookaheadCharCode()
                );
              },
            },
            {
              key: "tsParseModuleReference",
              value: function () {
                return this.tsIsExternalModuleReference()
                  ? this.tsParseExternalModuleReference()
                  : this.tsParseEntityName(!1);
              },
            },
            {
              key: "tsParseExternalModuleReference",
              value: function () {
                var e = this.startNode();
                return (
                  this.expectContextual(117),
                  this.expect(10),
                  this.match(131) || this.unexpected(),
                  (e.expression = Fe(
                    N(r.prototype),
                    "parseExprAtom",
                    this
                  ).call(this)),
                  this.expect(11),
                  this.finishNode(e, "TSExternalModuleReference")
                );
              },
            },
            {
              key: "tsLookAhead",
              value: function (e) {
                var t = this.state.clone(),
                  r = e();
                return (this.state = t), r;
              },
            },
            {
              key: "tsTryParseAndCatch",
              value: function (e) {
                var t = this.tryParse(function (t) {
                  return e() || t();
                });
                if (!t.aborted && t.node)
                  return t.error && (this.state = t.failState), t.node;
              },
            },
            {
              key: "tsTryParse",
              value: function (e) {
                var t = this.state.clone(),
                  r = e();
                if (void 0 !== r && !1 !== r) return r;
                this.state = t;
              },
            },
            {
              key: "tsTryParseDeclare",
              value: function (e) {
                var t = this;
                if (!this.isLineTerminator()) {
                  var n,
                    i = this.state.type;
                  return (
                    this.isContextual(99) && ((i = 74), (n = "let")),
                    this.tsInAmbientContext(function () {
                      switch (i) {
                        case 68:
                          return (
                            (e.declare = !0),
                            Fe(
                              N(r.prototype),
                              "parseFunctionStatement",
                              t
                            ).call(t, e, !1, !1)
                          );
                        case 80:
                          return (e.declare = !0), t.parseClass(e, !0, !1);
                        case 124:
                          return t.tsParseEnumDeclaration(e, { declare: !0 });
                        case 110:
                          return t.tsParseAmbientExternalModuleDeclaration(e);
                        case 75:
                        case 74:
                          return t.match(75) && t.isLookaheadContextual("enum")
                            ? (t.expect(75),
                              t.tsParseEnumDeclaration(e, {
                                const: !0,
                                declare: !0,
                              }))
                            : ((e.declare = !0),
                              t.parseVarStatement(e, n || t.state.value, !0));
                        case 127:
                          var a = t.tsParseInterfaceDeclaration(e, {
                            declare: !0,
                          });
                          if (a) return a;
                        default:
                          if (jt(i))
                            return t.tsParseDeclaration(
                              e,
                              t.state.value,
                              !0,
                              null
                            );
                      }
                    })
                  );
                }
              },
            },
            {
              key: "tsTryParseExportDeclaration",
              value: function () {
                return this.tsParseDeclaration(
                  this.startNode(),
                  this.state.value,
                  !0,
                  null
                );
              },
            },
            {
              key: "tsParseExpressionStatement",
              value: function (e, t, r) {
                switch (t.name) {
                  case "declare":
                    var n = this.tsTryParseDeclare(e);
                    return n && (n.declare = !0), n;
                  case "global":
                    if (this.match(5)) {
                      this.scope.enter(dr), this.prodParam.enter(0);
                      var i = e;
                      return (
                        (i.global = !0),
                        (i.id = t),
                        (i.body = this.tsParseModuleBlock()),
                        this.scope.exit(),
                        this.prodParam.exit(),
                        this.finishNode(i, "TSModuleDeclaration")
                      );
                    }
                    break;
                  default:
                    return this.tsParseDeclaration(e, t.name, !1, r);
                }
              },
            },
            {
              key: "tsParseDeclaration",
              value: function (e, t, r, n) {
                switch (t) {
                  case "abstract":
                    if (
                      this.tsCheckLineTerminator(r) &&
                      (this.match(80) || jt(this.state.type))
                    )
                      return this.tsParseAbstractDeclaration(e, n);
                    break;
                  case "module":
                    if (this.tsCheckLineTerminator(r)) {
                      if (this.match(131))
                        return this.tsParseAmbientExternalModuleDeclaration(e);
                      if (jt(this.state.type))
                        return this.tsParseModuleOrNamespaceDeclaration(e);
                    }
                    break;
                  case "namespace":
                    if (this.tsCheckLineTerminator(r) && jt(this.state.type))
                      return this.tsParseModuleOrNamespaceDeclaration(e);
                    break;
                  case "type":
                    if (this.tsCheckLineTerminator(r) && jt(this.state.type))
                      return this.tsParseTypeAliasDeclaration(e);
                }
              },
            },
            {
              key: "tsCheckLineTerminator",
              value: function (e) {
                return e
                  ? !this.hasFollowingLineBreak() && (this.next(), !0)
                  : !this.isLineTerminator();
              },
            },
            {
              key: "tsTryParseGenericAsyncArrowFunction",
              value: function (e) {
                var t = this;
                if (this.match(47)) {
                  var n = this.state.maybeInArrowParameters;
                  this.state.maybeInArrowParameters = !0;
                  var i = this.tsTryParseAndCatch(function () {
                    var n = t.startNodeAt(e);
                    return (
                      (n.typeParameters = t.tsParseTypeParameters(
                        t.tsParseConstModifier
                      )),
                      Fe(N(r.prototype), "parseFunctionParams", t).call(t, n),
                      (n.returnType =
                        t.tsTryParseTypeOrTypePredicateAnnotation()),
                      t.expect(19),
                      n
                    );
                  });
                  if (((this.state.maybeInArrowParameters = n), i))
                    return Fe(
                      N(r.prototype),
                      "parseArrowExpression",
                      this
                    ).call(this, i, null, !0);
                }
              },
            },
            {
              key: "tsParseTypeArgumentsInExpression",
              value: function () {
                if (47 === this.reScan_lt()) return this.tsParseTypeArguments();
              },
            },
            {
              key: "tsParseTypeArguments",
              value: function () {
                var e = this,
                  t = this.startNode();
                return (
                  (t.params = this.tsInType(function () {
                    return e.tsInNoContext(function () {
                      return (
                        e.expect(47),
                        e.tsParseDelimitedList(
                          "TypeParametersOrArguments",
                          e.tsParseType.bind(e)
                        )
                      );
                    });
                  })),
                  0 === t.params.length
                    ? this.raise(Nn.EmptyTypeArguments, { at: t })
                    : this.state.inType ||
                      this.curContext() !== mt.brace ||
                      this.reScan_lt_gt(),
                  this.expect(48),
                  this.finishNode(t, "TSTypeParameterInstantiation")
                );
              },
            },
            {
              key: "tsIsDeclarationStart",
              value: function () {
                return (e = this.state.type) >= 122 && e <= 128;
                var e;
              },
            },
            {
              key: "isExportDefaultSpecifier",
              value: function () {
                return (
                  !this.tsIsDeclarationStart() &&
                  Fe(N(r.prototype), "isExportDefaultSpecifier", this).call(
                    this
                  )
                );
              },
            },
            {
              key: "parseAssignableListItem",
              value: function (e, t) {
                var r = this.state.startLoc,
                  n = {};
                this.tsParseModifiers(
                  {
                    allowedModifiers: [
                      "public",
                      "private",
                      "protected",
                      "override",
                      "readonly",
                    ],
                  },
                  n
                );
                var i = n.accessibility,
                  a = n.override,
                  s = n.readonly;
                4 & e ||
                  !(i || s || a) ||
                  this.raise(Nn.UnexpectedParameterModifier, { at: r });
                var o = this.parseMaybeDefault();
                this.parseAssignableListItemTypes(o, e);
                var l = this.parseMaybeDefault(o.loc.start, o);
                if (i || s || a) {
                  var u = this.startNodeAt(r);
                  return (
                    t.length && (u.decorators = t),
                    i && (u.accessibility = i),
                    s && (u.readonly = s),
                    a && (u.override = a),
                    "Identifier" !== l.type &&
                      "AssignmentPattern" !== l.type &&
                      this.raise(Nn.UnsupportedParameterPropertyKind, {
                        at: u,
                      }),
                    (u.parameter = l),
                    this.finishNode(u, "TSParameterProperty")
                  );
                }
                return t.length && (o.decorators = t), l;
              },
            },
            {
              key: "isSimpleParameter",
              value: function (e) {
                return (
                  ("TSParameterProperty" === e.type &&
                    Fe(N(r.prototype), "isSimpleParameter", this).call(
                      this,
                      e.parameter
                    )) ||
                  Fe(N(r.prototype), "isSimpleParameter", this).call(this, e)
                );
              },
            },
            {
              key: "tsDisallowOptionalPattern",
              value: function (e) {
                var t,
                  r = He(e.params);
                try {
                  for (r.s(); !(t = r.n()).done; ) {
                    var n = t.value;
                    "Identifier" !== n.type &&
                      n.optional &&
                      !this.state.isAmbientContext &&
                      this.raise(Nn.PatternIsOptional, { at: n });
                  }
                } catch (e) {
                  r.e(e);
                } finally {
                  r.f();
                }
              },
            },
            {
              key: "setArrowFunctionParameters",
              value: function (e, t, n) {
                Fe(N(r.prototype), "setArrowFunctionParameters", this).call(
                  this,
                  e,
                  t,
                  n
                ),
                  this.tsDisallowOptionalPattern(e);
              },
            },
            {
              key: "parseFunctionBodyAndFinish",
              value: function (e, t) {
                var n =
                  arguments.length > 2 &&
                  void 0 !== arguments[2] &&
                  arguments[2];
                this.match(14) &&
                  (e.returnType =
                    this.tsParseTypeOrTypePredicateAnnotation(14));
                var i =
                  "FunctionDeclaration" === t
                    ? "TSDeclareFunction"
                    : "ClassMethod" === t || "ClassPrivateMethod" === t
                    ? "TSDeclareMethod"
                    : void 0;
                return i && !this.match(5) && this.isLineTerminator()
                  ? this.finishNode(e, i)
                  : "TSDeclareFunction" === i &&
                    this.state.isAmbientContext &&
                    (this.raise(Nn.DeclareFunctionHasImplementation, { at: e }),
                    e.declare)
                  ? Fe(N(r.prototype), "parseFunctionBodyAndFinish", this).call(
                      this,
                      e,
                      i,
                      n
                    )
                  : (this.tsDisallowOptionalPattern(e),
                    Fe(N(r.prototype), "parseFunctionBodyAndFinish", this).call(
                      this,
                      e,
                      t,
                      n
                    ));
              },
            },
            {
              key: "registerFunctionStatementId",
              value: function (e) {
                !e.body && e.id
                  ? this.checkIdentifier(e.id, 1024)
                  : Fe(
                      N(r.prototype),
                      "registerFunctionStatementId",
                      this
                    ).call(this, e);
              },
            },
            {
              key: "tsCheckForInvalidTypeCasts",
              value: function (e) {
                var t = this;
                e.forEach(function (e) {
                  "TSTypeCastExpression" === (null == e ? void 0 : e.type) &&
                    t.raise(Nn.UnexpectedTypeAnnotation, {
                      at: e.typeAnnotation,
                    });
                });
              },
            },
            {
              key: "toReferencedList",
              value: function (e, t) {
                return this.tsCheckForInvalidTypeCasts(e), e;
              },
            },
            {
              key: "parseArrayLike",
              value: function (e, t, n, i) {
                var a = Fe(N(r.prototype), "parseArrayLike", this).call(
                  this,
                  e,
                  t,
                  n,
                  i
                );
                return (
                  "ArrayExpression" === a.type &&
                    this.tsCheckForInvalidTypeCasts(a.elements),
                  a
                );
              },
            },
            {
              key: "parseSubscript",
              value: function (e, t, n, i) {
                var a = this;
                if (!this.hasPrecedingLineBreak() && this.match(35)) {
                  (this.state.canStartJSXElement = !1), this.next();
                  var s = this.startNodeAt(t);
                  return (
                    (s.expression = e),
                    this.finishNode(s, "TSNonNullExpression")
                  );
                }
                var o = !1;
                if (this.match(18) && 60 === this.lookaheadCharCode()) {
                  if (n) return (i.stop = !0), e;
                  (i.optionalChainMember = o = !0), this.next();
                }
                if (this.match(47) || this.match(51)) {
                  var l,
                    u = this.tsTryParseAndCatch(function () {
                      if (!n && a.atPossibleAsyncArrow(e)) {
                        var s = a.tsTryParseGenericAsyncArrowFunction(t);
                        if (s) return s;
                      }
                      var u = a.tsParseTypeArgumentsInExpression();
                      if (u)
                        if (!o || a.match(10)) {
                          if (qt(a.state.type)) {
                            var c = Fe(
                              N(r.prototype),
                              "parseTaggedTemplateExpression",
                              a
                            ).call(a, e, t, i);
                            return (c.typeParameters = u), c;
                          }
                          if (!n && a.eat(10)) {
                            var p = a.startNodeAt(t);
                            return (
                              (p.callee = e),
                              (p.arguments = a.parseCallExpressionArguments(
                                11,
                                !1
                              )),
                              a.tsCheckForInvalidTypeCasts(p.arguments),
                              (p.typeParameters = u),
                              i.optionalChainMember && (p.optional = o),
                              a.finishCallExpression(p, i.optionalChainMember)
                            );
                          }
                          var h = a.state.type;
                          if (
                            48 !== h &&
                            52 !== h &&
                            (10 === h || !Rt(h) || a.hasPrecedingLineBreak())
                          ) {
                            var d = a.startNodeAt(t);
                            return (
                              (d.expression = e),
                              (d.typeParameters = u),
                              a.finishNode(d, "TSInstantiationExpression")
                            );
                          }
                        } else l = a.state.curPosition();
                    });
                  if ((l && this.unexpected(l, 10), u))
                    return (
                      "TSInstantiationExpression" === u.type &&
                        (this.match(16) ||
                          (this.match(18) &&
                            40 !== this.lookaheadCharCode())) &&
                        this.raise(
                          Nn.InvalidPropertyAccessAfterInstantiationExpression,
                          { at: this.state.startLoc }
                        ),
                      u
                    );
                }
                return Fe(N(r.prototype), "parseSubscript", this).call(
                  this,
                  e,
                  t,
                  n,
                  i
                );
              },
            },
            {
              key: "parseNewCallee",
              value: function (e) {
                var t;
                Fe(N(r.prototype), "parseNewCallee", this).call(this, e);
                var n = e.callee;
                "TSInstantiationExpression" !== n.type ||
                  (null != (t = n.extra) && t.parenthesized) ||
                  ((e.typeParameters = n.typeParameters),
                  (e.callee = n.expression));
              },
            },
            {
              key: "parseExprOp",
              value: function (e, t, n) {
                var i,
                  a = this;
                if (
                  Wt(58) > n &&
                  !this.hasPrecedingLineBreak() &&
                  (this.isContextual(93) || (i = this.isContextual(118)))
                ) {
                  var s = this.startNodeAt(t);
                  return (
                    (s.expression = e),
                    (s.typeAnnotation = this.tsInType(function () {
                      return (
                        a.next(),
                        a.match(75)
                          ? (i &&
                              a.raise(pt.UnexpectedKeyword, {
                                at: a.state.startLoc,
                                keyword: "const",
                              }),
                            a.tsParseTypeReference())
                          : a.tsParseType()
                      );
                    })),
                    this.finishNode(
                      s,
                      i ? "TSSatisfiesExpression" : "TSAsExpression"
                    ),
                    this.reScan_lt_gt(),
                    this.parseExprOp(s, t, n)
                  );
                }
                return Fe(N(r.prototype), "parseExprOp", this).call(
                  this,
                  e,
                  t,
                  n
                );
              },
            },
            {
              key: "checkReservedWord",
              value: function (e, t, n, i) {
                this.state.isAmbientContext ||
                  Fe(N(r.prototype), "checkReservedWord", this).call(
                    this,
                    e,
                    t,
                    n,
                    i
                  );
              },
            },
            {
              key: "checkImportReflection",
              value: function (e) {
                Fe(N(r.prototype), "checkImportReflection", this).call(this, e),
                  e.module &&
                    "value" !== e.importKind &&
                    this.raise(Nn.ImportReflectionHasImportType, {
                      at: e.specifiers[0].loc.start,
                    });
              },
            },
            { key: "checkDuplicateExports", value: function () {} },
            {
              key: "parseImport",
              value: function (e) {
                if (
                  ((e.importKind = "value"),
                  jt(this.state.type) || this.match(55) || this.match(5))
                ) {
                  var t = this.lookahead();
                  if (
                    (this.isContextual(128) &&
                      12 !== t.type &&
                      97 !== t.type &&
                      29 !== t.type &&
                      ((e.importKind = "type"),
                      this.next(),
                      (t = this.lookahead())),
                    jt(this.state.type) && 29 === t.type)
                  )
                    return this.tsParseImportEqualsDeclaration(e);
                }
                var n = Fe(N(r.prototype), "parseImport", this).call(this, e);
                return (
                  "type" === n.importKind &&
                    n.specifiers.length > 1 &&
                    "ImportDefaultSpecifier" === n.specifiers[0].type &&
                    this.raise(Nn.TypeImportCannotSpecifyDefaultAndNamed, {
                      at: n,
                    }),
                  n
                );
              },
            },
            {
              key: "parseExport",
              value: function (e, t) {
                if (this.match(83))
                  return (
                    this.next(),
                    this.isContextual(128) && 61 !== this.lookaheadCharCode()
                      ? ((e.importKind = "type"), this.next())
                      : (e.importKind = "value"),
                    this.tsParseImportEqualsDeclaration(e, !0)
                  );
                if (this.eat(29)) {
                  var n = e;
                  return (
                    (n.expression = Fe(
                      N(r.prototype),
                      "parseExpression",
                      this
                    ).call(this)),
                    this.semicolon(),
                    this.finishNode(n, "TSExportAssignment")
                  );
                }
                if (this.eatContextual(93)) {
                  var i = e;
                  return (
                    this.expectContextual(126),
                    (i.id = this.parseIdentifier()),
                    this.semicolon(),
                    this.finishNode(i, "TSNamespaceExportDeclaration")
                  );
                }
                if (((e.exportKind = "value"), this.isContextual(128))) {
                  var a = this.lookaheadCharCode();
                  (123 !== a && 42 !== a) ||
                    (this.next(), (e.exportKind = "type"));
                }
                return Fe(N(r.prototype), "parseExport", this).call(this, e, t);
              },
            },
            {
              key: "isAbstractClass",
              value: function () {
                return this.isContextual(122) && 80 === this.lookahead().type;
              },
            },
            {
              key: "parseExportDefaultExpression",
              value: function () {
                if (this.isAbstractClass()) {
                  var e = this.startNode();
                  return (
                    this.next(), (e.abstract = !0), this.parseClass(e, !0, !0)
                  );
                }
                if (this.match(127)) {
                  var t = this.tsParseInterfaceDeclaration(this.startNode());
                  if (t) return t;
                }
                return Fe(
                  N(r.prototype),
                  "parseExportDefaultExpression",
                  this
                ).call(this);
              },
            },
            {
              key: "parseVarStatement",
              value: function (e, t) {
                var n =
                    arguments.length > 2 &&
                    void 0 !== arguments[2] &&
                    arguments[2],
                  i = this.state.isAmbientContext,
                  a = Fe(N(r.prototype), "parseVarStatement", this).call(
                    this,
                    e,
                    t,
                    n || i
                  );
                if (!i) return a;
                var s,
                  o = He(a.declarations);
                try {
                  for (o.s(); !(s = o.n()).done; ) {
                    var l = s.value,
                      u = l.id,
                      c = l.init;
                    c &&
                      ("const" !== t || u.typeAnnotation
                        ? this.raise(Nn.InitializerNotAllowedInAmbientContext, {
                            at: c,
                          })
                        : Mn(c, this.hasPlugin("estree")) ||
                          this.raise(
                            Nn.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference,
                            { at: c }
                          ));
                  }
                } catch (e) {
                  o.e(e);
                } finally {
                  o.f();
                }
                return a;
              },
            },
            {
              key: "parseStatementContent",
              value: function (e, t) {
                if (this.match(75) && this.isLookaheadContextual("enum")) {
                  var n = this.startNode();
                  return (
                    this.expect(75),
                    this.tsParseEnumDeclaration(n, { const: !0 })
                  );
                }
                if (this.isContextual(124))
                  return this.tsParseEnumDeclaration(this.startNode());
                if (this.isContextual(127)) {
                  var i = this.tsParseInterfaceDeclaration(this.startNode());
                  if (i) return i;
                }
                return Fe(N(r.prototype), "parseStatementContent", this).call(
                  this,
                  e,
                  t
                );
              },
            },
            {
              key: "parseAccessModifier",
              value: function () {
                return this.tsParseModifier(["public", "protected", "private"]);
              },
            },
            {
              key: "tsHasSomeModifiers",
              value: function (e, t) {
                return t.some(function (t) {
                  return _n(t) ? e.accessibility === t : !!e[t];
                });
              },
            },
            {
              key: "tsIsStartOfStaticBlocks",
              value: function () {
                return (
                  this.isContextual(104) && 123 === this.lookaheadCharCode()
                );
              },
            },
            {
              key: "parseClassMember",
              value: function (e, t, n) {
                var i = this,
                  a = [
                    "declare",
                    "private",
                    "public",
                    "protected",
                    "override",
                    "abstract",
                    "readonly",
                    "static",
                  ];
                this.tsParseModifiers(
                  {
                    allowedModifiers: a,
                    disallowedModifiers: ["in", "out"],
                    stopOnStartOfClassStaticBlock: !0,
                    errorTemplate: Nn.InvalidModifierOnTypeParameterPositions,
                  },
                  t
                );
                var s = function () {
                  i.tsIsStartOfStaticBlocks()
                    ? (i.next(),
                      i.next(),
                      i.tsHasSomeModifiers(t, a) &&
                        i.raise(Nn.StaticBlockCannotHaveModifier, {
                          at: i.state.curPosition(),
                        }),
                      Fe(N(r.prototype), "parseClassStaticBlock", i).call(
                        i,
                        e,
                        t
                      ))
                    : i.parseClassMemberWithIsStatic(e, t, n, !!t.static);
                };
                t.declare ? this.tsInAmbientContext(s) : s();
              },
            },
            {
              key: "parseClassMemberWithIsStatic",
              value: function (e, t, n, i) {
                var a = this.tsTryParseIndexSignature(t);
                if (a)
                  return (
                    e.body.push(a),
                    t.abstract &&
                      this.raise(Nn.IndexSignatureHasAbstract, { at: t }),
                    t.accessibility &&
                      this.raise(Nn.IndexSignatureHasAccessibility, {
                        at: t,
                        modifier: t.accessibility,
                      }),
                    t.declare &&
                      this.raise(Nn.IndexSignatureHasDeclare, { at: t }),
                    void (
                      t.override &&
                      this.raise(Nn.IndexSignatureHasOverride, { at: t })
                    )
                  );
                !this.state.inAbstractClass &&
                  t.abstract &&
                  this.raise(Nn.NonAbstractClassHasAbstractMethod, { at: t }),
                  t.override &&
                    (n.hadSuperClass ||
                      this.raise(Nn.OverrideNotInSubClass, { at: t })),
                  Fe(N(r.prototype), "parseClassMemberWithIsStatic", this).call(
                    this,
                    e,
                    t,
                    n,
                    i
                  );
              },
            },
            {
              key: "parsePostMemberNameModifiers",
              value: function (e) {
                this.eat(17) && (e.optional = !0),
                  e.readonly &&
                    this.match(10) &&
                    this.raise(Nn.ClassMethodHasReadonly, { at: e }),
                  e.declare &&
                    this.match(10) &&
                    this.raise(Nn.ClassMethodHasDeclare, { at: e });
              },
            },
            {
              key: "parseExpressionStatement",
              value: function (e, t, n) {
                return (
                  ("Identifier" === t.type
                    ? this.tsParseExpressionStatement(e, t, n)
                    : void 0) ||
                  Fe(N(r.prototype), "parseExpressionStatement", this).call(
                    this,
                    e,
                    t,
                    n
                  )
                );
              },
            },
            {
              key: "shouldParseExportDeclaration",
              value: function () {
                return (
                  !!this.tsIsDeclarationStart() ||
                  Fe(N(r.prototype), "shouldParseExportDeclaration", this).call(
                    this
                  )
                );
              },
            },
            {
              key: "parseConditional",
              value: function (e, t, n) {
                var i = this;
                if (!this.state.maybeInArrowParameters || !this.match(17))
                  return Fe(N(r.prototype), "parseConditional", this).call(
                    this,
                    e,
                    t,
                    n
                  );
                var a = this.tryParse(function () {
                  return Fe(N(r.prototype), "parseConditional", i).call(
                    i,
                    e,
                    t
                  );
                });
                return a.node
                  ? (a.error && (this.state = a.failState), a.node)
                  : (a.error &&
                      Fe(
                        N(r.prototype),
                        "setOptionalParametersError",
                        this
                      ).call(this, n, a.error),
                    e);
              },
            },
            {
              key: "parseParenItem",
              value: function (e, t) {
                if (
                  ((e = Fe(N(r.prototype), "parseParenItem", this).call(
                    this,
                    e,
                    t
                  )),
                  this.eat(17) && ((e.optional = !0), this.resetEndLocation(e)),
                  this.match(14))
                ) {
                  var n = this.startNodeAt(t);
                  return (
                    (n.expression = e),
                    (n.typeAnnotation = this.tsParseTypeAnnotation()),
                    this.finishNode(n, "TSTypeCastExpression")
                  );
                }
                return e;
              },
            },
            {
              key: "parseExportDeclaration",
              value: function (e) {
                var t = this;
                if (!this.state.isAmbientContext && this.isContextual(123))
                  return this.tsInAmbientContext(function () {
                    return t.parseExportDeclaration(e);
                  });
                var n = this.state.startLoc,
                  i = this.eatContextual(123);
                if (
                  i &&
                  (this.isContextual(123) ||
                    !this.shouldParseExportDeclaration())
                )
                  throw this.raise(Nn.ExpectedAmbientAfterExportDeclare, {
                    at: this.state.startLoc,
                  });
                var a =
                  (jt(this.state.type) && this.tsTryParseExportDeclaration()) ||
                  Fe(N(r.prototype), "parseExportDeclaration", this).call(
                    this,
                    e
                  );
                return a
                  ? (("TSInterfaceDeclaration" === a.type ||
                      "TSTypeAliasDeclaration" === a.type ||
                      i) &&
                      (e.exportKind = "type"),
                    i && (this.resetStartLocation(a, n), (a.declare = !0)),
                    a)
                  : null;
              },
            },
            {
              key: "parseClassId",
              value: function (e, t, n, i) {
                if ((t && !n) || !this.isContextual(111)) {
                  Fe(N(r.prototype), "parseClassId", this).call(
                    this,
                    e,
                    t,
                    n,
                    e.declare ? 1024 : 8331
                  );
                  var a = this.tsTryParseTypeParameters(
                    this.tsParseInOutConstModifiers
                  );
                  a && (e.typeParameters = a);
                }
              },
            },
            {
              key: "parseClassPropertyAnnotation",
              value: function (e) {
                e.optional ||
                  (this.eat(35)
                    ? (e.definite = !0)
                    : this.eat(17) && (e.optional = !0));
                var t = this.tsTryParseTypeAnnotation();
                t && (e.typeAnnotation = t);
              },
            },
            {
              key: "parseClassProperty",
              value: function (e) {
                if (
                  (this.parseClassPropertyAnnotation(e),
                  this.state.isAmbientContext &&
                    (!e.readonly || e.typeAnnotation) &&
                    this.match(29) &&
                    this.raise(Nn.DeclareClassFieldHasInitializer, {
                      at: this.state.startLoc,
                    }),
                  e.abstract && this.match(29))
                ) {
                  var t = e.key;
                  this.raise(Nn.AbstractPropertyHasInitializer, {
                    at: this.state.startLoc,
                    propertyName:
                      "Identifier" !== t.type || e.computed
                        ? "[".concat(this.input.slice(t.start, t.end), "]")
                        : t.name,
                  });
                }
                return Fe(N(r.prototype), "parseClassProperty", this).call(
                  this,
                  e
                );
              },
            },
            {
              key: "parseClassPrivateProperty",
              value: function (e) {
                return (
                  e.abstract &&
                    this.raise(Nn.PrivateElementHasAbstract, { at: e }),
                  e.accessibility &&
                    this.raise(Nn.PrivateElementHasAccessibility, {
                      at: e,
                      modifier: e.accessibility,
                    }),
                  this.parseClassPropertyAnnotation(e),
                  Fe(N(r.prototype), "parseClassPrivateProperty", this).call(
                    this,
                    e
                  )
                );
              },
            },
            {
              key: "parseClassAccessorProperty",
              value: function (e) {
                return (
                  this.parseClassPropertyAnnotation(e),
                  e.optional &&
                    this.raise(Nn.AccessorCannotBeOptional, { at: e }),
                  Fe(N(r.prototype), "parseClassAccessorProperty", this).call(
                    this,
                    e
                  )
                );
              },
            },
            {
              key: "pushClassMethod",
              value: function (e, t, n, i, a, s) {
                var o = this.tsTryParseTypeParameters(
                  this.tsParseConstModifier
                );
                o &&
                  a &&
                  this.raise(Nn.ConstructorHasTypeParameters, { at: o });
                var l = t.declare,
                  u = void 0 !== l && l,
                  c = t.kind;
                !u ||
                  ("get" !== c && "set" !== c) ||
                  this.raise(Nn.DeclareAccessor, { at: t, kind: c }),
                  o && (t.typeParameters = o),
                  Fe(N(r.prototype), "pushClassMethod", this).call(
                    this,
                    e,
                    t,
                    n,
                    i,
                    a,
                    s
                  );
              },
            },
            {
              key: "pushClassPrivateMethod",
              value: function (e, t, n, i) {
                var a = this.tsTryParseTypeParameters(
                  this.tsParseConstModifier
                );
                a && (t.typeParameters = a),
                  Fe(N(r.prototype), "pushClassPrivateMethod", this).call(
                    this,
                    e,
                    t,
                    n,
                    i
                  );
              },
            },
            {
              key: "declareClassPrivateMethodInScope",
              value: function (e, t) {
                "TSDeclareMethod" !== e.type &&
                  ("MethodDefinition" !== e.type || e.value.body) &&
                  Fe(
                    N(r.prototype),
                    "declareClassPrivateMethodInScope",
                    this
                  ).call(this, e, t);
              },
            },
            {
              key: "parseClassSuper",
              value: function (e) {
                Fe(N(r.prototype), "parseClassSuper", this).call(this, e),
                  e.superClass &&
                    (this.match(47) || this.match(51)) &&
                    (e.superTypeParameters =
                      this.tsParseTypeArgumentsInExpression()),
                  this.eatContextual(111) &&
                    (e.implements = this.tsParseHeritageClause("implements"));
              },
            },
            {
              key: "parseObjPropValue",
              value: function (e, t, n, i, a, s, o) {
                var l = this.tsTryParseTypeParameters(
                  this.tsParseConstModifier
                );
                return (
                  l && (e.typeParameters = l),
                  Fe(N(r.prototype), "parseObjPropValue", this).call(
                    this,
                    e,
                    t,
                    n,
                    i,
                    a,
                    s,
                    o
                  )
                );
              },
            },
            {
              key: "parseFunctionParams",
              value: function (e, t) {
                var n = this.tsTryParseTypeParameters(
                  this.tsParseConstModifier
                );
                n && (e.typeParameters = n),
                  Fe(N(r.prototype), "parseFunctionParams", this).call(
                    this,
                    e,
                    t
                  );
              },
            },
            {
              key: "parseVarId",
              value: function (e, t) {
                Fe(N(r.prototype), "parseVarId", this).call(this, e, t),
                  "Identifier" === e.id.type &&
                    !this.hasPrecedingLineBreak() &&
                    this.eat(35) &&
                    (e.definite = !0);
                var n = this.tsTryParseTypeAnnotation();
                n && ((e.id.typeAnnotation = n), this.resetEndLocation(e.id));
              },
            },
            {
              key: "parseAsyncArrowFromCallExpression",
              value: function (e, t) {
                return (
                  this.match(14) &&
                    (e.returnType = this.tsParseTypeAnnotation()),
                  Fe(
                    N(r.prototype),
                    "parseAsyncArrowFromCallExpression",
                    this
                  ).call(this, e, t)
                );
              },
            },
            {
              key: "parseMaybeAssign",
              value: function (e, t) {
                var n,
                  i,
                  a,
                  s,
                  o,
                  l,
                  u,
                  c,
                  p,
                  h = this;
                if (
                  this.hasPlugin("jsx") &&
                  (this.match(140) || this.match(47))
                ) {
                  if (
                    ((l = this.state.clone()),
                    !(u = this.tryParse(function () {
                      return Fe(N(r.prototype), "parseMaybeAssign", h).call(
                        h,
                        e,
                        t
                      );
                    }, l)).error)
                  )
                    return u.node;
                  var d = this.state.context,
                    f = d[d.length - 1];
                  (f !== mt.j_oTag && f !== mt.j_expr) || d.pop();
                }
                if (!((null != (n = u) && n.error) || this.match(47)))
                  return Fe(N(r.prototype), "parseMaybeAssign", this).call(
                    this,
                    e,
                    t
                  );
                (l && l !== this.state) || (l = this.state.clone());
                var y = this.tryParse(function (n) {
                  var i, a;
                  p = h.tsParseTypeParameters(h.tsParseConstModifier);
                  var s = Fe(N(r.prototype), "parseMaybeAssign", h).call(
                    h,
                    e,
                    t
                  );
                  return (
                    ("ArrowFunctionExpression" !== s.type ||
                      (null != (i = s.extra) && i.parenthesized)) &&
                      n(),
                    0 !== (null == (a = p) ? void 0 : a.params.length) &&
                      h.resetStartLocationFromNode(s, p),
                    (s.typeParameters = p),
                    s
                  );
                }, l);
                if (!y.error && !y.aborted)
                  return p && this.reportReservedArrowTypeParam(p), y.node;
                if (
                  !u &&
                  (On(!this.hasPlugin("jsx")),
                  !(c = this.tryParse(function () {
                    return Fe(N(r.prototype), "parseMaybeAssign", h).call(
                      h,
                      e,
                      t
                    );
                  }, l)).error)
                )
                  return c.node;
                if (null != (i = u) && i.node)
                  return (this.state = u.failState), u.node;
                if (y.node)
                  return (
                    (this.state = y.failState),
                    p && this.reportReservedArrowTypeParam(p),
                    y.node
                  );
                if (null != (a = c) && a.node)
                  return (this.state = c.failState), c.node;
                throw (
                  (null == (s = u) ? void 0 : s.error) ||
                  y.error ||
                  (null == (o = c) ? void 0 : o.error)
                );
              },
            },
            {
              key: "reportReservedArrowTypeParam",
              value: function (e) {
                var t;
                1 !== e.params.length ||
                  e.params[0].constraint ||
                  (null != (t = e.extra) && t.trailingComma) ||
                  !this.getPluginOption(
                    "typescript",
                    "disallowAmbiguousJSXLike"
                  ) ||
                  this.raise(Nn.ReservedArrowTypeParam, { at: e });
              },
            },
            {
              key: "parseMaybeUnary",
              value: function (e, t) {
                return !this.hasPlugin("jsx") && this.match(47)
                  ? this.tsParseTypeAssertion()
                  : Fe(N(r.prototype), "parseMaybeUnary", this).call(
                      this,
                      e,
                      t
                    );
              },
            },
            {
              key: "parseArrow",
              value: function (e) {
                var t = this;
                if (this.match(14)) {
                  var n = this.tryParse(function (e) {
                    var r = t.tsParseTypeOrTypePredicateAnnotation(14);
                    return (!t.canInsertSemicolon() && t.match(19)) || e(), r;
                  });
                  if (n.aborted) return;
                  n.thrown ||
                    (n.error && (this.state = n.failState),
                    (e.returnType = n.node));
                }
                return Fe(N(r.prototype), "parseArrow", this).call(this, e);
              },
            },
            {
              key: "parseAssignableListItemTypes",
              value: function (e, t) {
                if (!(2 & t)) return e;
                this.eat(17) && (e.optional = !0);
                var r = this.tsTryParseTypeAnnotation();
                return r && (e.typeAnnotation = r), this.resetEndLocation(e), e;
              },
            },
            {
              key: "isAssignable",
              value: function (e, t) {
                switch (e.type) {
                  case "TSTypeCastExpression":
                    return this.isAssignable(e.expression, t);
                  case "TSParameterProperty":
                    return !0;
                  default:
                    return Fe(N(r.prototype), "isAssignable", this).call(
                      this,
                      e,
                      t
                    );
                }
              },
            },
            {
              key: "toAssignable",
              value: function (e) {
                var t =
                  arguments.length > 1 &&
                  void 0 !== arguments[1] &&
                  arguments[1];
                switch (e.type) {
                  case "ParenthesizedExpression":
                    this.toAssignableParenthesizedExpression(e, t);
                    break;
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "TSTypeAssertion":
                    t
                      ? this.expressionScope.recordArrowParameterBindingError(
                          Nn.UnexpectedTypeCastInParameter,
                          { at: e }
                        )
                      : this.raise(Nn.UnexpectedTypeCastInParameter, { at: e }),
                      this.toAssignable(e.expression, t);
                    break;
                  case "AssignmentExpression":
                    t ||
                      "TSTypeCastExpression" !== e.left.type ||
                      (e.left = this.typeCastToParameter(e.left));
                  default:
                    Fe(N(r.prototype), "toAssignable", this).call(this, e, t);
                }
              },
            },
            {
              key: "toAssignableParenthesizedExpression",
              value: function (e, t) {
                switch (e.expression.type) {
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSNonNullExpression":
                  case "TSTypeAssertion":
                  case "ParenthesizedExpression":
                    this.toAssignable(e.expression, t);
                    break;
                  default:
                    Fe(N(r.prototype), "toAssignable", this).call(this, e, t);
                }
              },
            },
            {
              key: "checkToRestConversion",
              value: function (e, t) {
                switch (e.type) {
                  case "TSAsExpression":
                  case "TSSatisfiesExpression":
                  case "TSTypeAssertion":
                  case "TSNonNullExpression":
                    this.checkToRestConversion(e.expression, !1);
                    break;
                  default:
                    Fe(N(r.prototype), "checkToRestConversion", this).call(
                      this,
                      e,
                      t
                    );
                }
              },
            },
            {
              key: "isValidLVal",
              value: function (e, t, n) {
                return (
                  (function (e, t) {
                    return Object.hasOwnProperty.call(e, t) && e[t];
                  })(
                    {
                      TSTypeCastExpression: !0,
                      TSParameterProperty: "parameter",
                      TSNonNullExpression: "expression",
                      TSAsExpression: (n !== Sr || !t) && ["expression", !0],
                      TSSatisfiesExpression: (n !== Sr || !t) && [
                        "expression",
                        !0,
                      ],
                      TSTypeAssertion: (n !== Sr || !t) && ["expression", !0],
                    },
                    e
                  ) ||
                  Fe(N(r.prototype), "isValidLVal", this).call(this, e, t, n)
                );
              },
            },
            {
              key: "parseBindingAtom",
              value: function () {
                return 78 === this.state.type
                  ? this.parseIdentifier(!0)
                  : Fe(N(r.prototype), "parseBindingAtom", this).call(this);
              },
            },
            {
              key: "parseMaybeDecoratorArguments",
              value: function (e) {
                if (this.match(47) || this.match(51)) {
                  var t = this.tsParseTypeArgumentsInExpression();
                  if (this.match(10)) {
                    var n = Fe(
                      N(r.prototype),
                      "parseMaybeDecoratorArguments",
                      this
                    ).call(this, e);
                    return (n.typeParameters = t), n;
                  }
                  this.unexpected(null, 10);
                }
                return Fe(
                  N(r.prototype),
                  "parseMaybeDecoratorArguments",
                  this
                ).call(this, e);
              },
            },
            {
              key: "checkCommaAfterRest",
              value: function (e) {
                return this.state.isAmbientContext &&
                  this.match(12) &&
                  this.lookaheadCharCode() === e
                  ? (this.next(), !1)
                  : Fe(N(r.prototype), "checkCommaAfterRest", this).call(
                      this,
                      e
                    );
              },
            },
            {
              key: "isClassMethod",
              value: function () {
                return (
                  this.match(47) ||
                  Fe(N(r.prototype), "isClassMethod", this).call(this)
                );
              },
            },
            {
              key: "isClassProperty",
              value: function () {
                return (
                  this.match(35) ||
                  this.match(14) ||
                  Fe(N(r.prototype), "isClassProperty", this).call(this)
                );
              },
            },
            {
              key: "parseMaybeDefault",
              value: function (e, t) {
                var n = Fe(N(r.prototype), "parseMaybeDefault", this).call(
                  this,
                  e,
                  t
                );
                return (
                  "AssignmentPattern" === n.type &&
                    n.typeAnnotation &&
                    n.right.start < n.typeAnnotation.start &&
                    this.raise(Nn.TypeAnnotationAfterAssign, {
                      at: n.typeAnnotation,
                    }),
                  n
                );
              },
            },
            {
              key: "getTokenFromCode",
              value: function (e) {
                if (this.state.inType) {
                  if (62 === e) return void this.finishOp(48, 1);
                  if (60 === e) return void this.finishOp(47, 1);
                }
                Fe(N(r.prototype), "getTokenFromCode", this).call(this, e);
              },
            },
            {
              key: "reScan_lt_gt",
              value: function () {
                var e = this.state.type;
                47 === e
                  ? ((this.state.pos -= 1), this.readToken_lt())
                  : 48 === e && ((this.state.pos -= 1), this.readToken_gt());
              },
            },
            {
              key: "reScan_lt",
              value: function () {
                var e = this.state.type;
                return 51 === e
                  ? ((this.state.pos -= 2), this.finishOp(47, 1), 47)
                  : e;
              },
            },
            {
              key: "toAssignableList",
              value: function (e, t, n) {
                for (var i = 0; i < e.length; i++) {
                  var a = e[i];
                  "TSTypeCastExpression" === (null == a ? void 0 : a.type) &&
                    (e[i] = this.typeCastToParameter(a));
                }
                Fe(N(r.prototype), "toAssignableList", this).call(
                  this,
                  e,
                  t,
                  n
                );
              },
            },
            {
              key: "typeCastToParameter",
              value: function (e) {
                return (
                  (e.expression.typeAnnotation = e.typeAnnotation),
                  this.resetEndLocation(e.expression, e.typeAnnotation.loc.end),
                  e.expression
                );
              },
            },
            {
              key: "shouldParseArrow",
              value: function (e) {
                var t = this;
                return this.match(14)
                  ? e.every(function (e) {
                      return t.isAssignable(e, !0);
                    })
                  : Fe(N(r.prototype), "shouldParseArrow", this).call(this, e);
              },
            },
            {
              key: "shouldParseAsyncArrow",
              value: function () {
                return (
                  this.match(14) ||
                  Fe(N(r.prototype), "shouldParseAsyncArrow", this).call(this)
                );
              },
            },
            {
              key: "canHaveLeadingDecorator",
              value: function () {
                return (
                  Fe(N(r.prototype), "canHaveLeadingDecorator", this).call(
                    this
                  ) || this.isAbstractClass()
                );
              },
            },
            {
              key: "jsxParseOpeningElementAfterName",
              value: function (e) {
                var t = this;
                if (this.match(47) || this.match(51)) {
                  var n = this.tsTryParseAndCatch(function () {
                    return t.tsParseTypeArgumentsInExpression();
                  });
                  n && (e.typeParameters = n);
                }
                return Fe(
                  N(r.prototype),
                  "jsxParseOpeningElementAfterName",
                  this
                ).call(this, e);
              },
            },
            {
              key: "getGetterSetterExpectedParamCount",
              value: function (e) {
                var t = Fe(
                    N(r.prototype),
                    "getGetterSetterExpectedParamCount",
                    this
                  ).call(this, e),
                  n = this.getObjectOrClassMethodParams(e)[0];
                return n && this.isThisParam(n) ? t + 1 : t;
              },
            },
            {
              key: "parseCatchClauseParam",
              value: function () {
                var e = Fe(N(r.prototype), "parseCatchClauseParam", this).call(
                    this
                  ),
                  t = this.tsTryParseTypeAnnotation();
                return (
                  t && ((e.typeAnnotation = t), this.resetEndLocation(e)), e
                );
              },
            },
            {
              key: "tsInAmbientContext",
              value: function (e) {
                var t = this.state.isAmbientContext;
                this.state.isAmbientContext = !0;
                try {
                  return e();
                } finally {
                  this.state.isAmbientContext = t;
                }
              },
            },
            {
              key: "parseClass",
              value: function (e, t, n) {
                var i = this.state.inAbstractClass;
                this.state.inAbstractClass = !!e.abstract;
                try {
                  return Fe(N(r.prototype), "parseClass", this).call(
                    this,
                    e,
                    t,
                    n
                  );
                } finally {
                  this.state.inAbstractClass = i;
                }
              },
            },
            {
              key: "tsParseAbstractDeclaration",
              value: function (e, t) {
                if (this.match(80))
                  return (
                    (e.abstract = !0),
                    this.maybeTakeDecorators(t, this.parseClass(e, !0, !1))
                  );
                if (this.isContextual(127)) {
                  if (!this.hasFollowingLineBreak())
                    return (
                      (e.abstract = !0),
                      this.raise(Nn.NonClassMethodPropertyHasAbstractModifer, {
                        at: e,
                      }),
                      this.tsParseInterfaceDeclaration(e)
                    );
                } else this.unexpected(null, 80);
              },
            },
            {
              key: "parseMethod",
              value: function (e, t, n, i, a, s, o) {
                var l = Fe(N(r.prototype), "parseMethod", this).call(
                  this,
                  e,
                  t,
                  n,
                  i,
                  a,
                  s,
                  o
                );
                if (
                  l.abstract &&
                  (this.hasPlugin("estree") ? !!l.value.body : !!l.body)
                ) {
                  var u = l.key;
                  this.raise(Nn.AbstractMethodHasImplementation, {
                    at: l,
                    methodName:
                      "Identifier" !== u.type || l.computed
                        ? "[".concat(this.input.slice(u.start, u.end), "]")
                        : u.name,
                  });
                }
                return l;
              },
            },
            {
              key: "tsParseTypeParameterName",
              value: function () {
                return this.parseIdentifier().name;
              },
            },
            {
              key: "shouldParseAsAmbientContext",
              value: function () {
                return !!this.getPluginOption("typescript", "dts");
              },
            },
            {
              key: "parse",
              value: function () {
                return (
                  this.shouldParseAsAmbientContext() &&
                    (this.state.isAmbientContext = !0),
                  Fe(N(r.prototype), "parse", this).call(this)
                );
              },
            },
            {
              key: "getExpression",
              value: function () {
                return (
                  this.shouldParseAsAmbientContext() &&
                    (this.state.isAmbientContext = !0),
                  Fe(N(r.prototype), "getExpression", this).call(this)
                );
              },
            },
            {
              key: "parseExportSpecifier",
              value: function (e, t, n, i) {
                return !t && i
                  ? (this.parseTypeOnlyImportExportSpecifier(e, !1, n),
                    this.finishNode(e, "ExportSpecifier"))
                  : ((e.exportKind = "value"),
                    Fe(N(r.prototype), "parseExportSpecifier", this).call(
                      this,
                      e,
                      t,
                      n,
                      i
                    ));
              },
            },
            {
              key: "parseImportSpecifier",
              value: function (e, t, n, i, a) {
                return !t && i
                  ? (this.parseTypeOnlyImportExportSpecifier(e, !0, n),
                    this.finishNode(e, "ImportSpecifier"))
                  : ((e.importKind = "value"),
                    Fe(N(r.prototype), "parseImportSpecifier", this).call(
                      this,
                      e,
                      t,
                      n,
                      i,
                      n ? 4098 : gr
                    ));
              },
            },
            {
              key: "parseTypeOnlyImportExportSpecifier",
              value: function (e, t, r) {
                var n,
                  i = t ? "imported" : "local",
                  a = t ? "local" : "exported",
                  s = e[i],
                  o = !1,
                  l = !0,
                  u = s.loc.start;
                if (this.isContextual(93)) {
                  var c = this.parseIdentifier();
                  if (this.isContextual(93)) {
                    var p = this.parseIdentifier();
                    Ft(this.state.type)
                      ? ((o = !0),
                        (s = c),
                        (n = t
                          ? this.parseIdentifier()
                          : this.parseModuleExportName()),
                        (l = !1))
                      : ((n = p), (l = !1));
                  } else
                    Ft(this.state.type)
                      ? ((l = !1),
                        (n = t
                          ? this.parseIdentifier()
                          : this.parseModuleExportName()))
                      : ((o = !0), (s = c));
                } else
                  Ft(this.state.type) &&
                    ((o = !0),
                    t
                      ? ((s = this.parseIdentifier(!0)),
                        this.isContextual(93) ||
                          this.checkReservedWord(s.name, s.loc.start, !0, !0))
                      : (s = this.parseModuleExportName()));
                o &&
                  r &&
                  this.raise(
                    t
                      ? Nn.TypeModifierIsUsedInTypeImports
                      : Nn.TypeModifierIsUsedInTypeExports,
                    { at: u }
                  ),
                  (e[i] = s),
                  (e[a] = n),
                  (e[t ? "importKind" : "exportKind"] = o ? "type" : "value"),
                  l &&
                    this.eatContextual(93) &&
                    (e[a] = t
                      ? this.parseIdentifier()
                      : this.parseModuleExportName()),
                  e[a] || (e[a] = dn(e[i])),
                  t && this.checkIdentifier(e[a], o ? 4098 : gr);
              },
            },
          ]),
          r
        );
      })(e);
    },
    v8intrinsic: function (e) {
      return (function (e) {
        I(r, e);
        var t = Je(r);
        function r() {
          return E(this, r), t.apply(this, arguments);
        }
        return (
          A(r, [
            {
              key: "parseV8Intrinsic",
              value: function () {
                if (this.match(54)) {
                  var e = this.state.startLoc,
                    t = this.startNode();
                  if ((this.next(), jt(this.state.type))) {
                    var r = this.parseIdentifierName(),
                      n = this.createIdentifier(t, r);
                    if (((n.type = "V8IntrinsicIdentifier"), this.match(10)))
                      return n;
                  }
                  this.unexpected(e);
                }
              },
            },
            {
              key: "parseExprAtom",
              value: function (e) {
                return (
                  this.parseV8Intrinsic() ||
                  Fe(N(r.prototype), "parseExprAtom", this).call(this, e)
                );
              },
            },
          ]),
          r
        );
      })(e);
    },
    placeholders: function (e) {
      return (function (e) {
        I(r, e);
        var t = Je(r);
        function r() {
          return E(this, r), t.apply(this, arguments);
        }
        return (
          A(r, [
            {
              key: "parsePlaceholder",
              value: function (e) {
                if (this.match(142)) {
                  var t = this.startNode();
                  return (
                    this.next(),
                    this.assertNoSpace(),
                    (t.name = Fe(N(r.prototype), "parseIdentifier", this).call(
                      this,
                      !0
                    )),
                    this.assertNoSpace(),
                    this.expect(142),
                    this.finishPlaceholder(t, e)
                  );
                }
              },
            },
            {
              key: "finishPlaceholder",
              value: function (e, t) {
                var r = !(!e.expectedNode || "Placeholder" !== e.type);
                return (
                  (e.expectedNode = t),
                  r ? e : this.finishNode(e, "Placeholder")
                );
              },
            },
            {
              key: "getTokenFromCode",
              value: function (e) {
                37 === e && 37 === this.input.charCodeAt(this.state.pos + 1)
                  ? this.finishOp(142, 2)
                  : Fe(N(r.prototype), "getTokenFromCode", this).call(this, e);
              },
            },
            {
              key: "parseExprAtom",
              value: function (e) {
                return (
                  this.parsePlaceholder("Expression") ||
                  Fe(N(r.prototype), "parseExprAtom", this).call(this, e)
                );
              },
            },
            {
              key: "parseIdentifier",
              value: function (e) {
                return (
                  this.parsePlaceholder("Identifier") ||
                  Fe(N(r.prototype), "parseIdentifier", this).call(this, e)
                );
              },
            },
            {
              key: "checkReservedWord",
              value: function (e, t, n, i) {
                void 0 !== e &&
                  Fe(N(r.prototype), "checkReservedWord", this).call(
                    this,
                    e,
                    t,
                    n,
                    i
                  );
              },
            },
            {
              key: "parseBindingAtom",
              value: function () {
                return (
                  this.parsePlaceholder("Pattern") ||
                  Fe(N(r.prototype), "parseBindingAtom", this).call(this)
                );
              },
            },
            {
              key: "isValidLVal",
              value: function (e, t, n) {
                return (
                  "Placeholder" === e ||
                  Fe(N(r.prototype), "isValidLVal", this).call(this, e, t, n)
                );
              },
            },
            {
              key: "toAssignable",
              value: function (e, t) {
                e && "Placeholder" === e.type && "Expression" === e.expectedNode
                  ? (e.expectedNode = "Pattern")
                  : Fe(N(r.prototype), "toAssignable", this).call(this, e, t);
              },
            },
            {
              key: "chStartsBindingIdentifier",
              value: function (e, t) {
                return (
                  !!Fe(N(r.prototype), "chStartsBindingIdentifier", this).call(
                    this,
                    e,
                    t
                  ) || 142 === this.lookahead().type
                );
              },
            },
            {
              key: "verifyBreakContinue",
              value: function (e, t) {
                (e.label && "Placeholder" === e.label.type) ||
                  Fe(N(r.prototype), "verifyBreakContinue", this).call(
                    this,
                    e,
                    t
                  );
              },
            },
            {
              key: "parseExpressionStatement",
              value: function (e, t) {
                if (
                  "Placeholder" !== t.type ||
                  (t.extra && t.extra.parenthesized)
                )
                  return Fe(
                    N(r.prototype),
                    "parseExpressionStatement",
                    this
                  ).call(this, e, t);
                if (this.match(14)) {
                  var n = e;
                  return (
                    (n.label = this.finishPlaceholder(t, "Identifier")),
                    this.next(),
                    (n.body = Fe(
                      N(r.prototype),
                      "parseStatementOrSloppyAnnexBFunctionDeclaration",
                      this
                    ).call(this)),
                    this.finishNode(n, "LabeledStatement")
                  );
                }
                return (
                  this.semicolon(),
                  (e.name = t.name),
                  this.finishPlaceholder(e, "Statement")
                );
              },
            },
            {
              key: "parseBlock",
              value: function (e, t, n) {
                return (
                  this.parsePlaceholder("BlockStatement") ||
                  Fe(N(r.prototype), "parseBlock", this).call(this, e, t, n)
                );
              },
            },
            {
              key: "parseFunctionId",
              value: function (e) {
                return (
                  this.parsePlaceholder("Identifier") ||
                  Fe(N(r.prototype), "parseFunctionId", this).call(this, e)
                );
              },
            },
            {
              key: "parseClass",
              value: function (e, t, n) {
                var i = t ? "ClassDeclaration" : "ClassExpression";
                this.next();
                var a = this.state.strict,
                  s = this.parsePlaceholder("Identifier");
                if (s) {
                  if (!(this.match(81) || this.match(142) || this.match(5))) {
                    if (n || !t)
                      return (
                        (e.id = null),
                        (e.body = this.finishPlaceholder(s, "ClassBody")),
                        this.finishNode(e, i)
                      );
                    throw this.raise(Bn.ClassNameIsRequired, {
                      at: this.state.startLoc,
                    });
                  }
                  e.id = s;
                } else this.parseClassId(e, t, n);
                return (
                  Fe(N(r.prototype), "parseClassSuper", this).call(this, e),
                  (e.body =
                    this.parsePlaceholder("ClassBody") ||
                    Fe(N(r.prototype), "parseClassBody", this).call(
                      this,
                      !!e.superClass,
                      a
                    )),
                  this.finishNode(e, i)
                );
              },
            },
            {
              key: "parseExport",
              value: function (e, t) {
                var n = this.parsePlaceholder("Identifier");
                if (!n)
                  return Fe(N(r.prototype), "parseExport", this).call(
                    this,
                    e,
                    t
                  );
                if (!this.isContextual(97) && !this.match(12))
                  return (
                    (e.specifiers = []),
                    (e.source = null),
                    (e.declaration = this.finishPlaceholder(n, "Declaration")),
                    this.finishNode(e, "ExportNamedDeclaration")
                  );
                this.expectPlugin("exportDefaultFrom");
                var i = this.startNode();
                return (
                  (i.exported = n),
                  (e.specifiers = [
                    this.finishNode(i, "ExportDefaultSpecifier"),
                  ]),
                  Fe(N(r.prototype), "parseExport", this).call(this, e, t)
                );
              },
            },
            {
              key: "isExportDefaultSpecifier",
              value: function () {
                if (this.match(65)) {
                  var e = this.nextTokenStart();
                  if (
                    this.isUnparsedContextual(e, "from") &&
                    this.input.startsWith(
                      Kt(142),
                      this.nextTokenStartSince(e + 4)
                    )
                  )
                    return !0;
                }
                return Fe(
                  N(r.prototype),
                  "isExportDefaultSpecifier",
                  this
                ).call(this);
              },
            },
            {
              key: "maybeParseExportDefaultSpecifier",
              value: function (e) {
                return (
                  !!(e.specifiers && e.specifiers.length > 0) ||
                  Fe(
                    N(r.prototype),
                    "maybeParseExportDefaultSpecifier",
                    this
                  ).call(this, e)
                );
              },
            },
            {
              key: "checkExport",
              value: function (e) {
                var t = e.specifiers;
                null != t &&
                  t.length &&
                  (e.specifiers = t.filter(function (e) {
                    return "Placeholder" === e.exported.type;
                  })),
                  Fe(N(r.prototype), "checkExport", this).call(this, e),
                  (e.specifiers = t);
              },
            },
            {
              key: "parseImport",
              value: function (e) {
                var t = this.parsePlaceholder("Identifier");
                if (!t)
                  return Fe(N(r.prototype), "parseImport", this).call(this, e);
                if (
                  ((e.specifiers = []),
                  !this.isContextual(97) && !this.match(12))
                )
                  return (
                    (e.source = this.finishPlaceholder(t, "StringLiteral")),
                    this.semicolon(),
                    this.finishNode(e, "ImportDeclaration")
                  );
                var n = this.startNodeAtNode(t);
                ((n.local = t),
                e.specifiers.push(this.finishNode(n, "ImportDefaultSpecifier")),
                this.eat(12)) &&
                  (this.maybeParseStarImportSpecifier(e) ||
                    this.parseNamedImportSpecifiers(e));
                return (
                  this.expectContextual(97),
                  (e.source = this.parseImportSource()),
                  this.semicolon(),
                  this.finishNode(e, "ImportDeclaration")
                );
              },
            },
            {
              key: "parseImportSource",
              value: function () {
                return (
                  this.parsePlaceholder("StringLiteral") ||
                  Fe(N(r.prototype), "parseImportSource", this).call(this)
                );
              },
            },
            {
              key: "assertNoSpace",
              value: function () {
                this.state.start > this.state.lastTokEndLoc.index &&
                  this.raise(Bn.UnexpectedSpace, {
                    at: this.state.lastTokEndLoc,
                  });
              },
            },
          ]),
          r
        );
      })(e);
    },
  },
  Hn = Object.keys(qn),
  Yn = {
    sourceType: "script",
    sourceFilename: void 0,
    startColumn: 0,
    startLine: 1,
    allowAwaitOutsideFunction: !1,
    allowReturnOutsideFunction: !1,
    allowNewTargetOutsideFunction: !1,
    allowImportExportEverywhere: !1,
    allowSuperOutsideMethod: !1,
    allowUndeclaredExports: !1,
    plugins: [],
    strictMode: null,
    ranges: !1,
    tokens: !1,
    createParenthesizedExpressions: !1,
    errorRecovery: !1,
    attachComment: !0,
    annexB: !0,
  };
var Jn = (function (e) {
    I(r, In);
    var t = Je(r);
    function r() {
      return E(this, r), t.apply(this, arguments);
    }
    return (
      A(r, [
        {
          key: "checkProto",
          value: function (e, t, r, n) {
            if (
              !(
                "SpreadElement" === e.type ||
                this.isObjectMethod(e) ||
                e.computed ||
                e.shorthand
              )
            ) {
              var i = e.key;
              if (
                "__proto__" === ("Identifier" === i.type ? i.name : i.value)
              ) {
                if (t) return void this.raise(pt.RecordNoProto, { at: i });
                r.used &&
                  (n
                    ? null === n.doubleProtoLoc &&
                      (n.doubleProtoLoc = i.loc.start)
                    : this.raise(pt.DuplicateProto, { at: i })),
                  (r.used = !0);
              }
            }
          },
        },
        {
          key: "shouldExitDescending",
          value: function (e, t) {
            return "ArrowFunctionExpression" === e.type && e.start === t;
          },
        },
        {
          key: "getExpression",
          value: function () {
            this.enterInitialScopes(), this.nextToken();
            var e = this.parseExpression();
            return (
              this.match(137) || this.unexpected(),
              this.finalizeRemainingComments(),
              (e.comments = this.state.comments),
              (e.errors = this.state.errors),
              this.options.tokens && (e.tokens = this.tokens),
              e
            );
          },
        },
        {
          key: "parseExpression",
          value: function (e, t) {
            var r = this;
            return e
              ? this.disallowInAnd(function () {
                  return r.parseExpressionBase(t);
                })
              : this.allowInAnd(function () {
                  return r.parseExpressionBase(t);
                });
          },
        },
        {
          key: "parseExpressionBase",
          value: function (e) {
            var t = this.state.startLoc,
              r = this.parseMaybeAssign(e);
            if (this.match(12)) {
              var n = this.startNodeAt(t);
              for (n.expressions = [r]; this.eat(12); )
                n.expressions.push(this.parseMaybeAssign(e));
              return (
                this.toReferencedList(n.expressions),
                this.finishNode(n, "SequenceExpression")
              );
            }
            return r;
          },
        },
        {
          key: "parseMaybeAssignDisallowIn",
          value: function (e, t) {
            var r = this;
            return this.disallowInAnd(function () {
              return r.parseMaybeAssign(e, t);
            });
          },
        },
        {
          key: "parseMaybeAssignAllowIn",
          value: function (e, t) {
            var r = this;
            return this.allowInAnd(function () {
              return r.parseMaybeAssign(e, t);
            });
          },
        },
        {
          key: "setOptionalParametersError",
          value: function (e, t) {
            var r;
            e.optionalParametersLoc =
              null != (r = null == t ? void 0 : t.loc)
                ? r
                : this.state.startLoc;
          },
        },
        {
          key: "parseMaybeAssign",
          value: function (e, t) {
            var r,
              n = this.state.startLoc;
            if (this.isContextual(106) && this.prodParam.hasYield) {
              var i = this.parseYield();
              return t && (i = t.call(this, i, n)), i;
            }
            e ? (r = !1) : ((e = new cn()), (r = !0));
            var a = this.state.type;
            (10 === a || jt(a)) &&
              (this.state.potentialArrowAt = this.state.start);
            var s,
              o = this.parseMaybeConditional(e);
            if (
              (t && (o = t.call(this, o, n)),
              (s = this.state.type) >= 29 && s <= 33)
            ) {
              var l = this.startNodeAt(n),
                u = this.state.value;
              if (((l.operator = u), this.match(29))) {
                this.toAssignable(o, !0), (l.left = o);
                var c = n.index;
                null != e.doubleProtoLoc &&
                  e.doubleProtoLoc.index >= c &&
                  (e.doubleProtoLoc = null),
                  null != e.shorthandAssignLoc &&
                    e.shorthandAssignLoc.index >= c &&
                    (e.shorthandAssignLoc = null),
                  null != e.privateKeyLoc &&
                    e.privateKeyLoc.index >= c &&
                    (this.checkDestructuringPrivate(e),
                    (e.privateKeyLoc = null));
              } else l.left = o;
              return (
                this.next(),
                (l.right = this.parseMaybeAssign()),
                this.checkLVal(o, {
                  in: this.finishNode(l, "AssignmentExpression"),
                }),
                l
              );
            }
            return r && this.checkExpressionErrors(e, !0), o;
          },
        },
        {
          key: "parseMaybeConditional",
          value: function (e) {
            var t = this.state.startLoc,
              r = this.state.potentialArrowAt,
              n = this.parseExprOps(e);
            return this.shouldExitDescending(n, r)
              ? n
              : this.parseConditional(n, t, e);
          },
        },
        {
          key: "parseConditional",
          value: function (e, t, r) {
            if (this.eat(17)) {
              var n = this.startNodeAt(t);
              return (
                (n.test = e),
                (n.consequent = this.parseMaybeAssignAllowIn()),
                this.expect(14),
                (n.alternate = this.parseMaybeAssign()),
                this.finishNode(n, "ConditionalExpression")
              );
            }
            return e;
          },
        },
        {
          key: "parseMaybeUnaryOrPrivate",
          value: function (e) {
            return this.match(136)
              ? this.parsePrivateName()
              : this.parseMaybeUnary(e);
          },
        },
        {
          key: "parseExprOps",
          value: function (e) {
            var t = this.state.startLoc,
              r = this.state.potentialArrowAt,
              n = this.parseMaybeUnaryOrPrivate(e);
            return this.shouldExitDescending(n, r)
              ? n
              : this.parseExprOp(n, t, -1);
          },
        },
        {
          key: "parseExprOp",
          value: function (e, t, r) {
            if (this.isPrivateName(e)) {
              var n = this.getPrivateNameSV(e);
              (r >= Wt(58) || !this.prodParam.hasIn || !this.match(58)) &&
                this.raise(pt.PrivateInExpectedIn, {
                  at: e,
                  identifierName: n,
                }),
                this.classScope.usePrivateName(n, e.loc.start);
            }
            var i,
              a = this.state.type;
            if (
              (i = a) >= 39 &&
              i <= 59 &&
              (this.prodParam.hasIn || !this.match(58))
            ) {
              var s = Wt(a);
              if (s > r) {
                if (39 === a) {
                  if (
                    (this.expectPlugin("pipelineOperator"),
                    this.state.inFSharpPipelineDirectBody)
                  )
                    return e;
                  this.checkPipelineAtInfixOperator(e, t);
                }
                var o = this.startNodeAt(t);
                (o.left = e), (o.operator = this.state.value);
                var l = 41 === a || 42 === a,
                  u = 40 === a;
                if (
                  (u && (s = Wt(42)),
                  this.next(),
                  39 === a &&
                    this.hasPlugin([
                      "pipelineOperator",
                      { proposal: "minimal" },
                    ]) &&
                    96 === this.state.type &&
                    this.prodParam.hasAwait)
                )
                  throw this.raise(pt.UnexpectedAwaitAfterPipelineBody, {
                    at: this.state.startLoc,
                  });
                o.right = this.parseExprOpRightExpr(a, s);
                var c = this.finishNode(
                    o,
                    l || u ? "LogicalExpression" : "BinaryExpression"
                  ),
                  p = this.state.type;
                if ((u && (41 === p || 42 === p)) || (l && 40 === p))
                  throw this.raise(pt.MixingCoalesceWithLogical, {
                    at: this.state.startLoc,
                  });
                return this.parseExprOp(c, t, r);
              }
            }
            return e;
          },
        },
        {
          key: "parseExprOpRightExpr",
          value: function (e, t) {
            var r = this,
              n = this.state.startLoc;
            if (39 === e)
              switch (this.getPluginOption("pipelineOperator", "proposal")) {
                case "hack":
                  return this.withTopicBindingContext(function () {
                    return r.parseHackPipeBody();
                  });
                case "smart":
                  return this.withTopicBindingContext(function () {
                    if (r.prodParam.hasYield && r.isContextual(106))
                      throw r.raise(pt.PipeBodyIsTighter, {
                        at: r.state.startLoc,
                      });
                    return r.parseSmartPipelineBodyInStyle(
                      r.parseExprOpBaseRightExpr(e, t),
                      n
                    );
                  });
                case "fsharp":
                  return this.withSoloAwaitPermittingContext(function () {
                    return r.parseFSharpPipelineBody(t);
                  });
              }
            return this.parseExprOpBaseRightExpr(e, t);
          },
        },
        {
          key: "parseExprOpBaseRightExpr",
          value: function (e, t) {
            var r = this.state.startLoc;
            return this.parseExprOp(
              this.parseMaybeUnaryOrPrivate(),
              r,
              57 === e ? t - 1 : t
            );
          },
        },
        {
          key: "parseHackPipeBody",
          value: function () {
            var e,
              t = this.state.startLoc,
              r = this.parseMaybeAssign();
            return (
              !st.has(r.type) ||
                (null != (e = r.extra) && e.parenthesized) ||
                this.raise(pt.PipeUnparenthesizedBody, { at: t, type: r.type }),
              this.topicReferenceWasUsedInCurrentContext() ||
                this.raise(pt.PipeTopicUnused, { at: t }),
              r
            );
          },
        },
        {
          key: "checkExponentialAfterUnary",
          value: function (e) {
            this.match(57) &&
              this.raise(pt.UnexpectedTokenUnaryExponentiation, {
                at: e.argument,
              });
          },
        },
        {
          key: "parseMaybeUnary",
          value: function (e, t) {
            var r = this.state.startLoc,
              n = this.isContextual(96);
            if (n && this.isAwaitAllowed()) {
              this.next();
              var i = this.parseAwait(r);
              return t || this.checkExponentialAfterUnary(i), i;
            }
            var a,
              s = this.match(34),
              o = this.startNode();
            if (((a = this.state.type), _t[a])) {
              (o.operator = this.state.value),
                (o.prefix = !0),
                this.match(72) && this.expectPlugin("throwExpressions");
              var l = this.match(89);
              if (
                (this.next(),
                (o.argument = this.parseMaybeUnary(null, !0)),
                this.checkExpressionErrors(e, !0),
                this.state.strict && l)
              ) {
                var u = o.argument;
                "Identifier" === u.type
                  ? this.raise(pt.StrictDelete, { at: o })
                  : this.hasPropertyAsPrivateName(u) &&
                    this.raise(pt.DeletePrivateField, { at: o });
              }
              if (!s)
                return (
                  t || this.checkExponentialAfterUnary(o),
                  this.finishNode(o, "UnaryExpression")
                );
            }
            var c = this.parseUpdate(o, s, e);
            if (n) {
              var p = this.state.type;
              if (
                (this.hasPlugin("v8intrinsic")
                  ? Rt(p)
                  : Rt(p) && !this.match(54)) &&
                !this.isAmbiguousAwait()
              )
                return (
                  this.raiseOverwrite(pt.AwaitNotInAsyncContext, { at: r }),
                  this.parseAwait(r)
                );
            }
            return c;
          },
        },
        {
          key: "parseUpdate",
          value: function (e, t, r) {
            if (t) {
              var n = e;
              return (
                this.checkLVal(n.argument, {
                  in: this.finishNode(n, "UpdateExpression"),
                }),
                e
              );
            }
            var i = this.state.startLoc,
              a = this.parseExprSubscripts(r);
            if (this.checkExpressionErrors(r, !1)) return a;
            for (; 34 === this.state.type && !this.canInsertSemicolon(); ) {
              var s = this.startNodeAt(i);
              (s.operator = this.state.value),
                (s.prefix = !1),
                (s.argument = a),
                this.next(),
                this.checkLVal(a, {
                  in: (a = this.finishNode(s, "UpdateExpression")),
                });
            }
            return a;
          },
        },
        {
          key: "parseExprSubscripts",
          value: function (e) {
            var t = this.state.startLoc,
              r = this.state.potentialArrowAt,
              n = this.parseExprAtom(e);
            return this.shouldExitDescending(n, r)
              ? n
              : this.parseSubscripts(n, t);
          },
        },
        {
          key: "parseSubscripts",
          value: function (e, t, r) {
            var n = {
              optionalChainMember: !1,
              maybeAsyncArrow: this.atPossibleAsyncArrow(e),
              stop: !1,
            };
            do {
              (e = this.parseSubscript(e, t, r, n)), (n.maybeAsyncArrow = !1);
            } while (!n.stop);
            return e;
          },
        },
        {
          key: "parseSubscript",
          value: function (e, t, r, n) {
            var i = this.state.type;
            if (!r && 15 === i) return this.parseBind(e, t, r, n);
            if (qt(i)) return this.parseTaggedTemplateExpression(e, t, n);
            var a = !1;
            if (18 === i) {
              if (
                r &&
                (this.raise(pt.OptionalChainingNoNew, {
                  at: this.state.startLoc,
                }),
                40 === this.lookaheadCharCode())
              )
                return (n.stop = !0), e;
              (n.optionalChainMember = a = !0), this.next();
            }
            if (!r && this.match(10))
              return this.parseCoverCallAndAsyncArrowHead(e, t, n, a);
            var s = this.eat(0);
            return s || a || this.eat(16)
              ? this.parseMember(e, t, n, s, a)
              : ((n.stop = !0), e);
          },
        },
        {
          key: "parseMember",
          value: function (e, t, r, n, i) {
            var a = this.startNodeAt(t);
            return (
              (a.object = e),
              (a.computed = n),
              n
                ? ((a.property = this.parseExpression()), this.expect(3))
                : this.match(136)
                ? ("Super" === e.type &&
                    this.raise(pt.SuperPrivateField, { at: t }),
                  this.classScope.usePrivateName(
                    this.state.value,
                    this.state.startLoc
                  ),
                  (a.property = this.parsePrivateName()))
                : (a.property = this.parseIdentifier(!0)),
              r.optionalChainMember
                ? ((a.optional = i),
                  this.finishNode(a, "OptionalMemberExpression"))
                : this.finishNode(a, "MemberExpression")
            );
          },
        },
        {
          key: "parseBind",
          value: function (e, t, r, n) {
            var i = this.startNodeAt(t);
            return (
              (i.object = e),
              this.next(),
              (i.callee = this.parseNoCallExpr()),
              (n.stop = !0),
              this.parseSubscripts(this.finishNode(i, "BindExpression"), t, r)
            );
          },
        },
        {
          key: "parseCoverCallAndAsyncArrowHead",
          value: function (e, t, r, n) {
            var i = this.state.maybeInArrowParameters,
              a = null;
            (this.state.maybeInArrowParameters = !0), this.next();
            var s = this.startNodeAt(t);
            s.callee = e;
            var o = r.maybeAsyncArrow,
              l = r.optionalChainMember;
            o && (this.expressionScope.enter(new nn(2)), (a = new cn())),
              l && (s.optional = n),
              (s.arguments = n
                ? this.parseCallExpressionArguments(11)
                : this.parseCallExpressionArguments(
                    11,
                    "Import" === e.type,
                    "Super" !== e.type,
                    s,
                    a
                  ));
            var u = this.finishCallExpression(s, l);
            return (
              o && this.shouldParseAsyncArrow() && !n
                ? ((r.stop = !0),
                  this.checkDestructuringPrivate(a),
                  this.expressionScope.validateAsPattern(),
                  this.expressionScope.exit(),
                  (u = this.parseAsyncArrowFromCallExpression(
                    this.startNodeAt(t),
                    u
                  )))
                : (o &&
                    (this.checkExpressionErrors(a, !0),
                    this.expressionScope.exit()),
                  this.toReferencedArguments(u)),
              (this.state.maybeInArrowParameters = i),
              u
            );
          },
        },
        {
          key: "toReferencedArguments",
          value: function (e, t) {
            this.toReferencedListDeep(e.arguments, t);
          },
        },
        {
          key: "parseTaggedTemplateExpression",
          value: function (e, t, r) {
            var n = this.startNodeAt(t);
            return (
              (n.tag = e),
              (n.quasi = this.parseTemplate(!0)),
              r.optionalChainMember &&
                this.raise(pt.OptionalChainingNoTemplate, { at: t }),
              this.finishNode(n, "TaggedTemplateExpression")
            );
          },
        },
        {
          key: "atPossibleAsyncArrow",
          value: function (e) {
            return (
              "Identifier" === e.type &&
              "async" === e.name &&
              this.state.lastTokEndLoc.index === e.end &&
              !this.canInsertSemicolon() &&
              e.end - e.start == 5 &&
              e.start === this.state.potentialArrowAt
            );
          },
        },
        {
          key: "finishCallExpression",
          value: function (e, t) {
            if ("Import" === e.callee.type)
              if (
                (2 === e.arguments.length &&
                  (this.hasPlugin("moduleAttributes") ||
                    this.expectPlugin("importAssertions")),
                0 === e.arguments.length || e.arguments.length > 2)
              )
                this.raise(pt.ImportCallArity, {
                  at: e,
                  maxArgumentCount:
                    this.hasPlugin("importAssertions") ||
                    this.hasPlugin("moduleAttributes")
                      ? 2
                      : 1,
                });
              else {
                var r,
                  n = He(e.arguments);
                try {
                  for (n.s(); !(r = n.n()).done; ) {
                    var i = r.value;
                    "SpreadElement" === i.type &&
                      this.raise(pt.ImportCallSpreadArgument, { at: i });
                  }
                } catch (e) {
                  n.e(e);
                } finally {
                  n.f();
                }
              }
            return this.finishNode(
              e,
              t ? "OptionalCallExpression" : "CallExpression"
            );
          },
        },
        {
          key: "parseCallExpressionArguments",
          value: function (e, t, r, n, i) {
            var a = [],
              s = !0,
              o = this.state.inFSharpPipelineDirectBody;
            for (this.state.inFSharpPipelineDirectBody = !1; !this.eat(e); ) {
              if (s) s = !1;
              else if ((this.expect(12), this.match(e))) {
                !t ||
                  this.hasPlugin("importAssertions") ||
                  this.hasPlugin("moduleAttributes") ||
                  this.raise(pt.ImportCallArgumentTrailingComma, {
                    at: this.state.lastTokStartLoc,
                  }),
                  n && this.addTrailingCommaExtraToNode(n),
                  this.next();
                break;
              }
              a.push(this.parseExprListItem(!1, i, r));
            }
            return (this.state.inFSharpPipelineDirectBody = o), a;
          },
        },
        {
          key: "shouldParseAsyncArrow",
          value: function () {
            return this.match(19) && !this.canInsertSemicolon();
          },
        },
        {
          key: "parseAsyncArrowFromCallExpression",
          value: function (e, t) {
            var r;
            return (
              this.resetPreviousNodeTrailingComments(t),
              this.expect(19),
              this.parseArrowExpression(
                e,
                t.arguments,
                !0,
                null == (r = t.extra) ? void 0 : r.trailingCommaLoc
              ),
              t.innerComments && Cr(e, t.innerComments),
              t.callee.trailingComments && Cr(e, t.callee.trailingComments),
              e
            );
          },
        },
        {
          key: "parseNoCallExpr",
          value: function () {
            var e = this.state.startLoc;
            return this.parseSubscripts(this.parseExprAtom(), e, !0);
          },
        },
        {
          key: "parseExprAtom",
          value: function (e) {
            var t,
              r = null,
              n = this.state.type;
            switch (n) {
              case 79:
                return this.parseSuper();
              case 83:
                return (
                  (t = this.startNode()),
                  this.next(),
                  this.match(16)
                    ? this.parseImportMetaProperty(t)
                    : (this.match(10) ||
                        this.raise(pt.UnsupportedImport, {
                          at: this.state.lastTokStartLoc,
                        }),
                      this.finishNode(t, "Import"))
                );
              case 78:
                return (
                  (t = this.startNode()),
                  this.next(),
                  this.finishNode(t, "ThisExpression")
                );
              case 90:
                return this.parseDo(this.startNode(), !1);
              case 56:
              case 31:
                return (
                  this.readRegexp(), this.parseRegExpLiteral(this.state.value)
                );
              case 132:
                return this.parseNumericLiteral(this.state.value);
              case 133:
                return this.parseBigIntLiteral(this.state.value);
              case 134:
                return this.parseDecimalLiteral(this.state.value);
              case 131:
                return this.parseStringLiteral(this.state.value);
              case 84:
                return this.parseNullLiteral();
              case 85:
                return this.parseBooleanLiteral(!0);
              case 86:
                return this.parseBooleanLiteral(!1);
              case 10:
                var i = this.state.potentialArrowAt === this.state.start;
                return this.parseParenAndDistinguishExpression(i);
              case 2:
              case 1:
                return this.parseArrayLike(
                  2 === this.state.type ? 4 : 3,
                  !1,
                  !0
                );
              case 0:
                return this.parseArrayLike(3, !0, !1, e);
              case 6:
              case 7:
                return this.parseObjectLike(
                  6 === this.state.type ? 9 : 8,
                  !1,
                  !0
                );
              case 5:
                return this.parseObjectLike(8, !1, !1, e);
              case 68:
                return this.parseFunctionOrFunctionSent();
              case 26:
                r = this.parseDecorators();
              case 80:
                return this.parseClass(
                  this.maybeTakeDecorators(r, this.startNode()),
                  !1
                );
              case 77:
                return this.parseNewOrNewTarget();
              case 25:
              case 24:
                return this.parseTemplate(!1);
              case 15:
                (t = this.startNode()), this.next(), (t.object = null);
                var a = (t.callee = this.parseNoCallExpr());
                if ("MemberExpression" === a.type)
                  return this.finishNode(t, "BindExpression");
                throw this.raise(pt.UnsupportedBind, { at: a });
              case 136:
                return (
                  this.raise(pt.PrivateInExpectedIn, {
                    at: this.state.startLoc,
                    identifierName: this.state.value,
                  }),
                  this.parsePrivateName()
                );
              case 33:
                return this.parseTopicReferenceThenEqualsSign(54, "%");
              case 32:
                return this.parseTopicReferenceThenEqualsSign(44, "^");
              case 37:
              case 38:
                return this.parseTopicReference("hack");
              case 44:
              case 54:
              case 27:
                var s = this.getPluginOption("pipelineOperator", "proposal");
                if (s) return this.parseTopicReference(s);
                this.unexpected();
                break;
              case 47:
                var o = this.input.codePointAt(this.nextTokenStart());
                Zt(o) || 62 === o
                  ? this.expectOnePlugin(["jsx", "flow", "typescript"])
                  : this.unexpected();
                break;
              default:
                if (jt(n)) {
                  if (
                    this.isContextual(125) &&
                    123 === this.lookaheadInLineCharCode()
                  )
                    return this.parseModuleExpression();
                  var l = this.state.potentialArrowAt === this.state.start,
                    u = this.state.containsEsc,
                    c = this.parseIdentifier();
                  if (!u && "async" === c.name && !this.canInsertSemicolon()) {
                    var p = this.state.type;
                    if (68 === p)
                      return (
                        this.resetPreviousNodeTrailingComments(c),
                        this.next(),
                        this.parseAsyncFunctionExpression(
                          this.startNodeAtNode(c)
                        )
                      );
                    if (jt(p))
                      return 61 === this.lookaheadCharCode()
                        ? this.parseAsyncArrowUnaryFunction(
                            this.startNodeAtNode(c)
                          )
                        : c;
                    if (90 === p)
                      return (
                        this.resetPreviousNodeTrailingComments(c),
                        this.parseDo(this.startNodeAtNode(c), !0)
                      );
                  }
                  return l && this.match(19) && !this.canInsertSemicolon()
                    ? (this.next(),
                      this.parseArrowExpression(
                        this.startNodeAtNode(c),
                        [c],
                        !1
                      ))
                    : c;
                }
                this.unexpected();
            }
          },
        },
        {
          key: "parseTopicReferenceThenEqualsSign",
          value: function (e, t) {
            var r = this.getPluginOption("pipelineOperator", "proposal");
            if (r)
              return (
                (this.state.type = e),
                (this.state.value = t),
                this.state.pos--,
                this.state.end--,
                (this.state.endLoc = $e(this.state.endLoc, -1)),
                this.parseTopicReference(r)
              );
            this.unexpected();
          },
        },
        {
          key: "parseTopicReference",
          value: function (e) {
            var t = this.startNode(),
              r = this.state.startLoc,
              n = this.state.type;
            return this.next(), this.finishTopicReference(t, r, e, n);
          },
        },
        {
          key: "finishTopicReference",
          value: function (e, t, r, n) {
            if (this.testTopicReferenceConfiguration(r, t, n)) {
              var i =
                "smart" === r
                  ? "PipelinePrimaryTopicReference"
                  : "TopicReference";
              return (
                this.topicReferenceIsAllowedInCurrentContext() ||
                  this.raise(
                    "smart" === r
                      ? pt.PrimaryTopicNotAllowed
                      : pt.PipeTopicUnbound,
                    { at: t }
                  ),
                this.registerTopicReference(),
                this.finishNode(e, i)
              );
            }
            throw this.raise(pt.PipeTopicUnconfiguredToken, {
              at: t,
              token: Kt(n),
            });
          },
        },
        {
          key: "testTopicReferenceConfiguration",
          value: function (e, t, r) {
            switch (e) {
              case "hack":
                return this.hasPlugin([
                  "pipelineOperator",
                  { topicToken: Kt(r) },
                ]);
              case "smart":
                return 27 === r;
              default:
                throw this.raise(pt.PipeTopicRequiresHackPipes, { at: t });
            }
          },
        },
        {
          key: "parseAsyncArrowUnaryFunction",
          value: function (e) {
            this.prodParam.enter(ln(!0, this.prodParam.hasYield));
            var t = [this.parseIdentifier()];
            return (
              this.prodParam.exit(),
              this.hasPrecedingLineBreak() &&
                this.raise(pt.LineTerminatorBeforeArrow, {
                  at: this.state.curPosition(),
                }),
              this.expect(19),
              this.parseArrowExpression(e, t, !0)
            );
          },
        },
        {
          key: "parseDo",
          value: function (e, t) {
            this.expectPlugin("doExpressions"),
              t && this.expectPlugin("asyncDoExpressions"),
              (e.async = t),
              this.next();
            var r = this.state.labels;
            return (
              (this.state.labels = []),
              t
                ? (this.prodParam.enter(2),
                  (e.body = this.parseBlock()),
                  this.prodParam.exit())
                : (e.body = this.parseBlock()),
              (this.state.labels = r),
              this.finishNode(e, "DoExpression")
            );
          },
        },
        {
          key: "parseSuper",
          value: function () {
            var e = this.startNode();
            return (
              this.next(),
              !this.match(10) ||
              this.scope.allowDirectSuper ||
              this.options.allowSuperOutsideMethod
                ? this.scope.allowSuper ||
                  this.options.allowSuperOutsideMethod ||
                  this.raise(pt.UnexpectedSuper, { at: e })
                : this.raise(pt.SuperNotAllowed, { at: e }),
              this.match(10) ||
                this.match(0) ||
                this.match(16) ||
                this.raise(pt.UnsupportedSuper, { at: e }),
              this.finishNode(e, "Super")
            );
          },
        },
        {
          key: "parsePrivateName",
          value: function () {
            var e = this.startNode(),
              t = this.startNodeAt($e(this.state.startLoc, 1)),
              r = this.state.value;
            return (
              this.next(),
              (e.id = this.createIdentifier(t, r)),
              this.finishNode(e, "PrivateName")
            );
          },
        },
        {
          key: "parseFunctionOrFunctionSent",
          value: function () {
            var e = this.startNode();
            if ((this.next(), this.prodParam.hasYield && this.match(16))) {
              var t = this.createIdentifier(
                this.startNodeAtNode(e),
                "function"
              );
              return (
                this.next(),
                this.match(102)
                  ? this.expectPlugin("functionSent")
                  : this.hasPlugin("functionSent") || this.unexpected(),
                this.parseMetaProperty(e, t, "sent")
              );
            }
            return this.parseFunction(e);
          },
        },
        {
          key: "parseMetaProperty",
          value: function (e, t, r) {
            e.meta = t;
            var n = this.state.containsEsc;
            return (
              (e.property = this.parseIdentifier(!0)),
              (e.property.name !== r || n) &&
                this.raise(pt.UnsupportedMetaProperty, {
                  at: e.property,
                  target: t.name,
                  onlyValidPropertyName: r,
                }),
              this.finishNode(e, "MetaProperty")
            );
          },
        },
        {
          key: "parseImportMetaProperty",
          value: function (e) {
            var t = this.createIdentifier(this.startNodeAtNode(e), "import");
            return (
              this.next(),
              this.isContextual(100) &&
                (this.inModule ||
                  this.raise(pt.ImportMetaOutsideModule, { at: t }),
                (this.sawUnambiguousESM = !0)),
              this.parseMetaProperty(e, t, "meta")
            );
          },
        },
        {
          key: "parseLiteralAtNode",
          value: function (e, t, r) {
            return (
              this.addExtra(r, "rawValue", e),
              this.addExtra(
                r,
                "raw",
                this.input.slice(r.start, this.state.end)
              ),
              (r.value = e),
              this.next(),
              this.finishNode(r, t)
            );
          },
        },
        {
          key: "parseLiteral",
          value: function (e, t) {
            var r = this.startNode();
            return this.parseLiteralAtNode(e, t, r);
          },
        },
        {
          key: "parseStringLiteral",
          value: function (e) {
            return this.parseLiteral(e, "StringLiteral");
          },
        },
        {
          key: "parseNumericLiteral",
          value: function (e) {
            return this.parseLiteral(e, "NumericLiteral");
          },
        },
        {
          key: "parseBigIntLiteral",
          value: function (e) {
            return this.parseLiteral(e, "BigIntLiteral");
          },
        },
        {
          key: "parseDecimalLiteral",
          value: function (e) {
            return this.parseLiteral(e, "DecimalLiteral");
          },
        },
        {
          key: "parseRegExpLiteral",
          value: function (e) {
            var t = this.parseLiteral(e.value, "RegExpLiteral");
            return (t.pattern = e.pattern), (t.flags = e.flags), t;
          },
        },
        {
          key: "parseBooleanLiteral",
          value: function (e) {
            var t = this.startNode();
            return (
              (t.value = e), this.next(), this.finishNode(t, "BooleanLiteral")
            );
          },
        },
        {
          key: "parseNullLiteral",
          value: function () {
            var e = this.startNode();
            return this.next(), this.finishNode(e, "NullLiteral");
          },
        },
        {
          key: "parseParenAndDistinguishExpression",
          value: function (e) {
            var t,
              r = this.state.startLoc;
            this.next(), this.expressionScope.enter(new nn(1));
            var n = this.state.maybeInArrowParameters,
              i = this.state.inFSharpPipelineDirectBody;
            (this.state.maybeInArrowParameters = !0),
              (this.state.inFSharpPipelineDirectBody = !1);
            for (
              var a, s, o = this.state.startLoc, l = [], u = new cn(), c = !0;
              !this.match(11);

            ) {
              if (c) c = !1;
              else if (
                (this.expect(
                  12,
                  null === u.optionalParametersLoc
                    ? null
                    : u.optionalParametersLoc
                ),
                this.match(11))
              ) {
                s = this.state.startLoc;
                break;
              }
              if (this.match(21)) {
                var p = this.state.startLoc;
                if (
                  ((a = this.state.startLoc),
                  l.push(this.parseParenItem(this.parseRestBinding(), p)),
                  !this.checkCommaAfterRest(41))
                )
                  break;
              } else
                l.push(this.parseMaybeAssignAllowIn(u, this.parseParenItem));
            }
            var h = this.state.lastTokEndLoc;
            this.expect(11),
              (this.state.maybeInArrowParameters = n),
              (this.state.inFSharpPipelineDirectBody = i);
            var d = this.startNodeAt(r);
            return e && this.shouldParseArrow(l) && (d = this.parseArrow(d))
              ? (this.checkDestructuringPrivate(u),
                this.expressionScope.validateAsPattern(),
                this.expressionScope.exit(),
                this.parseArrowExpression(d, l, !1),
                d)
              : (this.expressionScope.exit(),
                l.length || this.unexpected(this.state.lastTokStartLoc),
                s && this.unexpected(s),
                a && this.unexpected(a),
                this.checkExpressionErrors(u, !0),
                this.toReferencedListDeep(l, !0),
                l.length > 1
                  ? (((t = this.startNodeAt(o)).expressions = l),
                    this.finishNode(t, "SequenceExpression"),
                    this.resetEndLocation(t, h))
                  : (t = l[0]),
                this.wrapParenthesis(r, t));
          },
        },
        {
          key: "wrapParenthesis",
          value: function (e, t) {
            if (!this.options.createParenthesizedExpressions)
              return (
                this.addExtra(t, "parenthesized", !0),
                this.addExtra(t, "parenStart", e.index),
                this.takeSurroundingComments(
                  t,
                  e.index,
                  this.state.lastTokEndLoc.index
                ),
                t
              );
            var r = this.startNodeAt(e);
            return (
              (r.expression = t), this.finishNode(r, "ParenthesizedExpression")
            );
          },
        },
        {
          key: "shouldParseArrow",
          value: function (e) {
            return !this.canInsertSemicolon();
          },
        },
        {
          key: "parseArrow",
          value: function (e) {
            if (this.eat(19)) return e;
          },
        },
        {
          key: "parseParenItem",
          value: function (e, t) {
            return e;
          },
        },
        {
          key: "parseNewOrNewTarget",
          value: function () {
            var e = this.startNode();
            if ((this.next(), this.match(16))) {
              var t = this.createIdentifier(this.startNodeAtNode(e), "new");
              this.next();
              var r = this.parseMetaProperty(e, t, "target");
              return (
                this.scope.inNonArrowFunction ||
                  this.scope.inClass ||
                  this.options.allowNewTargetOutsideFunction ||
                  this.raise(pt.UnexpectedNewTarget, { at: r }),
                r
              );
            }
            return this.parseNew(e);
          },
        },
        {
          key: "parseNew",
          value: function (e) {
            if ((this.parseNewCallee(e), this.eat(10))) {
              var t = this.parseExprList(11);
              this.toReferencedList(t), (e.arguments = t);
            } else e.arguments = [];
            return this.finishNode(e, "NewExpression");
          },
        },
        {
          key: "parseNewCallee",
          value: function (e) {
            (e.callee = this.parseNoCallExpr()),
              "Import" === e.callee.type &&
                this.raise(pt.ImportCallNotNewExpression, { at: e.callee });
          },
        },
        {
          key: "parseTemplateElement",
          value: function (e) {
            var t = this.state,
              r = t.start,
              n = t.startLoc,
              i = t.end,
              a = t.value,
              s = r + 1,
              o = this.startNodeAt($e(n, 1));
            null === a &&
              (e ||
                this.raise(pt.InvalidEscapeSequenceTemplate, {
                  at: $e(this.state.firstInvalidTemplateEscapePos, 1),
                }));
            var l = this.match(24),
              u = l ? -1 : -2,
              c = i + u;
            (o.value = {
              raw: this.input.slice(s, c).replace(/\r\n?/g, "\n"),
              cooked: null === a ? null : a.slice(1, u),
            }),
              (o.tail = l),
              this.next();
            var p = this.finishNode(o, "TemplateElement");
            return this.resetEndLocation(p, $e(this.state.lastTokEndLoc, u)), p;
          },
        },
        {
          key: "parseTemplate",
          value: function (e) {
            var t = this.startNode();
            t.expressions = [];
            var r = this.parseTemplateElement(e);
            for (t.quasis = [r]; !r.tail; )
              t.expressions.push(this.parseTemplateSubstitution()),
                this.readTemplateContinuation(),
                t.quasis.push((r = this.parseTemplateElement(e)));
            return this.finishNode(t, "TemplateLiteral");
          },
        },
        {
          key: "parseTemplateSubstitution",
          value: function () {
            return this.parseExpression();
          },
        },
        {
          key: "parseObjectLike",
          value: function (e, t, r, n) {
            r && this.expectPlugin("recordAndTuple");
            var i = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            var a = Object.create(null),
              s = !0,
              o = this.startNode();
            for (o.properties = [], this.next(); !this.match(e); ) {
              if (s) s = !1;
              else if ((this.expect(12), this.match(e))) {
                this.addTrailingCommaExtraToNode(o);
                break;
              }
              var l = void 0;
              t
                ? (l = this.parseBindingProperty())
                : ((l = this.parsePropertyDefinition(n)),
                  this.checkProto(l, r, a, n)),
                r &&
                  !this.isObjectProperty(l) &&
                  "SpreadElement" !== l.type &&
                  this.raise(pt.InvalidRecordProperty, { at: l }),
                l.shorthand && this.addExtra(l, "shorthand", !0),
                o.properties.push(l);
            }
            this.next(), (this.state.inFSharpPipelineDirectBody = i);
            var u = "ObjectExpression";
            return (
              t ? (u = "ObjectPattern") : r && (u = "RecordExpression"),
              this.finishNode(o, u)
            );
          },
        },
        {
          key: "addTrailingCommaExtraToNode",
          value: function (e) {
            this.addExtra(e, "trailingComma", this.state.lastTokStart),
              this.addExtra(
                e,
                "trailingCommaLoc",
                this.state.lastTokStartLoc,
                !1
              );
          },
        },
        {
          key: "maybeAsyncOrAccessorProp",
          value: function (e) {
            return (
              !e.computed &&
              "Identifier" === e.key.type &&
              (this.isLiteralPropertyName() || this.match(0) || this.match(55))
            );
          },
        },
        {
          key: "parsePropertyDefinition",
          value: function (e) {
            var t = [];
            if (this.match(26))
              for (
                this.hasPlugin("decorators") &&
                this.raise(pt.UnsupportedPropertyDecorator, {
                  at: this.state.startLoc,
                });
                this.match(26);

              )
                t.push(this.parseDecorator());
            var r,
              n = this.startNode(),
              i = !1,
              a = !1;
            if (this.match(21))
              return t.length && this.unexpected(), this.parseSpread();
            t.length && ((n.decorators = t), (t = [])),
              (n.method = !1),
              e && (r = this.state.startLoc);
            var s = this.eat(55);
            this.parsePropertyNamePrefixOperator(n);
            var o = this.state.containsEsc,
              l = this.parsePropertyName(n, e);
            if (!s && !o && this.maybeAsyncOrAccessorProp(n)) {
              var u = l.name;
              "async" !== u ||
                this.hasPrecedingLineBreak() ||
                ((i = !0),
                this.resetPreviousNodeTrailingComments(l),
                (s = this.eat(55)),
                this.parsePropertyName(n)),
                ("get" !== u && "set" !== u) ||
                  ((a = !0),
                  this.resetPreviousNodeTrailingComments(l),
                  (n.kind = u),
                  this.match(55) &&
                    ((s = !0),
                    this.raise(pt.AccessorIsGenerator, {
                      at: this.state.curPosition(),
                      kind: u,
                    }),
                    this.next()),
                  this.parsePropertyName(n));
            }
            return this.parseObjPropValue(n, r, s, i, !1, a, e);
          },
        },
        {
          key: "getGetterSetterExpectedParamCount",
          value: function (e) {
            return "get" === e.kind ? 0 : 1;
          },
        },
        {
          key: "getObjectOrClassMethodParams",
          value: function (e) {
            return e.params;
          },
        },
        {
          key: "checkGetterSetterParams",
          value: function (e) {
            var t,
              r = this.getGetterSetterExpectedParamCount(e),
              n = this.getObjectOrClassMethodParams(e);
            n.length !== r &&
              this.raise(
                "get" === e.kind ? pt.BadGetterArity : pt.BadSetterArity,
                { at: e }
              ),
              "set" === e.kind &&
                "RestElement" ===
                  (null == (t = n[n.length - 1]) ? void 0 : t.type) &&
                this.raise(pt.BadSetterRestParameter, { at: e });
          },
        },
        {
          key: "parseObjectMethod",
          value: function (e, t, r, n, i) {
            if (i) {
              var a = this.parseMethod(e, t, !1, !1, !1, "ObjectMethod");
              return this.checkGetterSetterParams(a), a;
            }
            if (r || t || this.match(10))
              return (
                n && this.unexpected(),
                (e.kind = "method"),
                (e.method = !0),
                this.parseMethod(e, t, r, !1, !1, "ObjectMethod")
              );
          },
        },
        {
          key: "parseObjectProperty",
          value: function (e, t, r, n) {
            if (((e.shorthand = !1), this.eat(14)))
              return (
                (e.value = r
                  ? this.parseMaybeDefault(this.state.startLoc)
                  : this.parseMaybeAssignAllowIn(n)),
                this.finishNode(e, "ObjectProperty")
              );
            if (!e.computed && "Identifier" === e.key.type) {
              if (
                (this.checkReservedWord(e.key.name, e.key.loc.start, !0, !1), r)
              )
                e.value = this.parseMaybeDefault(t, dn(e.key));
              else if (this.match(29)) {
                var i = this.state.startLoc;
                null != n
                  ? null === n.shorthandAssignLoc && (n.shorthandAssignLoc = i)
                  : this.raise(pt.InvalidCoverInitializedName, { at: i }),
                  (e.value = this.parseMaybeDefault(t, dn(e.key)));
              } else e.value = dn(e.key);
              return (e.shorthand = !0), this.finishNode(e, "ObjectProperty");
            }
          },
        },
        {
          key: "parseObjPropValue",
          value: function (e, t, r, n, i, a, s) {
            var o =
              this.parseObjectMethod(e, r, n, i, a) ||
              this.parseObjectProperty(e, t, i, s);
            return o || this.unexpected(), o;
          },
        },
        {
          key: "parsePropertyName",
          value: function (e, t) {
            if (this.eat(0))
              (e.computed = !0),
                (e.key = this.parseMaybeAssignAllowIn()),
                this.expect(3);
            else {
              var r,
                n = this.state,
                i = n.type,
                a = n.value;
              if (Ft(i)) r = this.parseIdentifier(!0);
              else
                switch (i) {
                  case 132:
                    r = this.parseNumericLiteral(a);
                    break;
                  case 131:
                    r = this.parseStringLiteral(a);
                    break;
                  case 133:
                    r = this.parseBigIntLiteral(a);
                    break;
                  case 134:
                    r = this.parseDecimalLiteral(a);
                    break;
                  case 136:
                    var s = this.state.startLoc;
                    null != t
                      ? null === t.privateKeyLoc && (t.privateKeyLoc = s)
                      : this.raise(pt.UnexpectedPrivateField, { at: s }),
                      (r = this.parsePrivateName());
                    break;
                  default:
                    this.unexpected();
                }
              (e.key = r), 136 !== i && (e.computed = !1);
            }
            return e.key;
          },
        },
        {
          key: "initFunction",
          value: function (e, t) {
            (e.id = null), (e.generator = !1), (e.async = t);
          },
        },
        {
          key: "parseMethod",
          value: function (e, t, r, n, i, a) {
            var s =
              arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
            this.initFunction(e, r),
              (e.generator = t),
              this.scope.enter(18 | (s ? pr : 0) | (i ? 32 : 0)),
              this.prodParam.enter(ln(r, e.generator)),
              this.parseFunctionParams(e, n);
            var o = this.parseFunctionBodyAndFinish(e, a, !0);
            return this.prodParam.exit(), this.scope.exit(), o;
          },
        },
        {
          key: "parseArrayLike",
          value: function (e, t, r, n) {
            r && this.expectPlugin("recordAndTuple");
            var i = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !1;
            var a = this.startNode();
            return (
              this.next(),
              (a.elements = this.parseExprList(e, !r, n, a)),
              (this.state.inFSharpPipelineDirectBody = i),
              this.finishNode(a, r ? "TupleExpression" : "ArrayExpression")
            );
          },
        },
        {
          key: "parseArrowExpression",
          value: function (e, t, r, n) {
            this.scope.enter(6);
            var i = ln(r, !1);
            !this.match(5) && this.prodParam.hasIn && (i |= 8),
              this.prodParam.enter(i),
              this.initFunction(e, r);
            var a = this.state.maybeInArrowParameters;
            return (
              t &&
                ((this.state.maybeInArrowParameters = !0),
                this.setArrowFunctionParameters(e, t, n)),
              (this.state.maybeInArrowParameters = !1),
              this.parseFunctionBody(e, !0),
              this.prodParam.exit(),
              this.scope.exit(),
              (this.state.maybeInArrowParameters = a),
              this.finishNode(e, "ArrowFunctionExpression")
            );
          },
        },
        {
          key: "setArrowFunctionParameters",
          value: function (e, t, r) {
            this.toAssignableList(t, r, !1), (e.params = t);
          },
        },
        {
          key: "parseFunctionBodyAndFinish",
          value: function (e, t) {
            var r =
              arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return this.parseFunctionBody(e, !1, r), this.finishNode(e, t);
          },
        },
        {
          key: "parseFunctionBody",
          value: function (e, t) {
            var r = this,
              n =
                arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
              i = t && !this.match(5);
            if ((this.expressionScope.enter(sn()), i))
              (e.body = this.parseMaybeAssign()),
                this.checkParams(e, !1, t, !1);
            else {
              var a = this.state.strict,
                s = this.state.labels;
              (this.state.labels = []),
                this.prodParam.enter(4 | this.prodParam.currentFlags()),
                (e.body = this.parseBlock(!0, !1, function (i) {
                  var s = !r.isSimpleParamList(e.params);
                  i &&
                    s &&
                    r.raise(pt.IllegalLanguageModeDirective, {
                      at:
                        ("method" !== e.kind && "constructor" !== e.kind) ||
                        !e.key
                          ? e
                          : e.key.loc.end,
                    });
                  var o = !a && r.state.strict;
                  r.checkParams(e, !(r.state.strict || t || n || s), t, o),
                    r.state.strict && e.id && r.checkIdentifier(e.id, 65, o);
                })),
                this.prodParam.exit(),
                (this.state.labels = s);
            }
            this.expressionScope.exit();
          },
        },
        {
          key: "isSimpleParameter",
          value: function (e) {
            return "Identifier" === e.type;
          },
        },
        {
          key: "isSimpleParamList",
          value: function (e) {
            for (var t = 0, r = e.length; t < r; t++)
              if (!this.isSimpleParameter(e[t])) return !1;
            return !0;
          },
        },
        {
          key: "checkParams",
          value: function (e, t, r) {
            var n,
              i =
                !(arguments.length > 3 && void 0 !== arguments[3]) ||
                arguments[3],
              a = !t && new Set(),
              s = { type: "FormalParameters" },
              o = He(e.params);
            try {
              for (o.s(); !(n = o.n()).done; ) {
                var l = n.value;
                this.checkLVal(l, {
                  in: s,
                  binding: 5,
                  checkClashes: a,
                  strictModeChanged: i,
                });
              }
            } catch (e) {
              o.e(e);
            } finally {
              o.f();
            }
          },
        },
        {
          key: "parseExprList",
          value: function (e, t, r, n) {
            for (var i = [], a = !0; !this.eat(e); ) {
              if (a) a = !1;
              else if ((this.expect(12), this.match(e))) {
                n && this.addTrailingCommaExtraToNode(n), this.next();
                break;
              }
              i.push(this.parseExprListItem(t, r));
            }
            return i;
          },
        },
        {
          key: "parseExprListItem",
          value: function (e, t, r) {
            var n;
            if (this.match(12))
              e ||
                this.raise(pt.UnexpectedToken, {
                  at: this.state.curPosition(),
                  unexpected: ",",
                }),
                (n = null);
            else if (this.match(21)) {
              var i = this.state.startLoc;
              n = this.parseParenItem(this.parseSpread(t), i);
            } else if (this.match(17)) {
              this.expectPlugin("partialApplication"),
                r ||
                  this.raise(pt.UnexpectedArgumentPlaceholder, {
                    at: this.state.startLoc,
                  });
              var a = this.startNode();
              this.next(), (n = this.finishNode(a, "ArgumentPlaceholder"));
            } else n = this.parseMaybeAssignAllowIn(t, this.parseParenItem);
            return n;
          },
        },
        {
          key: "parseIdentifier",
          value: function (e) {
            var t = this.startNode(),
              r = this.parseIdentifierName(e);
            return this.createIdentifier(t, r);
          },
        },
        {
          key: "createIdentifier",
          value: function (e, t) {
            return (
              (e.name = t),
              (e.loc.identifierName = t),
              this.finishNode(e, "Identifier")
            );
          },
        },
        {
          key: "parseIdentifierName",
          value: function (e) {
            var t,
              r = this.state,
              n = r.startLoc,
              i = r.type;
            Ft(i) ? (t = this.state.value) : this.unexpected();
            var a = i <= 92;
            return (
              e
                ? a && this.replaceToken(130)
                : this.checkReservedWord(t, n, a, !1),
              this.next(),
              t
            );
          },
        },
        {
          key: "checkReservedWord",
          value: function (e, t, r, n) {
            if (
              !(e.length > 10) &&
              (function (e) {
                return cr.has(e);
              })(e)
            )
              if (
                r &&
                (function (e) {
                  return nr.has(e);
                })(e)
              )
                this.raise(pt.UnexpectedKeyword, { at: t, keyword: e });
              else if (
                (this.state.strict ? (n ? ur : or) : sr)(e, this.inModule)
              )
                this.raise(pt.UnexpectedReservedWord, {
                  at: t,
                  reservedWord: e,
                });
              else if ("yield" === e) {
                if (this.prodParam.hasYield)
                  return void this.raise(pt.YieldBindingIdentifier, { at: t });
              } else if ("await" === e) {
                if (this.prodParam.hasAwait)
                  return void this.raise(pt.AwaitBindingIdentifier, { at: t });
                if (this.scope.inStaticBlock)
                  return void this.raise(
                    pt.AwaitBindingIdentifierInStaticBlock,
                    { at: t }
                  );
                this.expressionScope.recordAsyncArrowParametersError({ at: t });
              } else if (
                "arguments" === e &&
                this.scope.inClassAndNotInNonArrowFunction
              )
                return void this.raise(pt.ArgumentsInClass, { at: t });
          },
        },
        {
          key: "isAwaitAllowed",
          value: function () {
            return (
              !!this.prodParam.hasAwait ||
              !(
                !this.options.allowAwaitOutsideFunction || this.scope.inFunction
              )
            );
          },
        },
        {
          key: "parseAwait",
          value: function (e) {
            var t = this.startNodeAt(e);
            return (
              this.expressionScope.recordParameterInitializerError(
                pt.AwaitExpressionFormalParameter,
                { at: t }
              ),
              this.eat(55) && this.raise(pt.ObsoleteAwaitStar, { at: t }),
              this.scope.inFunction ||
                this.options.allowAwaitOutsideFunction ||
                (this.isAmbiguousAwait()
                  ? (this.ambiguousScriptDifferentAst = !0)
                  : (this.sawUnambiguousESM = !0)),
              this.state.soloAwait ||
                (t.argument = this.parseMaybeUnary(null, !0)),
              this.finishNode(t, "AwaitExpression")
            );
          },
        },
        {
          key: "isAmbiguousAwait",
          value: function () {
            if (this.hasPrecedingLineBreak()) return !0;
            var e = this.state.type;
            return (
              53 === e ||
              10 === e ||
              0 === e ||
              qt(e) ||
              (101 === e && !this.state.containsEsc) ||
              135 === e ||
              56 === e ||
              (this.hasPlugin("v8intrinsic") && 54 === e)
            );
          },
        },
        {
          key: "parseYield",
          value: function () {
            var e = this.startNode();
            this.expressionScope.recordParameterInitializerError(
              pt.YieldInParameter,
              { at: e }
            ),
              this.next();
            var t = !1,
              r = null;
            if (!this.hasPrecedingLineBreak())
              switch (((t = this.eat(55)), this.state.type)) {
                case 13:
                case 137:
                case 8:
                case 11:
                case 3:
                case 9:
                case 14:
                case 12:
                  if (!t) break;
                default:
                  r = this.parseMaybeAssign();
              }
            return (
              (e.delegate = t),
              (e.argument = r),
              this.finishNode(e, "YieldExpression")
            );
          },
        },
        {
          key: "checkPipelineAtInfixOperator",
          value: function (e, t) {
            this.hasPlugin(["pipelineOperator", { proposal: "smart" }]) &&
              "SequenceExpression" === e.type &&
              this.raise(pt.PipelineHeadSequenceExpression, { at: t });
          },
        },
        {
          key: "parseSmartPipelineBodyInStyle",
          value: function (e, t) {
            if (this.isSimpleReference(e)) {
              var r = this.startNodeAt(t);
              return (r.callee = e), this.finishNode(r, "PipelineBareFunction");
            }
            var n = this.startNodeAt(t);
            return (
              this.checkSmartPipeTopicBodyEarlyErrors(t),
              (n.expression = e),
              this.finishNode(n, "PipelineTopicExpression")
            );
          },
        },
        {
          key: "isSimpleReference",
          value: function (e) {
            switch (e.type) {
              case "MemberExpression":
                return !e.computed && this.isSimpleReference(e.object);
              case "Identifier":
                return !0;
              default:
                return !1;
            }
          },
        },
        {
          key: "checkSmartPipeTopicBodyEarlyErrors",
          value: function (e) {
            if (this.match(19))
              throw this.raise(pt.PipelineBodyNoArrow, {
                at: this.state.startLoc,
              });
            this.topicReferenceWasUsedInCurrentContext() ||
              this.raise(pt.PipelineTopicUnused, { at: e });
          },
        },
        {
          key: "withTopicBindingContext",
          value: function (e) {
            var t = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 1,
              maxTopicIndex: null,
            };
            try {
              return e();
            } finally {
              this.state.topicContext = t;
            }
          },
        },
        {
          key: "withSmartMixTopicForbiddingContext",
          value: function (e) {
            if (!this.hasPlugin(["pipelineOperator", { proposal: "smart" }]))
              return e();
            var t = this.state.topicContext;
            this.state.topicContext = {
              maxNumOfResolvableTopics: 0,
              maxTopicIndex: null,
            };
            try {
              return e();
            } finally {
              this.state.topicContext = t;
            }
          },
        },
        {
          key: "withSoloAwaitPermittingContext",
          value: function (e) {
            var t = this.state.soloAwait;
            this.state.soloAwait = !0;
            try {
              return e();
            } finally {
              this.state.soloAwait = t;
            }
          },
        },
        {
          key: "allowInAnd",
          value: function (e) {
            var t = this.prodParam.currentFlags();
            if (8 & ~t) {
              this.prodParam.enter(8 | t);
              try {
                return e();
              } finally {
                this.prodParam.exit();
              }
            }
            return e();
          },
        },
        {
          key: "disallowInAnd",
          value: function (e) {
            var t = this.prodParam.currentFlags();
            if (8 & t) {
              this.prodParam.enter(-9 & t);
              try {
                return e();
              } finally {
                this.prodParam.exit();
              }
            }
            return e();
          },
        },
        {
          key: "registerTopicReference",
          value: function () {
            this.state.topicContext.maxTopicIndex = 0;
          },
        },
        {
          key: "topicReferenceIsAllowedInCurrentContext",
          value: function () {
            return this.state.topicContext.maxNumOfResolvableTopics >= 1;
          },
        },
        {
          key: "topicReferenceWasUsedInCurrentContext",
          value: function () {
            return (
              null != this.state.topicContext.maxTopicIndex &&
              this.state.topicContext.maxTopicIndex >= 0
            );
          },
        },
        {
          key: "parseFSharpPipelineBody",
          value: function (e) {
            var t = this.state.startLoc;
            this.state.potentialArrowAt = this.state.start;
            var r = this.state.inFSharpPipelineDirectBody;
            this.state.inFSharpPipelineDirectBody = !0;
            var n = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), t, e);
            return (this.state.inFSharpPipelineDirectBody = r), n;
          },
        },
        {
          key: "parseModuleExpression",
          value: function () {
            this.expectPlugin("moduleBlocks");
            var e = this.startNode();
            this.next(), this.match(5) || this.unexpected(null, 5);
            var t = this.startNodeAt(this.state.endLoc);
            this.next();
            var r = this.initializeScopes(!0);
            this.enterInitialScopes();
            try {
              e.body = this.parseProgram(t, 8, "module");
            } finally {
              r();
            }
            return this.finishNode(e, "ModuleExpression");
          },
        },
        { key: "parsePropertyNamePrefixOperator", value: function (e) {} },
      ]),
      r
    );
  })(),
  Xn = { kind: "loop" },
  Gn = { kind: "switch" },
  zn =
    /(?:[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/,
  $n = new RegExp("in(?:stanceof)?", "y");
var Qn = (function (e) {
    I(r, Jn);
    var t = Je(r);
    function r() {
      return E(this, r), t.apply(this, arguments);
    }
    return (
      A(r, [
        {
          key: "parseTopLevel",
          value: function (e, t) {
            return (
              (e.program = this.parseProgram(t)),
              (e.comments = this.state.comments),
              this.options.tokens &&
                (e.tokens = (function (e, t) {
                  for (var r = 0; r < e.length; r++) {
                    var n = e[r],
                      i = n.type;
                    if ("number" == typeof i) {
                      if (136 === i) {
                        var a = n.loc,
                          s = n.start,
                          o = n.value,
                          l = n.end,
                          u = s + 1,
                          c = $e(a.start, 1);
                        e.splice(
                          r,
                          1,
                          new Qr({
                            type: Ht(27),
                            value: "#",
                            start: s,
                            end: u,
                            startLoc: a.start,
                            endLoc: c,
                          }),
                          new Qr({
                            type: Ht(130),
                            value: o,
                            start: u,
                            end: l,
                            startLoc: c,
                            endLoc: a.end,
                          })
                        ),
                          r++;
                        continue;
                      }
                      if (qt(i)) {
                        var p = n.loc,
                          h = n.start,
                          d = n.value,
                          f = n.end,
                          y = h + 1,
                          m = $e(p.start, 1),
                          v = void 0;
                        v =
                          96 === t.charCodeAt(h)
                            ? new Qr({
                                type: Ht(22),
                                value: "`",
                                start: h,
                                end: y,
                                startLoc: p.start,
                                endLoc: m,
                              })
                            : new Qr({
                                type: Ht(8),
                                value: "}",
                                start: h,
                                end: y,
                                startLoc: p.start,
                                endLoc: m,
                              });
                        var g = void 0,
                          b = void 0,
                          T = void 0,
                          S = void 0;
                        24 === i
                          ? ((b = f - 1),
                            (T = $e(p.end, -1)),
                            (g = null === d ? null : d.slice(1, -1)),
                            (S = new Qr({
                              type: Ht(22),
                              value: "`",
                              start: b,
                              end: f,
                              startLoc: T,
                              endLoc: p.end,
                            })))
                          : ((b = f - 2),
                            (T = $e(p.end, -2)),
                            (g = null === d ? null : d.slice(1, -2)),
                            (S = new Qr({
                              type: Ht(23),
                              value: "${",
                              start: b,
                              end: f,
                              startLoc: T,
                              endLoc: p.end,
                            }))),
                          e.splice(
                            r,
                            1,
                            v,
                            new Qr({
                              type: Ht(20),
                              value: g,
                              start: y,
                              end: b,
                              startLoc: m,
                              endLoc: T,
                            }),
                            S
                          ),
                          (r += 2);
                        continue;
                      }
                      n.type = Ht(i);
                    }
                  }
                  return e;
                })(this.tokens, this.input)),
              this.finishNode(e, "File")
            );
          },
        },
        {
          key: "parseProgram",
          value: function (e) {
            var t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 137,
              r =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : this.options.sourceType;
            if (
              ((e.sourceType = r),
              (e.interpreter = this.parseInterpreterDirective()),
              this.parseBlockBody(e, !0, !0, t),
              this.inModule &&
                !this.options.allowUndeclaredExports &&
                this.scope.undefinedExports.size > 0)
            )
              for (
                var n = 0, i = Array.from(this.scope.undefinedExports);
                n < i.length;
                n++
              ) {
                var a = H(i[n], 2),
                  s = a[0],
                  o = a[1];
                this.raise(pt.ModuleExportUndefined, { at: o, localName: s });
              }
            return 137 === t
              ? this.finishNode(e, "Program")
              : this.finishNodeAt(e, "Program", $e(this.state.startLoc, -1));
          },
        },
        {
          key: "stmtToDirective",
          value: function (e) {
            var t = e;
            (t.type = "Directive"),
              (t.value = t.expression),
              delete t.expression;
            var r = t.value,
              n = r.value,
              i = this.input.slice(r.start, r.end),
              a = (r.value = i.slice(1, -1));
            return (
              this.addExtra(r, "raw", i),
              this.addExtra(r, "rawValue", a),
              this.addExtra(r, "expressionValue", n),
              (r.type = "DirectiveLiteral"),
              t
            );
          },
        },
        {
          key: "parseInterpreterDirective",
          value: function () {
            if (!this.match(28)) return null;
            var e = this.startNode();
            return (
              (e.value = this.state.value),
              this.next(),
              this.finishNode(e, "InterpreterDirective")
            );
          },
        },
        {
          key: "isLet",
          value: function () {
            return !!this.isContextual(99) && this.hasFollowingBindingAtom();
          },
        },
        {
          key: "chStartsBindingIdentifier",
          value: function (e, t) {
            if (Zt(e)) {
              if ((($n.lastIndex = t), $n.test(this.input))) {
                var r = this.codePointAtPos($n.lastIndex);
                if (!er(r) && 92 !== r) return !1;
              }
              return !0;
            }
            return 92 === e;
          },
        },
        {
          key: "chStartsBindingPattern",
          value: function (e) {
            return 91 === e || 123 === e;
          },
        },
        {
          key: "hasFollowingBindingAtom",
          value: function () {
            var e = this.nextTokenStart(),
              t = this.codePointAtPos(e);
            return (
              this.chStartsBindingPattern(t) ||
              this.chStartsBindingIdentifier(t, e)
            );
          },
        },
        {
          key: "hasInLineFollowingBindingIdentifier",
          value: function () {
            var e = this.nextTokenInLineStart(),
              t = this.codePointAtPos(e);
            return this.chStartsBindingIdentifier(t, e);
          },
        },
        {
          key: "startsUsingForOf",
          value: function () {
            var e = this.lookahead(),
              t = e.type,
              r = e.containsEsc;
            return (
              !(101 === t && !r) &&
              (jt(t) && !this.hasFollowingLineBreak()
                ? (this.expectPlugin("explicitResourceManagement"), !0)
                : void 0)
            );
          },
        },
        {
          key: "parseModuleItem",
          value: function () {
            return this.parseStatementLike(15);
          },
        },
        {
          key: "parseStatementListItem",
          value: function () {
            return this.parseStatementLike(
              6 | (!this.options.annexB || this.state.strict ? 0 : 8)
            );
          },
        },
        {
          key: "parseStatementOrSloppyAnnexBFunctionDeclaration",
          value: function () {
            var e =
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
              t = 0;
            return (
              this.options.annexB &&
                !this.state.strict &&
                ((t |= 4), e && (t |= 8)),
              this.parseStatementLike(t)
            );
          },
        },
        {
          key: "parseStatement",
          value: function () {
            return this.parseStatementLike(0);
          },
        },
        {
          key: "parseStatementLike",
          value: function (e) {
            var t = null;
            return (
              this.match(26) && (t = this.parseDecorators(!0)),
              this.parseStatementContent(e, t)
            );
          },
        },
        {
          key: "parseStatementContent",
          value: function (e, t) {
            var r = this.state.type,
              n = this.startNode(),
              i = !!(2 & e),
              a = !!(4 & e),
              s = 1 & e;
            switch (r) {
              case 60:
                return this.parseBreakContinueStatement(n, !0);
              case 63:
                return this.parseBreakContinueStatement(n, !1);
              case 64:
                return this.parseDebuggerStatement(n);
              case 90:
                return this.parseDoWhileStatement(n);
              case 91:
                return this.parseForStatement(n);
              case 68:
                if (46 === this.lookaheadCharCode()) break;
                return (
                  a ||
                    this.raise(
                      this.state.strict
                        ? pt.StrictFunction
                        : this.options.annexB
                        ? pt.SloppyFunctionAnnexB
                        : pt.SloppyFunction,
                      { at: this.state.startLoc }
                    ),
                  this.parseFunctionStatement(n, !1, !i && a)
                );
              case 80:
                return (
                  i || this.unexpected(),
                  this.parseClass(this.maybeTakeDecorators(t, n), !0)
                );
              case 69:
                return this.parseIfStatement(n);
              case 70:
                return this.parseReturnStatement(n);
              case 71:
                return this.parseSwitchStatement(n);
              case 72:
                return this.parseThrowStatement(n);
              case 73:
                return this.parseTryStatement(n);
              case 105:
                if (
                  this.state.containsEsc ||
                  !this.hasInLineFollowingBindingIdentifier()
                )
                  break;
                return (
                  this.expectPlugin("explicitResourceManagement"),
                  !this.scope.inModule && this.scope.inTopLevel
                    ? this.raise(pt.UnexpectedUsingDeclaration, {
                        at: this.state.startLoc,
                      })
                    : i ||
                      this.raise(pt.UnexpectedLexicalDeclaration, {
                        at: this.state.startLoc,
                      }),
                  this.parseVarStatement(n, "using")
                );
              case 99:
                if (this.state.containsEsc) break;
                var o = this.nextTokenStart(),
                  l = this.codePointAtPos(o);
                if (91 !== l) {
                  if (!i && this.hasFollowingLineBreak()) break;
                  if (!this.chStartsBindingIdentifier(l, o) && 123 !== l) break;
                }
              case 75:
                i ||
                  this.raise(pt.UnexpectedLexicalDeclaration, {
                    at: this.state.startLoc,
                  });
              case 74:
                var u = this.state.value;
                return this.parseVarStatement(n, u);
              case 92:
                return this.parseWhileStatement(n);
              case 76:
                return this.parseWithStatement(n);
              case 5:
                return this.parseBlock();
              case 13:
                return this.parseEmptyStatement(n);
              case 83:
                var c = this.lookaheadCharCode();
                if (40 === c || 46 === c) break;
              case 82:
                var p;
                return (
                  this.options.allowImportExportEverywhere ||
                    s ||
                    this.raise(pt.UnexpectedImportExport, {
                      at: this.state.startLoc,
                    }),
                  this.next(),
                  83 === r
                    ? "ImportDeclaration" !== (p = this.parseImport(n)).type ||
                      (p.importKind && "value" !== p.importKind) ||
                      (this.sawUnambiguousESM = !0)
                    : (("ExportNamedDeclaration" !==
                        (p = this.parseExport(n, t)).type ||
                        (p.exportKind && "value" !== p.exportKind)) &&
                        ("ExportAllDeclaration" !== p.type ||
                          (p.exportKind && "value" !== p.exportKind)) &&
                        "ExportDefaultDeclaration" !== p.type) ||
                      (this.sawUnambiguousESM = !0),
                  this.assertModuleNodeAllowed(p),
                  p
                );
              default:
                if (this.isAsyncFunction())
                  return (
                    i ||
                      this.raise(pt.AsyncFunctionInSingleStatementContext, {
                        at: this.state.startLoc,
                      }),
                    this.next(),
                    this.parseFunctionStatement(n, !0, !i && a)
                  );
            }
            var h = this.state.value,
              d = this.parseExpression();
            return jt(r) && "Identifier" === d.type && this.eat(14)
              ? this.parseLabeledStatement(n, h, d, e)
              : this.parseExpressionStatement(n, d, t);
          },
        },
        {
          key: "assertModuleNodeAllowed",
          value: function (e) {
            this.options.allowImportExportEverywhere ||
              this.inModule ||
              this.raise(pt.ImportOutsideModule, { at: e });
          },
        },
        {
          key: "decoratorsEnabledBeforeExport",
          value: function () {
            return (
              !!this.hasPlugin("decorators-legacy") ||
              (this.hasPlugin("decorators") &&
                !1 !==
                  this.getPluginOption("decorators", "decoratorsBeforeExport"))
            );
          },
        },
        {
          key: "maybeTakeDecorators",
          value: function (e, t, r) {
            if (e) {
              var n;
              if (t.decorators && t.decorators.length > 0)
                "boolean" !=
                  typeof this.getPluginOption(
                    "decorators",
                    "decoratorsBeforeExport"
                  ) &&
                  this.raise(pt.DecoratorsBeforeAfterExport, {
                    at: t.decorators[0],
                  }),
                  (n = t.decorators).unshift.apply(n, K(e));
              else t.decorators = e;
              this.resetStartLocationFromNode(t, e[0]),
                r && this.resetStartLocationFromNode(r, t);
            }
            return t;
          },
        },
        {
          key: "canHaveLeadingDecorator",
          value: function () {
            return this.match(80);
          },
        },
        {
          key: "parseDecorators",
          value: function (e) {
            var t = [];
            do {
              t.push(this.parseDecorator());
            } while (this.match(26));
            if (this.match(82))
              e || this.unexpected(),
                this.decoratorsEnabledBeforeExport() ||
                  this.raise(pt.DecoratorExportClass, {
                    at: this.state.startLoc,
                  });
            else if (!this.canHaveLeadingDecorator())
              throw this.raise(pt.UnexpectedLeadingDecorator, {
                at: this.state.startLoc,
              });
            return t;
          },
        },
        {
          key: "parseDecorator",
          value: function () {
            this.expectOnePlugin(["decorators", "decorators-legacy"]);
            var e = this.startNode();
            if ((this.next(), this.hasPlugin("decorators"))) {
              var t,
                r = this.state.startLoc;
              if (this.match(10)) {
                var n = this.state.startLoc;
                this.next(),
                  (t = this.parseExpression()),
                  this.expect(11),
                  (t = this.wrapParenthesis(n, t));
                var i = this.state.startLoc;
                (e.expression = this.parseMaybeDecoratorArguments(t)),
                  !1 ===
                    this.getPluginOption(
                      "decorators",
                      "allowCallParenthesized"
                    ) &&
                    e.expression !== t &&
                    this.raise(pt.DecoratorArgumentsOutsideParentheses, {
                      at: i,
                    });
              } else {
                for (t = this.parseIdentifier(!1); this.eat(16); ) {
                  var a = this.startNodeAt(r);
                  (a.object = t),
                    this.match(136)
                      ? (this.classScope.usePrivateName(
                          this.state.value,
                          this.state.startLoc
                        ),
                        (a.property = this.parsePrivateName()))
                      : (a.property = this.parseIdentifier(!0)),
                    (a.computed = !1),
                    (t = this.finishNode(a, "MemberExpression"));
                }
                e.expression = this.parseMaybeDecoratorArguments(t);
              }
            } else e.expression = this.parseExprSubscripts();
            return this.finishNode(e, "Decorator");
          },
        },
        {
          key: "parseMaybeDecoratorArguments",
          value: function (e) {
            if (this.eat(10)) {
              var t = this.startNodeAtNode(e);
              return (
                (t.callee = e),
                (t.arguments = this.parseCallExpressionArguments(11, !1)),
                this.toReferencedList(t.arguments),
                this.finishNode(t, "CallExpression")
              );
            }
            return e;
          },
        },
        {
          key: "parseBreakContinueStatement",
          value: function (e, t) {
            return (
              this.next(),
              this.isLineTerminator()
                ? (e.label = null)
                : ((e.label = this.parseIdentifier()), this.semicolon()),
              this.verifyBreakContinue(e, t),
              this.finishNode(e, t ? "BreakStatement" : "ContinueStatement")
            );
          },
        },
        {
          key: "verifyBreakContinue",
          value: function (e, t) {
            var r;
            for (r = 0; r < this.state.labels.length; ++r) {
              var n = this.state.labels[r];
              if (null == e.label || n.name === e.label.name) {
                if (null != n.kind && (t || "loop" === n.kind)) break;
                if (e.label && t) break;
              }
            }
            if (r === this.state.labels.length) {
              var i = t ? "BreakStatement" : "ContinueStatement";
              this.raise(pt.IllegalBreakContinue, { at: e, type: i });
            }
          },
        },
        {
          key: "parseDebuggerStatement",
          value: function (e) {
            return (
              this.next(),
              this.semicolon(),
              this.finishNode(e, "DebuggerStatement")
            );
          },
        },
        {
          key: "parseHeaderExpression",
          value: function () {
            this.expect(10);
            var e = this.parseExpression();
            return this.expect(11), e;
          },
        },
        {
          key: "parseDoWhileStatement",
          value: function (e) {
            var t = this;
            return (
              this.next(),
              this.state.labels.push(Xn),
              (e.body = this.withSmartMixTopicForbiddingContext(function () {
                return t.parseStatement();
              })),
              this.state.labels.pop(),
              this.expect(92),
              (e.test = this.parseHeaderExpression()),
              this.eat(13),
              this.finishNode(e, "DoWhileStatement")
            );
          },
        },
        {
          key: "parseForStatement",
          value: function (e) {
            this.next(), this.state.labels.push(Xn);
            var t = null;
            if (
              (this.isAwaitAllowed() &&
                this.eatContextual(96) &&
                (t = this.state.lastTokStartLoc),
              this.scope.enter(0),
              this.expect(10),
              this.match(13))
            )
              return null !== t && this.unexpected(t), this.parseFor(e, null);
            var r = this.isContextual(99),
              n = this.isContextual(105),
              i =
                (r && this.hasFollowingBindingAtom()) ||
                (n && this.startsUsingForOf());
            if (this.match(74) || this.match(75) || i) {
              var a = this.startNode(),
                s = this.state.value;
              this.next(), this.parseVar(a, !0, s);
              var o = this.finishNode(a, "VariableDeclaration"),
                l = this.match(58);
              return (
                l && n && this.raise(pt.ForInUsing, { at: o }),
                (l || this.isContextual(101)) && 1 === o.declarations.length
                  ? this.parseForIn(e, o, t)
                  : (null !== t && this.unexpected(t), this.parseFor(e, o))
              );
            }
            var u = this.isContextual(95),
              c = new cn(),
              p = this.parseExpression(!0, c),
              h = this.isContextual(101);
            if (
              (h &&
                (r && this.raise(pt.ForOfLet, { at: p }),
                null === t &&
                  u &&
                  "Identifier" === p.type &&
                  this.raise(pt.ForOfAsync, { at: p })),
              h || this.match(58))
            ) {
              this.checkDestructuringPrivate(c), this.toAssignable(p, !0);
              var d = h ? "ForOfStatement" : "ForInStatement";
              return (
                this.checkLVal(p, { in: { type: d } }), this.parseForIn(e, p, t)
              );
            }
            return (
              this.checkExpressionErrors(c, !0),
              null !== t && this.unexpected(t),
              this.parseFor(e, p)
            );
          },
        },
        {
          key: "parseFunctionStatement",
          value: function (e, t, r) {
            return (
              this.next(), this.parseFunction(e, 1 | (r ? 2 : 0) | (t ? 8 : 0))
            );
          },
        },
        {
          key: "parseIfStatement",
          value: function (e) {
            return (
              this.next(),
              (e.test = this.parseHeaderExpression()),
              (e.consequent =
                this.parseStatementOrSloppyAnnexBFunctionDeclaration()),
              (e.alternate = this.eat(66)
                ? this.parseStatementOrSloppyAnnexBFunctionDeclaration()
                : null),
              this.finishNode(e, "IfStatement")
            );
          },
        },
        {
          key: "parseReturnStatement",
          value: function (e) {
            return (
              this.prodParam.hasReturn ||
                this.options.allowReturnOutsideFunction ||
                this.raise(pt.IllegalReturn, { at: this.state.startLoc }),
              this.next(),
              this.isLineTerminator()
                ? (e.argument = null)
                : ((e.argument = this.parseExpression()), this.semicolon()),
              this.finishNode(e, "ReturnStatement")
            );
          },
        },
        {
          key: "parseSwitchStatement",
          value: function (e) {
            this.next(), (e.discriminant = this.parseHeaderExpression());
            var t,
              r,
              n = (e.cases = []);
            for (
              this.expect(5), this.state.labels.push(Gn), this.scope.enter(0);
              !this.match(8);

            )
              if (this.match(61) || this.match(65)) {
                var i = this.match(61);
                t && this.finishNode(t, "SwitchCase"),
                  n.push((t = this.startNode())),
                  (t.consequent = []),
                  this.next(),
                  i
                    ? (t.test = this.parseExpression())
                    : (r &&
                        this.raise(pt.MultipleDefaultsInSwitch, {
                          at: this.state.lastTokStartLoc,
                        }),
                      (r = !0),
                      (t.test = null)),
                  this.expect(14);
              } else
                t
                  ? t.consequent.push(this.parseStatementListItem())
                  : this.unexpected();
            return (
              this.scope.exit(),
              t && this.finishNode(t, "SwitchCase"),
              this.next(),
              this.state.labels.pop(),
              this.finishNode(e, "SwitchStatement")
            );
          },
        },
        {
          key: "parseThrowStatement",
          value: function (e) {
            return (
              this.next(),
              this.hasPrecedingLineBreak() &&
                this.raise(pt.NewlineAfterThrow, {
                  at: this.state.lastTokEndLoc,
                }),
              (e.argument = this.parseExpression()),
              this.semicolon(),
              this.finishNode(e, "ThrowStatement")
            );
          },
        },
        {
          key: "parseCatchClauseParam",
          value: function () {
            var e = this.parseBindingAtom();
            return (
              this.scope.enter(
                this.options.annexB && "Identifier" === e.type ? 8 : 0
              ),
              this.checkLVal(e, { in: { type: "CatchClause" }, binding: 9 }),
              e
            );
          },
        },
        {
          key: "parseTryStatement",
          value: function (e) {
            var t = this;
            if (
              (this.next(),
              (e.block = this.parseBlock()),
              (e.handler = null),
              this.match(62))
            ) {
              var r = this.startNode();
              this.next(),
                this.match(10)
                  ? (this.expect(10),
                    (r.param = this.parseCatchClauseParam()),
                    this.expect(11))
                  : ((r.param = null), this.scope.enter(0)),
                (r.body = this.withSmartMixTopicForbiddingContext(function () {
                  return t.parseBlock(!1, !1);
                })),
                this.scope.exit(),
                (e.handler = this.finishNode(r, "CatchClause"));
            }
            return (
              (e.finalizer = this.eat(67) ? this.parseBlock() : null),
              e.handler ||
                e.finalizer ||
                this.raise(pt.NoCatchOrFinally, { at: e }),
              this.finishNode(e, "TryStatement")
            );
          },
        },
        {
          key: "parseVarStatement",
          value: function (e, t) {
            var r =
              arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
            return (
              this.next(),
              this.parseVar(e, !1, t, r),
              this.semicolon(),
              this.finishNode(e, "VariableDeclaration")
            );
          },
        },
        {
          key: "parseWhileStatement",
          value: function (e) {
            var t = this;
            return (
              this.next(),
              (e.test = this.parseHeaderExpression()),
              this.state.labels.push(Xn),
              (e.body = this.withSmartMixTopicForbiddingContext(function () {
                return t.parseStatement();
              })),
              this.state.labels.pop(),
              this.finishNode(e, "WhileStatement")
            );
          },
        },
        {
          key: "parseWithStatement",
          value: function (e) {
            var t = this;
            return (
              this.state.strict &&
                this.raise(pt.StrictWith, { at: this.state.startLoc }),
              this.next(),
              (e.object = this.parseHeaderExpression()),
              (e.body = this.withSmartMixTopicForbiddingContext(function () {
                return t.parseStatement();
              })),
              this.finishNode(e, "WithStatement")
            );
          },
        },
        {
          key: "parseEmptyStatement",
          value: function (e) {
            return this.next(), this.finishNode(e, "EmptyStatement");
          },
        },
        {
          key: "parseLabeledStatement",
          value: function (e, t, r, n) {
            var i,
              a = He(this.state.labels);
            try {
              for (a.s(); !(i = a.n()).done; ) {
                i.value.name === t &&
                  this.raise(pt.LabelRedeclaration, { at: r, labelName: t });
              }
            } catch (e) {
              a.e(e);
            } finally {
              a.f();
            }
            for (
              var s,
                o =
                  (s = this.state.type) >= 90 && s <= 92
                    ? "loop"
                    : this.match(71)
                    ? "switch"
                    : null,
                l = this.state.labels.length - 1;
              l >= 0;
              l--
            ) {
              var u = this.state.labels[l];
              if (u.statementStart !== e.start) break;
              (u.statementStart = this.state.start), (u.kind = o);
            }
            return (
              this.state.labels.push({
                name: t,
                kind: o,
                statementStart: this.state.start,
              }),
              (e.body =
                8 & n
                  ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(!0)
                  : this.parseStatement()),
              this.state.labels.pop(),
              (e.label = r),
              this.finishNode(e, "LabeledStatement")
            );
          },
        },
        {
          key: "parseExpressionStatement",
          value: function (e, t, r) {
            return (
              (e.expression = t),
              this.semicolon(),
              this.finishNode(e, "ExpressionStatement")
            );
          },
        },
        {
          key: "parseBlock",
          value: function () {
            var e =
                arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
              t =
                !(arguments.length > 1 && void 0 !== arguments[1]) ||
                arguments[1],
              r = arguments.length > 2 ? arguments[2] : void 0,
              n = this.startNode();
            return (
              e && this.state.strictErrors.clear(),
              this.expect(5),
              t && this.scope.enter(0),
              this.parseBlockBody(n, e, !1, 8, r),
              t && this.scope.exit(),
              this.finishNode(n, "BlockStatement")
            );
          },
        },
        {
          key: "isValidDirective",
          value: function (e) {
            return (
              "ExpressionStatement" === e.type &&
              "StringLiteral" === e.expression.type &&
              !e.expression.extra.parenthesized
            );
          },
        },
        {
          key: "parseBlockBody",
          value: function (e, t, r, n, i) {
            var a = (e.body = []),
              s = (e.directives = []);
            this.parseBlockOrModuleBlockBody(a, t ? s : void 0, r, n, i);
          },
        },
        {
          key: "parseBlockOrModuleBlockBody",
          value: function (e, t, r, n, i) {
            for (var a = this.state.strict, s = !1, o = !1; !this.match(n); ) {
              var l = r
                ? this.parseModuleItem()
                : this.parseStatementListItem();
              if (t && !o) {
                if (this.isValidDirective(l)) {
                  var u = this.stmtToDirective(l);
                  t.push(u),
                    s ||
                      "use strict" !== u.value.value ||
                      ((s = !0), this.setStrict(!0));
                  continue;
                }
                (o = !0), this.state.strictErrors.clear();
              }
              e.push(l);
            }
            i && i.call(this, s), a || this.setStrict(!1), this.next();
          },
        },
        {
          key: "parseFor",
          value: function (e, t) {
            var r = this;
            return (
              (e.init = t),
              this.semicolon(!1),
              (e.test = this.match(13) ? null : this.parseExpression()),
              this.semicolon(!1),
              (e.update = this.match(11) ? null : this.parseExpression()),
              this.expect(11),
              (e.body = this.withSmartMixTopicForbiddingContext(function () {
                return r.parseStatement();
              })),
              this.scope.exit(),
              this.state.labels.pop(),
              this.finishNode(e, "ForStatement")
            );
          },
        },
        {
          key: "parseForIn",
          value: function (e, t, r) {
            var n = this,
              i = this.match(58);
            return (
              this.next(),
              i ? null !== r && this.unexpected(r) : (e.await = null !== r),
              "VariableDeclaration" !== t.type ||
                null == t.declarations[0].init ||
                (i &&
                  this.options.annexB &&
                  !this.state.strict &&
                  "var" === t.kind &&
                  "Identifier" === t.declarations[0].id.type) ||
                this.raise(pt.ForInOfLoopInitializer, {
                  at: t,
                  type: i ? "ForInStatement" : "ForOfStatement",
                }),
              "AssignmentPattern" === t.type &&
                this.raise(pt.InvalidLhs, {
                  at: t,
                  ancestor: { type: "ForStatement" },
                }),
              (e.left = t),
              (e.right = i
                ? this.parseExpression()
                : this.parseMaybeAssignAllowIn()),
              this.expect(11),
              (e.body = this.withSmartMixTopicForbiddingContext(function () {
                return n.parseStatement();
              })),
              this.scope.exit(),
              this.state.labels.pop(),
              this.finishNode(e, i ? "ForInStatement" : "ForOfStatement")
            );
          },
        },
        {
          key: "parseVar",
          value: function (e, t, r) {
            var n =
                arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
              i = (e.declarations = []);
            for (e.kind = r; ; ) {
              var a = this.startNode();
              if (
                (this.parseVarId(a, r),
                (a.init = this.eat(29)
                  ? t
                    ? this.parseMaybeAssignDisallowIn()
                    : this.parseMaybeAssignAllowIn()
                  : null),
                null !== a.init ||
                  n ||
                  ("Identifier" === a.id.type ||
                  (t && (this.match(58) || this.isContextual(101)))
                    ? "const" !== r ||
                      this.match(58) ||
                      this.isContextual(101) ||
                      this.raise(pt.DeclarationMissingInitializer, {
                        at: this.state.lastTokEndLoc,
                        kind: "const",
                      })
                    : this.raise(pt.DeclarationMissingInitializer, {
                        at: this.state.lastTokEndLoc,
                        kind: "destructuring",
                      })),
                i.push(this.finishNode(a, "VariableDeclarator")),
                !this.eat(12))
              )
                break;
            }
            return e;
          },
        },
        {
          key: "parseVarId",
          value: function (e, t) {
            var r = this.parseBindingAtom();
            this.checkLVal(r, {
              in: { type: "VariableDeclarator" },
              binding: "var" === t ? 5 : Tr,
            }),
              (e.id = r);
          },
        },
        {
          key: "parseAsyncFunctionExpression",
          value: function (e) {
            return this.parseFunction(e, 8);
          },
        },
        {
          key: "parseFunction",
          value: function (e) {
            var t = this,
              r =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : 0,
              n = 2 & r,
              i = !!(1 & r),
              a = i && !(4 & r),
              s = !!(8 & r);
            this.initFunction(e, s),
              this.match(55) &&
                (n &&
                  this.raise(pt.GeneratorInSingleStatementContext, {
                    at: this.state.startLoc,
                  }),
                this.next(),
                (e.generator = !0)),
              i && (e.id = this.parseFunctionId(a));
            var o = this.state.maybeInArrowParameters;
            return (
              (this.state.maybeInArrowParameters = !1),
              this.scope.enter(2),
              this.prodParam.enter(ln(s, e.generator)),
              i || (e.id = this.parseFunctionId()),
              this.parseFunctionParams(e, !1),
              this.withSmartMixTopicForbiddingContext(function () {
                t.parseFunctionBodyAndFinish(
                  e,
                  i ? "FunctionDeclaration" : "FunctionExpression"
                );
              }),
              this.prodParam.exit(),
              this.scope.exit(),
              i && !n && this.registerFunctionStatementId(e),
              (this.state.maybeInArrowParameters = o),
              e
            );
          },
        },
        {
          key: "parseFunctionId",
          value: function (e) {
            return e || jt(this.state.type) ? this.parseIdentifier() : null;
          },
        },
        {
          key: "parseFunctionParams",
          value: function (e, t) {
            this.expect(10),
              this.expressionScope.enter(new rn(3)),
              (e.params = this.parseBindingList(11, 41, 2 | (t ? 4 : 0))),
              this.expressionScope.exit();
          },
        },
        {
          key: "registerFunctionStatementId",
          value: function (e) {
            e.id &&
              this.scope.declareName(
                e.id.name,
                !this.options.annexB ||
                  this.state.strict ||
                  e.generator ||
                  e.async
                  ? this.scope.treatFunctionsAsVar
                    ? 5
                    : Tr
                  : 17,
                e.id.loc.start
              );
          },
        },
        {
          key: "parseClass",
          value: function (e, t, r) {
            this.next();
            var n = this.state.strict;
            return (
              (this.state.strict = !0),
              this.parseClassId(e, t, r),
              this.parseClassSuper(e),
              (e.body = this.parseClassBody(!!e.superClass, n)),
              this.finishNode(e, t ? "ClassDeclaration" : "ClassExpression")
            );
          },
        },
        {
          key: "isClassProperty",
          value: function () {
            return this.match(29) || this.match(13) || this.match(8);
          },
        },
        {
          key: "isClassMethod",
          value: function () {
            return this.match(10);
          },
        },
        {
          key: "isNonstaticConstructor",
          value: function (e) {
            return !(
              e.computed ||
              e.static ||
              ("constructor" !== e.key.name && "constructor" !== e.key.value)
            );
          },
        },
        {
          key: "parseClassBody",
          value: function (e, t) {
            var r = this;
            this.classScope.enter();
            var n = { hadConstructor: !1, hadSuperClass: e },
              i = [],
              a = this.startNode();
            if (
              ((a.body = []),
              this.expect(5),
              this.withSmartMixTopicForbiddingContext(function () {
                for (; !r.match(8); )
                  if (r.eat(13)) {
                    if (i.length > 0)
                      throw r.raise(pt.DecoratorSemicolon, {
                        at: r.state.lastTokEndLoc,
                      });
                  } else if (r.match(26)) i.push(r.parseDecorator());
                  else {
                    var e = r.startNode();
                    i.length &&
                      ((e.decorators = i),
                      r.resetStartLocationFromNode(e, i[0]),
                      (i = [])),
                      r.parseClassMember(a, e, n),
                      "constructor" === e.kind &&
                        e.decorators &&
                        e.decorators.length > 0 &&
                        r.raise(pt.DecoratorConstructor, { at: e });
                  }
              }),
              (this.state.strict = t),
              this.next(),
              i.length)
            )
              throw this.raise(pt.TrailingDecorator, {
                at: this.state.startLoc,
              });
            return this.classScope.exit(), this.finishNode(a, "ClassBody");
          },
        },
        {
          key: "parseClassMemberFromModifier",
          value: function (e, t) {
            var r = this.parseIdentifier(!0);
            if (this.isClassMethod()) {
              var n = t;
              return (
                (n.kind = "method"),
                (n.computed = !1),
                (n.key = r),
                (n.static = !1),
                this.pushClassMethod(e, n, !1, !1, !1, !1),
                !0
              );
            }
            if (this.isClassProperty()) {
              var i = t;
              return (
                (i.computed = !1),
                (i.key = r),
                (i.static = !1),
                e.body.push(this.parseClassProperty(i)),
                !0
              );
            }
            return this.resetPreviousNodeTrailingComments(r), !1;
          },
        },
        {
          key: "parseClassMember",
          value: function (e, t, r) {
            var n = this.isContextual(104);
            if (n) {
              if (this.parseClassMemberFromModifier(e, t)) return;
              if (this.eat(5)) return void this.parseClassStaticBlock(e, t);
            }
            this.parseClassMemberWithIsStatic(e, t, r, n);
          },
        },
        {
          key: "parseClassMemberWithIsStatic",
          value: function (e, t, r, n) {
            var i = t,
              a = t,
              s = t,
              o = t,
              l = t,
              u = i,
              c = i;
            if (
              ((t.static = n),
              this.parsePropertyNamePrefixOperator(t),
              this.eat(55))
            ) {
              u.kind = "method";
              var p = this.match(136);
              return (
                this.parseClassElementName(u),
                p
                  ? void this.pushClassPrivateMethod(e, a, !0, !1)
                  : (this.isNonstaticConstructor(i) &&
                      this.raise(pt.ConstructorIsGenerator, { at: i.key }),
                    void this.pushClassMethod(e, i, !0, !1, !1, !1))
              );
            }
            var h = jt(this.state.type) && !this.state.containsEsc,
              d = this.match(136),
              f = this.parseClassElementName(t),
              y = this.state.startLoc;
            if ((this.parsePostMemberNameModifiers(c), this.isClassMethod())) {
              if (((u.kind = "method"), d))
                return void this.pushClassPrivateMethod(e, a, !1, !1);
              var m = this.isNonstaticConstructor(i),
                v = !1;
              m &&
                ((i.kind = "constructor"),
                r.hadConstructor &&
                  !this.hasPlugin("typescript") &&
                  this.raise(pt.DuplicateConstructor, { at: f }),
                m &&
                  this.hasPlugin("typescript") &&
                  t.override &&
                  this.raise(pt.OverrideOnConstructor, { at: f }),
                (r.hadConstructor = !0),
                (v = r.hadSuperClass)),
                this.pushClassMethod(e, i, !1, !1, m, v);
            } else if (this.isClassProperty())
              d
                ? this.pushClassPrivateProperty(e, o)
                : this.pushClassProperty(e, s);
            else if (h && "async" === f.name && !this.isLineTerminator()) {
              this.resetPreviousNodeTrailingComments(f);
              var g = this.eat(55);
              c.optional && this.unexpected(y), (u.kind = "method");
              var b = this.match(136);
              this.parseClassElementName(u),
                this.parsePostMemberNameModifiers(c),
                b
                  ? this.pushClassPrivateMethod(e, a, g, !0)
                  : (this.isNonstaticConstructor(i) &&
                      this.raise(pt.ConstructorIsAsync, { at: i.key }),
                    this.pushClassMethod(e, i, g, !0, !1, !1));
            } else if (
              !h ||
              ("get" !== f.name && "set" !== f.name) ||
              (this.match(55) && this.isLineTerminator())
            )
              if (h && "accessor" === f.name && !this.isLineTerminator()) {
                this.expectPlugin("decoratorAutoAccessors"),
                  this.resetPreviousNodeTrailingComments(f);
                var T = this.match(136);
                this.parseClassElementName(s),
                  this.pushClassAccessorProperty(e, l, T);
              } else
                this.isLineTerminator()
                  ? d
                    ? this.pushClassPrivateProperty(e, o)
                    : this.pushClassProperty(e, s)
                  : this.unexpected();
            else {
              this.resetPreviousNodeTrailingComments(f), (u.kind = f.name);
              var S = this.match(136);
              this.parseClassElementName(i),
                S
                  ? this.pushClassPrivateMethod(e, a, !1, !1)
                  : (this.isNonstaticConstructor(i) &&
                      this.raise(pt.ConstructorIsAccessor, { at: i.key }),
                    this.pushClassMethod(e, i, !1, !1, !1, !1)),
                this.checkGetterSetterParams(i);
            }
          },
        },
        {
          key: "parseClassElementName",
          value: function (e) {
            var t = this.state,
              r = t.type,
              n = t.value;
            if (
              ((130 !== r && 131 !== r) ||
                !e.static ||
                "prototype" !== n ||
                this.raise(pt.StaticPrototype, { at: this.state.startLoc }),
              136 === r)
            ) {
              "constructor" === n &&
                this.raise(pt.ConstructorClassPrivateField, {
                  at: this.state.startLoc,
                });
              var i = this.parsePrivateName();
              return (e.key = i), i;
            }
            return this.parsePropertyName(e);
          },
        },
        {
          key: "parseClassStaticBlock",
          value: function (e, t) {
            var r;
            this.scope.enter(208);
            var n = this.state.labels;
            (this.state.labels = []), this.prodParam.enter(0);
            var i = (t.body = []);
            this.parseBlockOrModuleBlockBody(i, void 0, !1, 8),
              this.prodParam.exit(),
              this.scope.exit(),
              (this.state.labels = n),
              e.body.push(this.finishNode(t, "StaticBlock")),
              null != (r = t.decorators) &&
                r.length &&
                this.raise(pt.DecoratorStaticBlock, { at: t });
          },
        },
        {
          key: "pushClassProperty",
          value: function (e, t) {
            t.computed ||
              ("constructor" !== t.key.name && "constructor" !== t.key.value) ||
              this.raise(pt.ConstructorClassField, { at: t.key }),
              e.body.push(this.parseClassProperty(t));
          },
        },
        {
          key: "pushClassPrivateProperty",
          value: function (e, t) {
            var r = this.parseClassPrivateProperty(t);
            e.body.push(r),
              this.classScope.declarePrivateName(
                this.getPrivateNameSV(r.key),
                0,
                r.key.loc.start
              );
          },
        },
        {
          key: "pushClassAccessorProperty",
          value: function (e, t, r) {
            if (!r && !t.computed) {
              var n = t.key;
              ("constructor" !== n.name && "constructor" !== n.value) ||
                this.raise(pt.ConstructorClassField, { at: n });
            }
            var i = this.parseClassAccessorProperty(t);
            e.body.push(i),
              r &&
                this.classScope.declarePrivateName(
                  this.getPrivateNameSV(i.key),
                  0,
                  i.key.loc.start
                );
          },
        },
        {
          key: "pushClassMethod",
          value: function (e, t, r, n, i, a) {
            e.body.push(this.parseMethod(t, r, n, i, a, "ClassMethod", !0));
          },
        },
        {
          key: "pushClassPrivateMethod",
          value: function (e, t, r, n) {
            var i = this.parseMethod(t, r, n, !1, !1, "ClassPrivateMethod", !0);
            e.body.push(i);
            var a =
              "get" === i.kind
                ? i.static
                  ? 6
                  : 2
                : "set" === i.kind
                ? i.static
                  ? 5
                  : 1
                : 0;
            this.declareClassPrivateMethodInScope(i, a);
          },
        },
        {
          key: "declareClassPrivateMethodInScope",
          value: function (e, t) {
            this.classScope.declarePrivateName(
              this.getPrivateNameSV(e.key),
              t,
              e.key.loc.start
            );
          },
        },
        { key: "parsePostMemberNameModifiers", value: function (e) {} },
        {
          key: "parseClassPrivateProperty",
          value: function (e) {
            return (
              this.parseInitializer(e),
              this.semicolon(),
              this.finishNode(e, "ClassPrivateProperty")
            );
          },
        },
        {
          key: "parseClassProperty",
          value: function (e) {
            return (
              this.parseInitializer(e),
              this.semicolon(),
              this.finishNode(e, "ClassProperty")
            );
          },
        },
        {
          key: "parseClassAccessorProperty",
          value: function (e) {
            return (
              this.parseInitializer(e),
              this.semicolon(),
              this.finishNode(e, "ClassAccessorProperty")
            );
          },
        },
        {
          key: "parseInitializer",
          value: function (e) {
            this.scope.enter(80),
              this.expressionScope.enter(sn()),
              this.prodParam.enter(0),
              (e.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null),
              this.expressionScope.exit(),
              this.prodParam.exit(),
              this.scope.exit();
          },
        },
        {
          key: "parseClassId",
          value: function (e, t, r) {
            var n =
              arguments.length > 3 && void 0 !== arguments[3]
                ? arguments[3]
                : 8331;
            if (jt(this.state.type))
              (e.id = this.parseIdentifier()),
                t && this.declareNameFromIdentifier(e.id, n);
            else {
              if (!r && t)
                throw this.raise(pt.MissingClassName, {
                  at: this.state.startLoc,
                });
              e.id = null;
            }
          },
        },
        {
          key: "parseClassSuper",
          value: function (e) {
            e.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
          },
        },
        {
          key: "parseExport",
          value: function (e, t) {
            var r = this.maybeParseExportDefaultSpecifier(e),
              n = !r || this.eat(12),
              i = n && this.eatExportStar(e),
              a = i && this.maybeParseExportNamespaceSpecifier(e),
              s = n && (!a || this.eat(12)),
              o = r || i;
            if (i && !a) {
              if ((r && this.unexpected(), t))
                throw this.raise(pt.UnsupportedDecoratorExport, { at: e });
              return (
                this.parseExportFrom(e, !0),
                this.finishNode(e, "ExportAllDeclaration")
              );
            }
            var l,
              u = this.maybeParseExportNamedSpecifiers(e);
            if (
              (r && n && !i && !u && this.unexpected(null, 5),
              a && s && this.unexpected(null, 97),
              o || u)
            ) {
              if (((l = !1), t))
                throw this.raise(pt.UnsupportedDecoratorExport, { at: e });
              this.parseExportFrom(e, o);
            } else l = this.maybeParseExportDeclaration(e);
            if (o || u || l) {
              var c,
                p = e;
              if (
                (this.checkExport(p, !0, !1, !!p.source),
                "ClassDeclaration" ===
                  (null == (c = p.declaration) ? void 0 : c.type))
              )
                this.maybeTakeDecorators(t, p.declaration, p);
              else if (t)
                throw this.raise(pt.UnsupportedDecoratorExport, { at: e });
              return this.finishNode(p, "ExportNamedDeclaration");
            }
            if (this.eat(65)) {
              var h = e,
                d = this.parseExportDefaultExpression();
              if (((h.declaration = d), "ClassDeclaration" === d.type))
                this.maybeTakeDecorators(t, d, h);
              else if (t)
                throw this.raise(pt.UnsupportedDecoratorExport, { at: e });
              return (
                this.checkExport(h, !0, !0),
                this.finishNode(h, "ExportDefaultDeclaration")
              );
            }
            this.unexpected(null, 5);
          },
        },
        {
          key: "eatExportStar",
          value: function (e) {
            return this.eat(55);
          },
        },
        {
          key: "maybeParseExportDefaultSpecifier",
          value: function (e) {
            if (this.isExportDefaultSpecifier()) {
              this.expectPlugin("exportDefaultFrom");
              var t = this.startNode();
              return (
                (t.exported = this.parseIdentifier(!0)),
                (e.specifiers = [this.finishNode(t, "ExportDefaultSpecifier")]),
                !0
              );
            }
            return !1;
          },
        },
        {
          key: "maybeParseExportNamespaceSpecifier",
          value: function (e) {
            if (this.isContextual(93)) {
              e.specifiers || (e.specifiers = []);
              var t = this.startNodeAt(this.state.lastTokStartLoc);
              return (
                this.next(),
                (t.exported = this.parseModuleExportName()),
                e.specifiers.push(
                  this.finishNode(t, "ExportNamespaceSpecifier")
                ),
                !0
              );
            }
            return !1;
          },
        },
        {
          key: "maybeParseExportNamedSpecifiers",
          value: function (e) {
            if (this.match(5)) {
              var t;
              e.specifiers || (e.specifiers = []);
              var r = "type" === e.exportKind;
              return (
                (t = e.specifiers).push.apply(
                  t,
                  K(this.parseExportSpecifiers(r))
                ),
                (e.source = null),
                (e.declaration = null),
                this.hasPlugin("importAssertions") && (e.assertions = []),
                !0
              );
            }
            return !1;
          },
        },
        {
          key: "maybeParseExportDeclaration",
          value: function (e) {
            return (
              !!this.shouldParseExportDeclaration() &&
              ((e.specifiers = []),
              (e.source = null),
              this.hasPlugin("importAssertions") && (e.assertions = []),
              (e.declaration = this.parseExportDeclaration(e)),
              !0)
            );
          },
        },
        {
          key: "isAsyncFunction",
          value: function () {
            if (!this.isContextual(95)) return !1;
            var e = this.nextTokenStart();
            return (
              !Nr.test(this.input.slice(this.state.pos, e)) &&
              this.isUnparsedContextual(e, "function")
            );
          },
        },
        {
          key: "parseExportDefaultExpression",
          value: function () {
            var e = this.startNode();
            if (this.match(68)) return this.next(), this.parseFunction(e, 5);
            if (this.isAsyncFunction())
              return this.next(), this.next(), this.parseFunction(e, 13);
            if (this.match(80)) return this.parseClass(e, !0, !0);
            if (this.match(26))
              return (
                this.hasPlugin("decorators") &&
                  !0 ===
                    this.getPluginOption(
                      "decorators",
                      "decoratorsBeforeExport"
                    ) &&
                  this.raise(pt.DecoratorBeforeExport, {
                    at: this.state.startLoc,
                  }),
                this.parseClass(
                  this.maybeTakeDecorators(
                    this.parseDecorators(!1),
                    this.startNode()
                  ),
                  !0,
                  !0
                )
              );
            if (this.match(75) || this.match(74) || this.isLet())
              throw this.raise(pt.UnsupportedDefaultExport, {
                at: this.state.startLoc,
              });
            var t = this.parseMaybeAssignAllowIn();
            return this.semicolon(), t;
          },
        },
        {
          key: "parseExportDeclaration",
          value: function (e) {
            return this.match(80)
              ? this.parseClass(this.startNode(), !0, !1)
              : this.parseStatementListItem();
          },
        },
        {
          key: "isExportDefaultSpecifier",
          value: function () {
            var e = this.state.type;
            if (jt(e)) {
              if ((95 === e && !this.state.containsEsc) || 99 === e) return !1;
              if ((128 === e || 127 === e) && !this.state.containsEsc) {
                var t = this.lookahead().type;
                if ((jt(t) && 97 !== t) || 5 === t)
                  return this.expectOnePlugin(["flow", "typescript"]), !1;
              }
            } else if (!this.match(65)) return !1;
            var r = this.nextTokenStart(),
              n = this.isUnparsedContextual(r, "from");
            if (44 === this.input.charCodeAt(r) || (jt(this.state.type) && n))
              return !0;
            if (this.match(65) && n) {
              var i = this.input.charCodeAt(this.nextTokenStartSince(r + 4));
              return 34 === i || 39 === i;
            }
            return !1;
          },
        },
        {
          key: "parseExportFrom",
          value: function (e, t) {
            if (this.eatContextual(97)) {
              (e.source = this.parseImportSource()), this.checkExport(e);
              var r = this.maybeParseImportAssertions();
              r && ((e.assertions = r), this.checkJSONModuleImport(e));
            } else t && this.unexpected();
            this.semicolon();
          },
        },
        {
          key: "shouldParseExportDeclaration",
          value: function () {
            var e = this.state.type;
            return 26 === e &&
              (this.expectOnePlugin(["decorators", "decorators-legacy"]),
              this.hasPlugin("decorators"))
              ? (!0 ===
                  this.getPluginOption(
                    "decorators",
                    "decoratorsBeforeExport"
                  ) &&
                  this.raise(pt.DecoratorBeforeExport, {
                    at: this.state.startLoc,
                  }),
                !0)
              : 74 === e ||
                  75 === e ||
                  68 === e ||
                  80 === e ||
                  this.isLet() ||
                  this.isAsyncFunction();
          },
        },
        {
          key: "checkExport",
          value: function (e, t, r, n) {
            if (t)
              if (r) {
                if (
                  (this.checkDuplicateExports(e, "default"),
                  this.hasPlugin("exportDefaultFrom"))
                ) {
                  var i,
                    a = e.declaration;
                  "Identifier" !== a.type ||
                    "from" !== a.name ||
                    a.end - a.start != 4 ||
                    (null != (i = a.extra) && i.parenthesized) ||
                    this.raise(pt.ExportDefaultFromAsIdentifier, { at: a });
                }
              } else if (e.specifiers && e.specifiers.length) {
                var s,
                  o = He(e.specifiers);
                try {
                  for (o.s(); !(s = o.n()).done; ) {
                    var l = s.value,
                      u = l.exported,
                      c = "Identifier" === u.type ? u.name : u.value;
                    if ((this.checkDuplicateExports(l, c), !n && l.local)) {
                      var p = l.local;
                      "Identifier" !== p.type
                        ? this.raise(pt.ExportBindingIsString, {
                            at: l,
                            localName: p.value,
                            exportName: c,
                          })
                        : (this.checkReservedWord(p.name, p.loc.start, !0, !1),
                          this.scope.checkLocalExport(p));
                    }
                  }
                } catch (e) {
                  o.e(e);
                } finally {
                  o.f();
                }
              } else if (e.declaration)
                if (
                  "FunctionDeclaration" === e.declaration.type ||
                  "ClassDeclaration" === e.declaration.type
                ) {
                  var h = e.declaration.id;
                  if (!h) throw new Error("Assertion failure");
                  this.checkDuplicateExports(e, h.name);
                } else if ("VariableDeclaration" === e.declaration.type) {
                  var d,
                    f = He(e.declaration.declarations);
                  try {
                    for (f.s(); !(d = f.n()).done; ) {
                      var y = d.value;
                      this.checkDeclaration(y.id);
                    }
                  } catch (e) {
                    f.e(e);
                  } finally {
                    f.f();
                  }
                }
          },
        },
        {
          key: "checkDeclaration",
          value: function (e) {
            if ("Identifier" === e.type) this.checkDuplicateExports(e, e.name);
            else if ("ObjectPattern" === e.type) {
              var t,
                r = He(e.properties);
              try {
                for (r.s(); !(t = r.n()).done; ) {
                  var n = t.value;
                  this.checkDeclaration(n);
                }
              } catch (e) {
                r.e(e);
              } finally {
                r.f();
              }
            } else if ("ArrayPattern" === e.type) {
              var i,
                a = He(e.elements);
              try {
                for (a.s(); !(i = a.n()).done; ) {
                  var s = i.value;
                  s && this.checkDeclaration(s);
                }
              } catch (e) {
                a.e(e);
              } finally {
                a.f();
              }
            } else
              "ObjectProperty" === e.type
                ? this.checkDeclaration(e.value)
                : "RestElement" === e.type
                ? this.checkDeclaration(e.argument)
                : "AssignmentPattern" === e.type &&
                  this.checkDeclaration(e.left);
          },
        },
        {
          key: "checkDuplicateExports",
          value: function (e, t) {
            this.exportedIdentifiers.has(t) &&
              ("default" === t
                ? this.raise(pt.DuplicateDefaultExport, { at: e })
                : this.raise(pt.DuplicateExport, { at: e, exportName: t })),
              this.exportedIdentifiers.add(t);
          },
        },
        {
          key: "parseExportSpecifiers",
          value: function (e) {
            var t = [],
              r = !0;
            for (this.expect(5); !this.eat(8); ) {
              if (r) r = !1;
              else if ((this.expect(12), this.eat(8))) break;
              var n = this.isContextual(128),
                i = this.match(131),
                a = this.startNode();
              (a.local = this.parseModuleExportName()),
                t.push(this.parseExportSpecifier(a, i, e, n));
            }
            return t;
          },
        },
        {
          key: "parseExportSpecifier",
          value: function (e, t, r, n) {
            return (
              this.eatContextual(93)
                ? (e.exported = this.parseModuleExportName())
                : t
                ? (e.exported = fn(e.local))
                : e.exported || (e.exported = dn(e.local)),
              this.finishNode(e, "ExportSpecifier")
            );
          },
        },
        {
          key: "parseModuleExportName",
          value: function () {
            if (this.match(131)) {
              var e = this.parseStringLiteral(this.state.value),
                t = e.value.match(zn);
              return (
                t &&
                  this.raise(pt.ModuleExportNameHasLoneSurrogate, {
                    at: e,
                    surrogateCharCode: t[0].charCodeAt(0),
                  }),
                e
              );
            }
            return this.parseIdentifier(!0);
          },
        },
        {
          key: "isJSONModuleImport",
          value: function (e) {
            return (
              null != e.assertions &&
              e.assertions.some(function (e) {
                var t = e.key;
                return (
                  "json" === e.value.value &&
                  ("Identifier" === t.type
                    ? "type" === t.name
                    : "type" === t.value)
                );
              })
            );
          },
        },
        {
          key: "checkImportReflection",
          value: function (e) {
            var t;
            e.module &&
              ((1 === e.specifiers.length &&
                "ImportDefaultSpecifier" === e.specifiers[0].type) ||
                this.raise(pt.ImportReflectionNotBinding, {
                  at: e.specifiers[0].loc.start,
                }),
              (null == (t = e.assertions) ? void 0 : t.length) > 0 &&
                this.raise(pt.ImportReflectionHasAssertion, {
                  at: e.specifiers[0].loc.start,
                }));
          },
        },
        {
          key: "checkJSONModuleImport",
          value: function (e) {
            if (
              this.isJSONModuleImport(e) &&
              "ExportAllDeclaration" !== e.type
            ) {
              var t = e.specifiers;
              if (null != t) {
                var r = t.find(function (e) {
                  var t;
                  if (
                    ("ExportSpecifier" === e.type
                      ? (t = e.local)
                      : "ImportSpecifier" === e.type && (t = e.imported),
                    void 0 !== t)
                  )
                    return "Identifier" === t.type
                      ? "default" !== t.name
                      : "default" !== t.value;
                });
                void 0 !== r &&
                  this.raise(pt.ImportJSONBindingNotDefault, {
                    at: r.loc.start,
                  });
              }
            }
          },
        },
        {
          key: "parseMaybeImportReflection",
          value: function (e) {
            var t = !1;
            if (this.isContextual(125)) {
              var r = this.lookahead(),
                n = r.type;
              if (jt(n))
                if (97 !== n) t = !0;
                else
                  102 ===
                    this.input.charCodeAt(this.nextTokenStartSince(r.end)) &&
                    (t = !0);
              else 12 !== n && (t = !0);
            }
            t
              ? (this.expectPlugin("importReflection"),
                this.next(),
                (e.module = !0))
              : this.hasPlugin("importReflection") && (e.module = !1);
          },
        },
        {
          key: "parseImport",
          value: function (e) {
            if (((e.specifiers = []), !this.match(131))) {
              this.parseMaybeImportReflection(e);
              var t = !this.maybeParseDefaultImportSpecifier(e) || this.eat(12),
                r = t && this.maybeParseStarImportSpecifier(e);
              t && !r && this.parseNamedImportSpecifiers(e),
                this.expectContextual(97);
            }
            e.source = this.parseImportSource();
            var n = this.maybeParseImportAssertions();
            if (n) e.assertions = n;
            else {
              var i = this.maybeParseModuleAttributes();
              i && (e.attributes = i);
            }
            return (
              this.checkImportReflection(e),
              this.checkJSONModuleImport(e),
              this.semicolon(),
              this.finishNode(e, "ImportDeclaration")
            );
          },
        },
        {
          key: "parseImportSource",
          value: function () {
            return this.match(131) || this.unexpected(), this.parseExprAtom();
          },
        },
        {
          key: "shouldParseDefaultImport",
          value: function (e) {
            return jt(this.state.type);
          },
        },
        {
          key: "parseImportSpecifierLocal",
          value: function (e, t, r) {
            (t.local = this.parseIdentifier()),
              e.specifiers.push(this.finishImportSpecifier(t, r));
          },
        },
        {
          key: "finishImportSpecifier",
          value: function (e, t) {
            var r =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : Tr;
            return (
              this.checkLVal(e.local, { in: { type: t }, binding: r }),
              this.finishNode(e, t)
            );
          },
        },
        {
          key: "parseAssertEntries",
          value: function () {
            var e = [],
              t = new Set();
            do {
              if (this.match(8)) break;
              var r = this.startNode(),
                n = this.state.value;
              if (
                (t.has(n) &&
                  this.raise(pt.ModuleAttributesWithDuplicateKeys, {
                    at: this.state.startLoc,
                    key: n,
                  }),
                t.add(n),
                this.match(131)
                  ? (r.key = this.parseStringLiteral(n))
                  : (r.key = this.parseIdentifier(!0)),
                this.expect(14),
                !this.match(131))
              )
                throw this.raise(pt.ModuleAttributeInvalidValue, {
                  at: this.state.startLoc,
                });
              (r.value = this.parseStringLiteral(this.state.value)),
                e.push(this.finishNode(r, "ImportAttribute"));
            } while (this.eat(12));
            return e;
          },
        },
        {
          key: "maybeParseModuleAttributes",
          value: function () {
            if (!this.match(76) || this.hasPrecedingLineBreak())
              return this.hasPlugin("moduleAttributes") ? [] : null;
            this.expectPlugin("moduleAttributes"), this.next();
            var e = [],
              t = new Set();
            do {
              var r = this.startNode();
              if (
                ((r.key = this.parseIdentifier(!0)),
                "type" !== r.key.name &&
                  this.raise(pt.ModuleAttributeDifferentFromType, {
                    at: r.key,
                  }),
                t.has(r.key.name) &&
                  this.raise(pt.ModuleAttributesWithDuplicateKeys, {
                    at: r.key,
                    key: r.key.name,
                  }),
                t.add(r.key.name),
                this.expect(14),
                !this.match(131))
              )
                throw this.raise(pt.ModuleAttributeInvalidValue, {
                  at: this.state.startLoc,
                });
              (r.value = this.parseStringLiteral(this.state.value)),
                this.finishNode(r, "ImportAttribute"),
                e.push(r);
            } while (this.eat(12));
            return e;
          },
        },
        {
          key: "maybeParseImportAssertions",
          value: function () {
            if (!this.isContextual(94) || this.hasPrecedingLineBreak())
              return this.hasPlugin("importAssertions") ? [] : null;
            this.expectPlugin("importAssertions"), this.next(), this.eat(5);
            var e = this.parseAssertEntries();
            return this.eat(8), e;
          },
        },
        {
          key: "maybeParseDefaultImportSpecifier",
          value: function (e) {
            return (
              !!this.shouldParseDefaultImport(e) &&
              (this.parseImportSpecifierLocal(
                e,
                this.startNode(),
                "ImportDefaultSpecifier"
              ),
              !0)
            );
          },
        },
        {
          key: "maybeParseStarImportSpecifier",
          value: function (e) {
            if (this.match(55)) {
              var t = this.startNode();
              return (
                this.next(),
                this.expectContextual(93),
                this.parseImportSpecifierLocal(
                  e,
                  t,
                  "ImportNamespaceSpecifier"
                ),
                !0
              );
            }
            return !1;
          },
        },
        {
          key: "parseNamedImportSpecifiers",
          value: function (e) {
            var t = !0;
            for (this.expect(5); !this.eat(8); ) {
              if (t) t = !1;
              else {
                if (this.eat(14))
                  throw this.raise(pt.DestructureNamedImport, {
                    at: this.state.startLoc,
                  });
                if ((this.expect(12), this.eat(8))) break;
              }
              var r = this.startNode(),
                n = this.match(131),
                i = this.isContextual(128);
              r.imported = this.parseModuleExportName();
              var a = this.parseImportSpecifier(
                r,
                n,
                "type" === e.importKind || "typeof" === e.importKind,
                i,
                void 0
              );
              e.specifiers.push(a);
            }
          },
        },
        {
          key: "parseImportSpecifier",
          value: function (e, t, r, n, i) {
            if (this.eatContextual(93)) e.local = this.parseIdentifier();
            else {
              var a = e.imported;
              if (t)
                throw this.raise(pt.ImportBindingIsString, {
                  at: e,
                  importName: a.value,
                });
              this.checkReservedWord(a.name, e.loc.start, !0, !0),
                e.local || (e.local = dn(a));
            }
            return this.finishImportSpecifier(e, "ImportSpecifier", i);
          },
        },
        {
          key: "isThisParam",
          value: function (e) {
            return "Identifier" === e.type && "this" === e.name;
          },
        },
      ]),
      r
    );
  })(),
  Zn = (function (e) {
    I(r, Qn);
    var t = Je(r);
    function r(e, n) {
      var i;
      return (
        E(this, r),
        (e = (function (e) {
          if (e && null != e.annexB && !1 !== e.annexB)
            throw new Error("The `annexB` option can only be set to `false`.");
          for (var t = {}, r = 0, n = Object.keys(Yn); r < n.length; r++) {
            var i = n[r];
            t[i] = e && null != e[i] ? e[i] : Yn[i];
          }
          return t;
        })(e)),
        ((i = t.call(this, e, n)).options = e),
        i.initializeScopes(),
        (i.plugins = (function (e) {
          var t,
            r = new Map(),
            n = He(e);
          try {
            for (n.s(); !(t = n.n()).done; ) {
              var i = t.value,
                a = H(Array.isArray(i) ? i : [i, {}], 2),
                s = a[0],
                o = a[1];
              r.has(s) || r.set(s, o || {});
            }
          } catch (e) {
            n.e(e);
          } finally {
            n.f();
          }
          return r;
        })(i.options.plugins)),
        (i.filename = e.sourceFilename),
        i
      );
    }
    return (
      A(r, [
        {
          key: "getScopeHandler",
          value: function () {
            return Er;
          },
        },
        {
          key: "parse",
          value: function () {
            this.enterInitialScopes();
            var e = this.startNode(),
              t = this.startNode();
            return (
              this.nextToken(),
              (e.errors = null),
              this.parseTopLevel(e, t),
              (e.errors = this.state.errors),
              e
            );
          },
        },
      ]),
      r
    );
  })();
var ei = (function (e) {
  for (var t = {}, r = 0, n = Object.keys(e); r < n.length; r++) {
    var i = n[r];
    t[i] = Ht(e[i]);
  }
  return t;
})(Mt);
function ti(e, t) {
  var r = Zn;
  return (
    null != e &&
      e.plugins &&
      (!(function (e) {
        if (Rn(e, "decorators")) {
          if (Rn(e, "decorators-legacy"))
            throw new Error(
              "Cannot use the decorators and decorators-legacy plugin together"
            );
          var t = Un(e, "decorators", "decoratorsBeforeExport");
          if (null != t && "boolean" != typeof t)
            throw new Error(
              "'decoratorsBeforeExport' must be a boolean, if specified."
            );
          var r = Un(e, "decorators", "allowCallParenthesized");
          if (null != r && "boolean" != typeof r)
            throw new Error("'allowCallParenthesized' must be a boolean.");
        }
        if (Rn(e, "flow") && Rn(e, "typescript"))
          throw new Error("Cannot combine flow and typescript plugins.");
        if (Rn(e, "placeholders") && Rn(e, "v8intrinsic"))
          throw new Error(
            "Cannot combine placeholders and v8intrinsic plugins."
          );
        if (Rn(e, "pipelineOperator")) {
          var n = Un(e, "pipelineOperator", "proposal");
          if (!Vn.includes(n)) {
            var i = Vn.map(function (e) {
              return '"'.concat(e, '"');
            }).join(", ");
            throw new Error(
              '"pipelineOperator" requires "proposal" option whose value must be one of: '.concat(
                i,
                "."
              )
            );
          }
          var a = Rn(e, ["recordAndTuple", { syntaxType: "hash" }]);
          if ("hack" === n) {
            if (Rn(e, "placeholders"))
              throw new Error(
                "Cannot combine placeholders plugin and Hack-style pipes."
              );
            if (Rn(e, "v8intrinsic"))
              throw new Error(
                "Cannot combine v8intrinsic plugin and Hack-style pipes."
              );
            var s = Un(e, "pipelineOperator", "topicToken");
            if (!Kn.includes(s)) {
              var o = Kn.map(function (e) {
                return '"'.concat(e, '"');
              }).join(", ");
              throw new Error(
                '"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: '.concat(
                  o,
                  "."
                )
              );
            }
            if ("#" === s && a)
              throw new Error(
                'Plugin conflict between `["pipelineOperator", { proposal: "hack", topicToken: "#" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
              );
          } else if ("smart" === n && a)
            throw new Error(
              'Plugin conflict between `["pipelineOperator", { proposal: "smart" }]` and `["recordAndtuple", { syntaxType: "hash"}]`.'
            );
        }
        if (Rn(e, "moduleAttributes")) {
          if (Rn(e, "importAssertions"))
            throw new Error(
              "Cannot combine importAssertions and moduleAttributes plugins."
            );
          if ("may-2020" !== Un(e, "moduleAttributes", "version"))
            throw new Error(
              "The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'."
            );
        }
        if (
          Rn(e, "recordAndTuple") &&
          null != Un(e, "recordAndTuple", "syntaxType") &&
          !Wn.includes(Un(e, "recordAndTuple", "syntaxType"))
        )
          throw new Error(
            "The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " +
              Wn.map(function (e) {
                return "'".concat(e, "'");
              }).join(", ")
          );
        if (Rn(e, "asyncDoExpressions") && !Rn(e, "doExpressions")) {
          var l = new Error(
            "'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins."
          );
          throw ((l.missingPlugins = "doExpressions"), l);
        }
      })(e.plugins),
      (r = (function (e) {
        var t = Hn.filter(function (t) {
            return Rn(e, t);
          }),
          r = t.join("/"),
          n = ri[r];
        if (!n) {
          n = Zn;
          var i,
            a = He(t);
          try {
            for (a.s(); !(i = a.n()).done; ) {
              var s = i.value;
              n = qn[s](n);
            }
          } catch (e) {
            a.e(e);
          } finally {
            a.f();
          }
          ri[r] = n;
        }
        return n;
      })(e.plugins))),
    new r(e, t)
  );
}
var ri = {};
var ni = (qe.parse = function (e, t) {
  var r;
  if ("unambiguous" !== (null == (r = t) ? void 0 : r.sourceType))
    return ti(t, e).parse();
  t = Object.assign({}, t);
  try {
    t.sourceType = "module";
    var n = ti(t, e),
      i = n.parse();
    if (n.sawUnambiguousESM) return i;
    if (n.ambiguousScriptDifferentAst)
      try {
        return (t.sourceType = "script"), ti(t, e).parse();
      } catch (e) {}
    else i.program.sourceType = "script";
    return i;
  } catch (r) {
    try {
      return (t.sourceType = "script"), ti(t, e).parse();
    } catch (e) {}
    throw r;
  }
});
(qe.parseExpression = function (e, t) {
  var r = ti(t, e);
  return r.options.strictMode && (r.state.strict = !0), r.getExpression();
}),
  (qe.tokTypes = ei);
var ii,
  ai = {},
  si = {},
  oi = { exports: {} },
  li = { exports: {} };
function ui() {
  return (
    ii ||
      ((ii = 1),
      (function (e) {
        (e.get = void 0), (e.put = void 0), (e.pop = void 0);
        var t = A(function e() {
          E(this, e), (this._indexes = { __proto__: null }), (this.array = []);
        });
        (e.get = function (e, t) {
          return e._indexes[t];
        }),
          (e.put = function (t, r) {
            var n = e.get(t, r);
            if (void 0 !== n) return n;
            var i = t.array;
            return (t._indexes[r] = i.push(r) - 1);
          }),
          (e.pop = function (e) {
            var t = e.array,
              r = e._indexes;
            0 !== t.length && (r[t.pop()] = void 0);
          }),
          (e.SetArray = t),
          Object.defineProperty(e, "__esModule", { value: !0 });
      })(li.exports)),
    li.exports
  );
}
var ci,
  pi = { exports: {} };
function hi() {
  return (
    ci ||
      ((ci = 1),
      (function (e) {
        for (
          var t = ",".charCodeAt(0),
            r = ";".charCodeAt(0),
            n =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            i = new Uint8Array(64),
            a = new Uint8Array(128),
            s = 0;
          s < n.length;
          s++
        ) {
          var o = n.charCodeAt(s);
          (i[s] = o), (a[o] = s);
        }
        var l =
          "undefined" != typeof TextDecoder
            ? new TextDecoder()
            : "undefined" != typeof Buffer
            ? {
                decode: function (e) {
                  return Buffer.from(
                    e.buffer,
                    e.byteOffset,
                    e.byteLength
                  ).toString();
                },
              }
            : {
                decode: function (e) {
                  for (var t = "", r = 0; r < e.length; r++)
                    t += String.fromCharCode(e[r]);
                  return t;
                },
              };
        function u(e) {
          var t = new Int32Array(5),
            r = [],
            n = 0;
          do {
            var i = c(e, n),
              a = [],
              s = !0,
              o = 0;
            t[0] = 0;
            for (var l = n; l < i; l++) {
              var u = void 0;
              l = p(e, l, t, 0);
              var f = t[0];
              f < o && (s = !1),
                (o = f),
                h(e, l, i)
                  ? ((l = p(e, l, t, 1)),
                    (l = p(e, l, t, 2)),
                    h(e, (l = p(e, l, t, 3)), i)
                      ? ((l = p(e, l, t, 4)), (u = [f, t[1], t[2], t[3], t[4]]))
                      : (u = [f, t[1], t[2], t[3]]))
                  : (u = [f]),
                a.push(u);
            }
            s || d(a), r.push(a), (n = i + 1);
          } while (n <= e.length);
          return r;
        }
        function c(e, t) {
          var r = e.indexOf(";", t);
          return -1 === r ? e.length : r;
        }
        function p(e, t, r, n) {
          var i = 0,
            s = 0,
            o = 0;
          do {
            var l = e.charCodeAt(t++);
            (i |= (31 & (o = a[l])) << s), (s += 5);
          } while (32 & o);
          var u = 1 & i;
          return (i >>>= 1), u && (i = -2147483648 | -i), (r[n] += i), t;
        }
        function h(e, r, n) {
          return !(r >= n) && e.charCodeAt(r) !== t;
        }
        function d(e) {
          e.sort(f);
        }
        function f(e, t) {
          return e[0] - t[0];
        }
        function y(e) {
          for (
            var n = new Int32Array(5),
              i = 16384,
              a = i - 36,
              s = new Uint8Array(i),
              o = s.subarray(0, a),
              u = 0,
              c = "",
              p = 0;
            p < e.length;
            p++
          ) {
            var h = e[p];
            if (
              (p > 0 &&
                (u === i && ((c += l.decode(s)), (u = 0)), (s[u++] = r)),
              0 !== h.length)
            ) {
              n[0] = 0;
              for (var d = 0; d < h.length; d++) {
                var f = h[d];
                u > a && ((c += l.decode(o)), s.copyWithin(0, a, u), (u -= a)),
                  d > 0 && (s[u++] = t),
                  (u = m(s, u, n, f, 0)),
                  1 !== f.length &&
                    ((u = m(s, u, n, f, 1)),
                    (u = m(s, u, n, f, 2)),
                    (u = m(s, u, n, f, 3)),
                    4 !== f.length && (u = m(s, u, n, f, 4)));
              }
            }
          }
          return c + l.decode(s.subarray(0, u));
        }
        function m(e, t, r, n, a) {
          var s = n[a],
            o = s - r[a];
          (r[a] = s), (o = o < 0 ? (-o << 1) | 1 : o << 1);
          do {
            var l = 31 & o;
            (o >>>= 5) > 0 && (l |= 32), (e[t++] = i[l]);
          } while (o > 0);
          return t;
        }
        (e.decode = u),
          (e.encode = y),
          Object.defineProperty(e, "__esModule", { value: !0 });
      })(pi.exports)),
    pi.exports
  );
}
var di,
  fi = { exports: {} },
  yi = { exports: {} };
function mi() {
  return (
    di ||
      ((di = 1),
      (function (e) {
        for (
          var t = ",".charCodeAt(0),
            r = ";".charCodeAt(0),
            n =
              "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
            i = new Uint8Array(64),
            a = new Uint8Array(128),
            s = 0;
          s < n.length;
          s++
        ) {
          var o = n.charCodeAt(s);
          (i[s] = o), (a[o] = s);
        }
        var l =
          "undefined" != typeof TextDecoder
            ? new TextDecoder()
            : "undefined" != typeof Buffer
            ? {
                decode: function (e) {
                  return Buffer.from(
                    e.buffer,
                    e.byteOffset,
                    e.byteLength
                  ).toString();
                },
              }
            : {
                decode: function (e) {
                  for (var t = "", r = 0; r < e.length; r++)
                    t += String.fromCharCode(e[r]);
                  return t;
                },
              };
        function u(e) {
          var t = new Int32Array(5),
            r = [],
            n = 0;
          do {
            var i = c(e, n),
              a = [],
              s = !0,
              o = 0;
            t[0] = 0;
            for (var l = n; l < i; l++) {
              var u = void 0;
              l = p(e, l, t, 0);
              var f = t[0];
              f < o && (s = !1),
                (o = f),
                h(e, l, i)
                  ? ((l = p(e, l, t, 1)),
                    (l = p(e, l, t, 2)),
                    h(e, (l = p(e, l, t, 3)), i)
                      ? ((l = p(e, l, t, 4)), (u = [f, t[1], t[2], t[3], t[4]]))
                      : (u = [f, t[1], t[2], t[3]]))
                  : (u = [f]),
                a.push(u);
            }
            s || d(a), r.push(a), (n = i + 1);
          } while (n <= e.length);
          return r;
        }
        function c(e, t) {
          var r = e.indexOf(";", t);
          return -1 === r ? e.length : r;
        }
        function p(e, t, r, n) {
          var i = 0,
            s = 0,
            o = 0;
          do {
            var l = e.charCodeAt(t++);
            (i |= (31 & (o = a[l])) << s), (s += 5);
          } while (32 & o);
          var u = 1 & i;
          return (i >>>= 1), u && (i = -2147483648 | -i), (r[n] += i), t;
        }
        function h(e, r, n) {
          return !(r >= n) && e.charCodeAt(r) !== t;
        }
        function d(e) {
          e.sort(f);
        }
        function f(e, t) {
          return e[0] - t[0];
        }
        function y(e) {
          for (
            var n = new Int32Array(5),
              i = 16384,
              a = i - 36,
              s = new Uint8Array(i),
              o = s.subarray(0, a),
              u = 0,
              c = "",
              p = 0;
            p < e.length;
            p++
          ) {
            var h = e[p];
            if (
              (p > 0 &&
                (u === i && ((c += l.decode(s)), (u = 0)), (s[u++] = r)),
              0 !== h.length)
            ) {
              n[0] = 0;
              for (var d = 0; d < h.length; d++) {
                var f = h[d];
                u > a && ((c += l.decode(o)), s.copyWithin(0, a, u), (u -= a)),
                  d > 0 && (s[u++] = t),
                  (u = m(s, u, n, f, 0)),
                  1 !== f.length &&
                    ((u = m(s, u, n, f, 1)),
                    (u = m(s, u, n, f, 2)),
                    (u = m(s, u, n, f, 3)),
                    4 !== f.length && (u = m(s, u, n, f, 4)));
              }
            }
          }
          return c + l.decode(s.subarray(0, u));
        }
        function m(e, t, r, n, a) {
          var s = n[a],
            o = s - r[a];
          (r[a] = s), (o = o < 0 ? (-o << 1) | 1 : o << 1);
          do {
            var l = 31 & o;
            (o >>>= 5) > 0 && (l |= 32), (e[t++] = i[l]);
          } while (o > 0);
          return t;
        }
        (e.decode = u),
          (e.encode = y),
          Object.defineProperty(e, "__esModule", { value: !0 });
      })(yi.exports)),
    yi.exports
  );
}
var vi,
  gi = { exports: {} };
function bi() {
  return (
    vi ||
      ((vi = 1),
      (gi.exports = (function () {
        var e,
          t = /^[\w+.-]+:\/\//,
          r =
            /^([\w+.-]+:)\/\/([^@/#?]*@)?([^:/#?]*)(:\d+)?(\/[^#?]*)?(\?[^#]*)?(#.*)?/,
          n = /^file:(?:\/\/((?![a-z]:)[^/#?]*)?)?(\/?[^#?]*)(\?[^#]*)?(#.*)?/i;
        function i(e) {
          return t.test(e);
        }
        function a(e) {
          return e.startsWith("//");
        }
        function s(e) {
          return e.startsWith("/");
        }
        function o(e) {
          return e.startsWith("file:");
        }
        function l(e) {
          return /^[.?#]/.test(e);
        }
        function u(e) {
          var t = r.exec(e);
          return p(
            t[1],
            t[2] || "",
            t[3],
            t[4] || "",
            t[5] || "/",
            t[6] || "",
            t[7] || ""
          );
        }
        function c(e) {
          var t = n.exec(e),
            r = t[2];
          return p(
            "file:",
            "",
            t[1] || "",
            "",
            s(r) ? r : "/" + r,
            t[3] || "",
            t[4] || ""
          );
        }
        function p(t, r, n, i, a, s, o) {
          return {
            scheme: t,
            user: r,
            host: n,
            port: i,
            path: a,
            query: s,
            hash: o,
            type: e.Absolute,
          };
        }
        function h(t) {
          if (a(t)) {
            var r = u("http:" + t);
            return (r.scheme = ""), (r.type = e.SchemeRelative), r;
          }
          if (s(t)) {
            var n = u("http://foo.com" + t);
            return (n.scheme = ""), (n.host = ""), (n.type = e.AbsolutePath), n;
          }
          if (o(t)) return c(t);
          if (i(t)) return u(t);
          var l = u("http://foo.com/" + t);
          return (
            (l.scheme = ""),
            (l.host = ""),
            (l.type = t
              ? t.startsWith("?")
                ? e.Query
                : t.startsWith("#")
                ? e.Hash
                : e.RelativePath
              : e.Empty),
            l
          );
        }
        function d(e) {
          if (e.endsWith("/..")) return e;
          var t = e.lastIndexOf("/");
          return e.slice(0, t + 1);
        }
        function f(e, t) {
          y(t, t.type),
            "/" === e.path ? (e.path = t.path) : (e.path = d(t.path) + e.path);
        }
        function y(t, r) {
          for (
            var n = r <= e.RelativePath,
              i = t.path.split("/"),
              a = 1,
              s = 0,
              o = !1,
              l = 1;
            l < i.length;
            l++
          ) {
            var u = i[l];
            u
              ? ((o = !1),
                "." !== u &&
                  (".." !== u
                    ? ((i[a++] = u), s++)
                    : s
                    ? ((o = !0), s--, a--)
                    : n && (i[a++] = u)))
              : (o = !0);
          }
          for (var c = "", p = 1; p < a; p++) c += "/" + i[p];
          (!c || (o && !c.endsWith("/.."))) && (c += "/"), (t.path = c);
        }
        function m(t, r) {
          if (!t && !r) return "";
          var n = h(t),
            i = n.type;
          if (r && i !== e.Absolute) {
            var a = h(r),
              s = a.type;
            switch (i) {
              case e.Empty:
                n.hash = a.hash;
              case e.Hash:
                n.query = a.query;
              case e.Query:
              case e.RelativePath:
                f(n, a);
              case e.AbsolutePath:
                (n.user = a.user), (n.host = a.host), (n.port = a.port);
              case e.SchemeRelative:
                n.scheme = a.scheme;
            }
            s > i && (i = s);
          }
          y(n, i);
          var o = n.query + n.hash;
          switch (i) {
            case e.Hash:
            case e.Query:
              return o;
            case e.RelativePath:
              var u = n.path.slice(1);
              return u ? (l(r || t) && !l(u) ? "./" + u + o : u + o) : o || ".";
            case e.AbsolutePath:
              return n.path + o;
            default:
              return n.scheme + "//" + n.user + n.host + n.port + n.path + o;
          }
        }
        return (
          (function (e) {
            (e[(e.Empty = 1)] = "Empty"),
              (e[(e.Hash = 2)] = "Hash"),
              (e[(e.Query = 3)] = "Query"),
              (e[(e.RelativePath = 4)] = "RelativePath"),
              (e[(e.AbsolutePath = 5)] = "AbsolutePath"),
              (e[(e.SchemeRelative = 6)] = "SchemeRelative"),
              (e[(e.Absolute = 7)] = "Absolute");
          })(e || (e = {})),
          m
        );
      })())),
    gi.exports
  );
}
!(function (e, t, r) {
  function n(e) {
    return e && "object" === g(e) && "default" in e ? e : { default: e };
  }
  var i = n(r);
  function a(e, t) {
    return t && !t.endsWith("/") && (t += "/"), i.default(e, t);
  }
  function s(e) {
    if (!e) return "";
    var t = e.lastIndexOf("/");
    return e.slice(0, t + 1);
  }
  var o = 0,
    l = 1,
    u = 2,
    c = 3,
    p = 4,
    h = 1,
    d = 2;
  function f(e, t) {
    var r = y(e, 0);
    if (r === e.length) return e;
    t || (e = e.slice());
    for (var n = r; n < e.length; n = y(e, n + 1)) e[n] = v(e[n], t);
    return e;
  }
  function y(e, t) {
    for (var r = t; r < e.length; r++) if (!m(e[r])) return r;
    return e.length;
  }
  function m(e) {
    for (var t = 1; t < e.length; t++) if (e[t][o] < e[t - 1][o]) return !1;
    return !0;
  }
  function v(e, t) {
    return t || (e = e.slice()), e.sort(b);
  }
  function b(e, t) {
    return e[o] - t[o];
  }
  var T = !1;
  function S(e, t, r, n) {
    for (; r <= n; ) {
      var i = r + ((n - r) >> 1),
        a = e[i][o] - t;
      if (0 === a) return (T = !0), i;
      a < 0 ? (r = i + 1) : (n = i - 1);
    }
    return (T = !1), r - 1;
  }
  function x(e, t, r) {
    for (var n = r + 1; n < e.length && e[n][o] === t; r = n++);
    return r;
  }
  function P(e, t, r) {
    for (var n = r - 1; n >= 0 && e[n][o] === t; r = n--);
    return r;
  }
  function k() {
    return { lastKey: -1, lastNeedle: -1, lastIndex: -1 };
  }
  function w(e, t, r, n) {
    var i = r.lastKey,
      a = r.lastNeedle,
      s = r.lastIndex,
      l = 0,
      u = e.length - 1;
    if (n === i) {
      if (t === a) return (T = -1 !== s && e[s][o] === t), s;
      t >= a ? (l = -1 === s ? 0 : s) : (u = s);
    }
    return (r.lastKey = n), (r.lastNeedle = t), (r.lastIndex = S(e, t, l, u));
  }
  function C(e, t) {
    for (var r = t.map(O), n = 0; n < e.length; n++)
      for (var i = e[n], a = 0; a < i.length; a++) {
        var s = i[a];
        if (1 !== s.length) {
          var p = s[l],
            h = s[u],
            d = s[c],
            f = r[p],
            y = f[h] || (f[h] = []),
            m = t[p],
            v = x(y, d, w(y, d, m, h));
          I(y, (m.lastIndex = v + 1), [d, n, s[o]]);
        }
      }
    return r;
  }
  function I(e, t, r) {
    for (var n = e.length; n > t; n--) e[n] = e[n - 1];
    e[t] = r;
  }
  function O() {
    return { __proto__: null };
  }
  var N = function (t, r) {
    var n = "string" == typeof t ? JSON.parse(t) : t;
    if (!("sections" in n)) return new U(n, r);
    var i = [],
      a = [],
      s = [],
      o = [];
    _(n, r, i, a, s, o, 0, 0, 1 / 0, 1 / 0);
    var l = {
      version: 3,
      file: n.file,
      names: o,
      sources: a,
      sourcesContent: s,
      mappings: i,
    };
    return e.presortedDecodedMap(l);
  };
  function _(e, t, r, n, i, a, s, o, l, u) {
    for (var c = e.sections, p = 0; p < c.length; p++) {
      var h = c[p],
        d = h.map,
        f = h.offset,
        y = l,
        m = u;
      if (p + 1 < c.length) {
        var v = c[p + 1].offset;
        (y = Math.min(l, s + v.line)) === l
          ? (m = Math.min(u, o + v.column))
          : y < l && (m = o + v.column);
      }
      D(d, t, r, n, i, a, s + f.line, o + f.column, y, m);
    }
  }
  function D(t, r, n, i, a, s, h, d, f, y) {
    if ("sections" in t) return _.apply(void 0, arguments);
    var m = new U(t, r),
      v = i.length,
      g = s.length,
      b = e.decodedMappings(m),
      T = m.resolvedSources,
      S = m.sourcesContent;
    if ((L(i, T), L(s, m.names), S)) L(a, S);
    else for (var x = 0; x < T.length; x++) a.push(null);
    for (var E = 0; E < b.length; E++) {
      var P = h + E;
      if (P > f) return;
      for (
        var A = M(n, P), k = 0 === E ? d : 0, w = b[E], C = 0;
        C < w.length;
        C++
      ) {
        var I = w[C],
          O = k + I[o];
        if (P === f && O >= y) return;
        if (1 !== I.length) {
          var N = v + I[l],
            D = I[u],
            j = I[c];
          A.push(4 === I.length ? [O, N, D, j] : [O, N, D, j, g + I[p]]);
        } else A.push([O]);
      }
    }
  }
  function L(e, t) {
    for (var r = 0; r < t.length; r++) e.push(t[r]);
  }
  function M(e, t) {
    for (var r = e.length; r <= t; r++) e[r] = [];
    return e[t];
  }
  var j = "`line` must be greater than 0 (lines start at line 1)",
    F =
      "`column` must be greater than or equal to 0 (columns start at column 0)",
    B = -1,
    R = 1;
  (e.encodedMappings = void 0),
    (e.decodedMappings = void 0),
    (e.traceSegment = void 0),
    (e.originalPositionFor = void 0),
    (e.generatedPositionFor = void 0),
    (e.allGeneratedPositionsFor = void 0),
    (e.eachMapping = void 0),
    (e.sourceContentFor = void 0),
    (e.presortedDecodedMap = void 0),
    (e.decodedMap = void 0),
    (e.encodedMap = void 0);
  var U = A(function e(t, r) {
    E(this, e);
    var n = "string" == typeof t;
    if (!n && t._decodedMemo) return t;
    var i = n ? JSON.parse(t) : t,
      o = i.version,
      l = i.file,
      u = i.names,
      c = i.sourceRoot,
      p = i.sources,
      h = i.sourcesContent;
    (this.version = o),
      (this.file = l),
      (this.names = u),
      (this.sourceRoot = c),
      (this.sources = p),
      (this.sourcesContent = h);
    var d = a(c || "", s(r));
    this.resolvedSources = p.map(function (e) {
      return a(e || "", d);
    });
    var y = i.mappings;
    "string" == typeof y
      ? ((this._encoded = y), (this._decoded = void 0))
      : ((this._encoded = void 0), (this._decoded = f(y, n))),
      (this._decodedMemo = k()),
      (this._bySources = void 0),
      (this._bySourceMemos = void 0);
  });
  function V(e, t) {
    return {
      version: e.version,
      file: e.file,
      names: e.names,
      sourceRoot: e.sourceRoot,
      sources: e.sources,
      sourcesContent: e.sourcesContent,
      mappings: t,
    };
  }
  function K(e, t, r, n) {
    return { source: e, line: t, column: r, name: n };
  }
  function W(e, t) {
    return { line: e, column: t };
  }
  function q(e, t, r, n, i) {
    var a = w(e, n, t, r);
    return (
      T ? (a = (i === B ? x : P)(e, n, a)) : i === B && a++,
      -1 === a || a === e.length ? -1 : a
    );
  }
  function H(e, t, r, n, i) {
    var a = q(e, t, r, n, R);
    if ((T || i !== B || a++, -1 === a || a === e.length)) return [];
    var s = T ? n : e[a][o];
    T || (a = P(e, s, a));
    for (var l = x(e, s, a), u = []; a <= l; a++) {
      var c = e[a];
      u.push(W(c[h] + 1, c[d]));
    }
    return u;
  }
  (function () {
    function r(t, r, n, i, a, s) {
      if (--n < 0) throw new Error(j);
      if (i < 0) throw new Error(F);
      var o = t.sources,
        l = t.resolvedSources,
        u = o.indexOf(r);
      if ((-1 === u && (u = l.indexOf(r)), -1 === u))
        return s ? [] : W(null, null);
      var c = (t._bySources ||
        (t._bySources = C(
          e.decodedMappings(t),
          (t._bySourceMemos = o.map(k))
        )))[u][n];
      if (null == c) return s ? [] : W(null, null);
      var p = t._bySourceMemos[u];
      if (s) return H(c, p, n, i, a);
      var f = q(c, p, n, i, a);
      if (-1 === f) return W(null, null);
      var y = c[f];
      return W(y[h] + 1, y[d]);
    }
    (e.encodedMappings = function (e) {
      var r;
      return null !== (r = e._encoded) && void 0 !== r
        ? r
        : (e._encoded = t.encode(e._decoded));
    }),
      (e.decodedMappings = function (e) {
        return e._decoded || (e._decoded = t.decode(e._encoded));
      }),
      (e.traceSegment = function (t, r, n) {
        var i = e.decodedMappings(t);
        if (r >= i.length) return null;
        var a = i[r],
          s = q(a, t._decodedMemo, r, n, R);
        return -1 === s ? null : a[s];
      }),
      (e.originalPositionFor = function (t, r) {
        var n = r.line,
          i = r.column,
          a = r.bias;
        if (--n < 0) throw new Error(j);
        if (i < 0) throw new Error(F);
        var s = e.decodedMappings(t);
        if (n >= s.length) return K(null, null, null, null);
        var o = s[n],
          h = q(o, t._decodedMemo, n, i, a || R);
        if (-1 === h) return K(null, null, null, null);
        var d = o[h];
        if (1 === d.length) return K(null, null, null, null);
        var f = t.names;
        return K(
          t.resolvedSources[d[l]],
          d[u] + 1,
          d[c],
          5 === d.length ? f[d[p]] : null
        );
      }),
      (e.allGeneratedPositionsFor = function (e, t) {
        return r(e, t.source, t.line, t.column, t.bias || B, !0);
      }),
      (e.generatedPositionFor = function (e, t) {
        return r(e, t.source, t.line, t.column, t.bias || R, !1);
      }),
      (e.eachMapping = function (t, r) {
        for (
          var n = e.decodedMappings(t),
            i = t.names,
            a = t.resolvedSources,
            s = 0;
          s < n.length;
          s++
        )
          for (var o = n[s], l = 0; l < o.length; l++) {
            var u = o[l],
              c = s + 1,
              p = u[0],
              h = null,
              d = null,
              f = null,
              y = null;
            1 !== u.length && ((h = a[u[1]]), (d = u[2] + 1), (f = u[3])),
              5 === u.length && (y = i[u[4]]),
              r({
                generatedLine: c,
                generatedColumn: p,
                source: h,
                originalLine: d,
                originalColumn: f,
                name: y,
              });
          }
      }),
      (e.sourceContentFor = function (e, t) {
        var r = e.sources,
          n = e.resolvedSources,
          i = e.sourcesContent;
        if (null == i) return null;
        var a = r.indexOf(t);
        return -1 === a && (a = n.indexOf(t)), -1 === a ? null : i[a];
      }),
      (e.presortedDecodedMap = function (e, t) {
        var r = new U(V(e, []), t);
        return (r._decoded = e.mappings), r;
      }),
      (e.decodedMap = function (t) {
        return V(t, e.decodedMappings(t));
      }),
      (e.encodedMap = function (t) {
        return V(t, e.encodedMappings(t));
      });
  })(),
    (e.AnyMap = N),
    (e.GREATEST_LOWER_BOUND = R),
    (e.LEAST_UPPER_BOUND = B),
    (e.TraceMap = U),
    Object.defineProperty(e, "__esModule", { value: !0 });
})(fi.exports, mi(), bi()),
  (function (e, t, r, n) {
    var i,
      a = 0,
      s = 1,
      o = 2,
      l = 3,
      u = 4,
      c = -1;
    (e.addSegment = void 0),
      (e.addMapping = void 0),
      (e.maybeAddSegment = void 0),
      (e.maybeAddMapping = void 0),
      (e.setSourceContent = void 0),
      (e.toDecodedMap = void 0),
      (e.toEncodedMap = void 0),
      (e.fromMap = void 0),
      (e.allMappings = void 0);
    var p = A(function e() {
      var r =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
        n = r.file,
        i = r.sourceRoot;
      E(this, e),
        (this._names = new t.SetArray()),
        (this._sources = new t.SetArray()),
        (this._sourcesContent = []),
        (this._mappings = []),
        (this.file = n),
        (this.sourceRoot = i);
    });
    function h(e, t) {
      for (var r = e.length; r <= t; r++) e[r] = [];
      return e[t];
    }
    function d(e, t) {
      for (var r = e.length, n = r - 1; n >= 0 && !(t >= e[n][a]); r = n--);
      return r;
    }
    function f(e, t, r) {
      for (var n = e.length; n > t; n--) e[n] = e[n - 1];
      e[t] = r;
    }
    function y(e) {
      for (
        var t = e.length, r = t, n = r - 1;
        n >= 0 && !(e[n].length > 0);
        r = n, n--
      );
      r < t && (e.length = r);
    }
    function m(e, r) {
      for (var n = 0; n < r.length; n++) t.put(e, r[n]);
    }
    function v(e, t) {
      return 0 === t || 1 === e[t - 1].length;
    }
    function g(e, t, r, n, i, a) {
      if (0 === t) return !1;
      var p = e[t - 1];
      return (
        1 !== p.length &&
        r === p[s] &&
        n === p[o] &&
        i === p[l] &&
        a === (5 === p.length ? p[u] : c)
      );
    }
    function b(e, t, r) {
      var n = r.generated,
        a = r.source,
        s = r.original,
        o = r.name,
        l = r.content;
      if (!a)
        return i(e, t, n.line - 1, n.column, null, null, null, null, null);
      var u = a;
      return i(e, t, n.line - 1, n.column, u, s.line - 1, s.column, o, l);
    }
    (e.addSegment = function (e, t, r, n, a, s, o, l) {
      return i(!1, e, t, r, n, a, s, o, l);
    }),
      (e.maybeAddSegment = function (e, t, r, n, a, s, o, l) {
        return i(!0, e, t, r, n, a, s, o, l);
      }),
      (e.addMapping = function (e, t) {
        return b(!1, e, t);
      }),
      (e.maybeAddMapping = function (e, t) {
        return b(!0, e, t);
      }),
      (e.setSourceContent = function (e, r, n) {
        var i = e._sources;
        e._sourcesContent[t.put(i, r)] = n;
      }),
      (e.toDecodedMap = function (e) {
        var t = e.file,
          r = e.sourceRoot,
          n = e._mappings,
          i = e._sources,
          a = e._sourcesContent,
          s = e._names;
        return (
          y(n),
          {
            version: 3,
            file: t || void 0,
            names: s.array,
            sourceRoot: r || void 0,
            sources: i.array,
            sourcesContent: a,
            mappings: n,
          }
        );
      }),
      (e.toEncodedMap = function (t) {
        var n = e.toDecodedMap(t);
        return Object.assign(Object.assign({}, n), {
          mappings: r.encode(n.mappings),
        });
      }),
      (e.allMappings = function (e) {
        for (
          var t = [], r = e._mappings, n = e._sources, i = e._names, c = 0;
          c < r.length;
          c++
        )
          for (var p = r[c], h = 0; h < p.length; h++) {
            var d = p[h],
              f = { line: c + 1, column: d[a] },
              y = void 0,
              m = void 0,
              v = void 0;
            1 !== d.length &&
              ((y = n.array[d[s]]),
              (m = { line: d[o] + 1, column: d[l] }),
              5 === d.length && (v = i.array[d[u]])),
              t.push({ generated: f, source: y, original: m, name: v });
          }
        return t;
      }),
      (e.fromMap = function (e) {
        var t = new n.TraceMap(e),
          r = new p({ file: t.file, sourceRoot: t.sourceRoot });
        return (
          m(r._names, t.names),
          m(r._sources, t.sources),
          (r._sourcesContent =
            t.sourcesContent ||
            t.sources.map(function () {
              return null;
            })),
          (r._mappings = n.decodedMappings(t)),
          r
        );
      }),
      (i = function (e, r, n, i, a, s, o, l, u) {
        var p = r._mappings,
          y = r._sources,
          m = r._sourcesContent,
          b = r._names,
          T = h(p, n),
          S = d(T, i);
        if (!a) {
          if (e && v(T, S)) return;
          return f(T, S, [i]);
        }
        var x = t.put(y, a),
          E = l ? t.put(b, l) : c;
        if (
          (x === m.length && (m[x] = null != u ? u : null),
          !e || !g(T, S, x, s, o, E))
        )
          return f(T, S, l ? [i, x, s, o, E] : [i, x, s, o]);
      }),
      (e.GenMapping = p),
      Object.defineProperty(e, "__esModule", { value: !0 });
  })(oi.exports, ui(), hi(), fi.exports),
  Object.defineProperty(si, "__esModule", { value: !0 }),
  (si.default = void 0);
var Ti = oi.exports,
  Si = fi.exports,
  xi = (function () {
    function e(t, r) {
      var n;
      E(this, e),
        (this._map = void 0),
        (this._rawMappings = void 0),
        (this._sourceFileName = void 0),
        (this._lastGenLine = 0),
        (this._lastSourceLine = 0),
        (this._lastSourceColumn = 0),
        (this._inputMap = void 0);
      var i = (this._map = new Ti.GenMapping({ sourceRoot: t.sourceRoot }));
      if (
        ((this._sourceFileName =
          null == (n = t.sourceFileName) ? void 0 : n.replace(/\\/g, "/")),
        (this._rawMappings = void 0),
        t.inputSourceMap)
      ) {
        this._inputMap = new Si.TraceMap(t.inputSourceMap);
        var a = this._inputMap.resolvedSources;
        if (a.length)
          for (var s = 0; s < a.length; s++) {
            var o;
            (0, Ti.setSourceContent)(
              i,
              a[s],
              null == (o = this._inputMap.sourcesContent) ? void 0 : o[s]
            );
          }
      }
      if ("string" != typeof r || t.inputSourceMap) {
        if ("object" === g(r))
          for (var l = 0, u = Object.keys(r); l < u.length; l++) {
            var c = u[l];
            (0, Ti.setSourceContent)(i, c.replace(/\\/g, "/"), r[c]);
          }
      } else (0, Ti.setSourceContent)(i, this._sourceFileName, r);
    }
    return (
      A(e, [
        {
          key: "get",
          value: function () {
            return (0, Ti.toEncodedMap)(this._map);
          },
        },
        {
          key: "getDecoded",
          value: function () {
            return (0, Ti.toDecodedMap)(this._map);
          },
        },
        {
          key: "getRawMappings",
          value: function () {
            return (
              this._rawMappings ||
              (this._rawMappings = (0, Ti.allMappings)(this._map))
            );
          },
        },
        {
          key: "mark",
          value: function (e, t, r, n, i, a) {
            var s, o;
            if (((this._rawMappings = void 0), null != t))
              if (this._inputMap) {
                if (
                  !(o = (0, Si.originalPositionFor)(this._inputMap, {
                    line: t,
                    column: r,
                  })).name &&
                  i
                ) {
                  var l = (0, Si.originalPositionFor)(this._inputMap, i);
                  l.name && (n = l.name);
                }
              } else
                o = {
                  source:
                    (null == a ? void 0 : a.replace(/\\/g, "/")) ||
                    this._sourceFileName,
                  line: t,
                  column: r,
                };
            (0, Ti.maybeAddMapping)(this._map, {
              name: n,
              generated: e,
              source: null == (s = o) ? void 0 : s.source,
              original: o,
            });
          },
        },
      ]),
      e
    );
  })();
si.default = xi;
var Ei = {},
  Pi = {};
Object.defineProperty(Pi, "__esModule", { value: !0 }), (Pi.default = void 0);
var Ai = (function () {
  function e(t) {
    E(this, e),
      (this._map = null),
      (this._buf = ""),
      (this._str = ""),
      (this._appendCount = 0),
      (this._last = 0),
      (this._queue = []),
      (this._queueCursor = 0),
      (this._canMarkIdName = !0),
      (this._position = { line: 1, column: 0 }),
      (this._sourcePosition = {
        identifierName: void 0,
        identifierNamePos: void 0,
        line: void 0,
        column: void 0,
        filename: void 0,
      }),
      (this._map = t),
      this._allocQueue();
  }
  return (
    A(e, [
      {
        key: "_allocQueue",
        value: function () {
          for (var e = this._queue, t = 0; t < 16; t++)
            e.push({
              char: 0,
              repeat: 1,
              line: void 0,
              column: void 0,
              identifierName: void 0,
              identifierNamePos: void 0,
              filename: "",
            });
        },
      },
      {
        key: "_pushQueue",
        value: function (e, t, r, n, i) {
          var a = this._queueCursor;
          a === this._queue.length && this._allocQueue();
          var s = this._queue[a];
          (s.char = e),
            (s.repeat = t),
            (s.line = r),
            (s.column = n),
            (s.filename = i),
            this._queueCursor++;
        },
      },
      {
        key: "_popQueue",
        value: function () {
          if (0 === this._queueCursor)
            throw new Error("Cannot pop from empty queue");
          return this._queue[--this._queueCursor];
        },
      },
      {
        key: "get",
        value: function () {
          this._flush();
          var e = this._map,
            t = {
              code: (this._buf + this._str).trimRight(),
              decodedMap: null == e ? void 0 : e.getDecoded(),
              get __mergedMap() {
                return this.map;
              },
              get map() {
                var r = e ? e.get() : null;
                return (t.map = r), r;
              },
              set map(e) {
                Object.defineProperty(t, "map", { value: e, writable: !0 });
              },
              get rawMappings() {
                var r = null == e ? void 0 : e.getRawMappings();
                return (t.rawMappings = r), r;
              },
              set rawMappings(e) {
                Object.defineProperty(t, "rawMappings", {
                  value: e,
                  writable: !0,
                });
              },
            };
          return t;
        },
      },
      {
        key: "append",
        value: function (e, t) {
          this._flush(), this._append(e, this._sourcePosition, t);
        },
      },
      {
        key: "appendChar",
        value: function (e) {
          this._flush(), this._appendChar(e, 1, this._sourcePosition);
        },
      },
      {
        key: "queue",
        value: function (e) {
          if (10 === e)
            for (; 0 !== this._queueCursor; ) {
              var t = this._queue[this._queueCursor - 1].char;
              if (32 !== t && 9 !== t) break;
              this._queueCursor--;
            }
          var r = this._sourcePosition;
          this._pushQueue(e, 1, r.line, r.column, r.filename);
        },
      },
      {
        key: "queueIndentation",
        value: function (e, t) {
          this._pushQueue(e, t, void 0, void 0, void 0);
        },
      },
      {
        key: "_flush",
        value: function () {
          for (var e = this._queueCursor, t = this._queue, r = 0; r < e; r++) {
            var n = t[r];
            this._appendChar(n.char, n.repeat, n);
          }
          this._queueCursor = 0;
        },
      },
      {
        key: "_appendChar",
        value: function (e, t, r) {
          (this._last = e),
            (this._str +=
              t > 1
                ? String.fromCharCode(e).repeat(t)
                : String.fromCharCode(e)),
            10 !== e
              ? (this._mark(
                  r.line,
                  r.column,
                  r.identifierName,
                  r.identifierNamePos,
                  r.filename
                ),
                (this._position.column += t))
              : (this._position.line++, (this._position.column = 0)),
            this._canMarkIdName &&
              ((r.identifierName = void 0), (r.identifierNamePos = void 0));
        },
      },
      {
        key: "_append",
        value: function (e, t, r) {
          var n = e.length,
            i = this._position;
          if (
            ((this._last = e.charCodeAt(n - 1)),
            ++this._appendCount > 4096
              ? (this._str,
                (this._buf += this._str),
                (this._str = e),
                (this._appendCount = 0))
              : (this._str += e),
            r || this._map)
          ) {
            var a = t.column,
              s = t.identifierName,
              o = t.identifierNamePos,
              l = t.filename,
              u = t.line;
            (null == s && null == o) ||
              !this._canMarkIdName ||
              ((t.identifierName = void 0), (t.identifierNamePos = void 0));
            var c = e.indexOf("\n"),
              p = 0;
            for (0 !== c && this._mark(u, a, s, o, l); -1 !== c; )
              i.line++,
                (i.column = 0),
                (p = c + 1) < n &&
                  void 0 !== u &&
                  this._mark(++u, 0, null, null, l),
                (c = e.indexOf("\n", p));
            i.column += n - p;
          } else i.column += n;
        },
      },
      {
        key: "_mark",
        value: function (e, t, r, n, i) {
          var a;
          null == (a = this._map) || a.mark(this._position, e, t, r, n, i);
        },
      },
      {
        key: "removeTrailingNewline",
        value: function () {
          var e = this._queueCursor;
          0 !== e && 10 === this._queue[e - 1].char && this._queueCursor--;
        },
      },
      {
        key: "removeLastSemicolon",
        value: function () {
          var e = this._queueCursor;
          0 !== e && 59 === this._queue[e - 1].char && this._queueCursor--;
        },
      },
      {
        key: "getLastChar",
        value: function () {
          var e = this._queueCursor;
          return 0 !== e ? this._queue[e - 1].char : this._last;
        },
      },
      {
        key: "getNewlineCount",
        value: function () {
          var e = this._queueCursor,
            t = 0;
          if (0 === e) return 10 === this._last ? 1 : 0;
          for (var r = e - 1; r >= 0 && 10 === this._queue[r].char; r--) t++;
          return t === e && 10 === this._last ? t + 1 : t;
        },
      },
      {
        key: "endsWithCharAndNewline",
        value: function () {
          var e = this._queue,
            t = this._queueCursor;
          if (0 !== t) {
            if (10 !== e[t - 1].char) return;
            return t > 1 ? e[t - 2].char : this._last;
          }
        },
      },
      {
        key: "hasContent",
        value: function () {
          return 0 !== this._queueCursor || !!this._last;
        },
      },
      {
        key: "exactSource",
        value: function (e, t) {
          if (this._map) {
            this.source("start", e);
            var r = e.identifierName,
              n = this._sourcePosition;
            r && ((this._canMarkIdName = !1), (n.identifierName = r)),
              t(),
              r &&
                ((this._canMarkIdName = !0),
                (n.identifierName = void 0),
                (n.identifierNamePos = void 0)),
              this.source("end", e);
          } else t();
        },
      },
      {
        key: "source",
        value: function (e, t) {
          this._map && this._normalizePosition(e, t, 0, 0);
        },
      },
      {
        key: "sourceWithOffset",
        value: function (e, t, r, n) {
          this._map && this._normalizePosition(e, t, r, n);
        },
      },
      {
        key: "withSource",
        value: function (e, t, r) {
          this._map && this.source(e, t), r();
        },
      },
      {
        key: "_normalizePosition",
        value: function (e, t, r, n) {
          var i = t[e],
            a = this._sourcePosition;
          i &&
            ((a.line = i.line + r),
            (a.column = i.column + n),
            (a.filename = t.filename));
        },
      },
      {
        key: "getCurrentColumn",
        value: function () {
          for (
            var e = this._queue, t = this._queueCursor, r = -1, n = 0, i = 0;
            i < t;
            i++
          ) {
            var a = e[i];
            10 === a.char && (r = n), (n += a.repeat);
          }
          return -1 === r ? this._position.column + n : n - 1 - r;
        },
      },
      {
        key: "getCurrentLine",
        value: function () {
          for (var e = 0, t = this._queue, r = 0; r < this._queueCursor; r++)
            10 === t[r].char && e++;
          return this._position.line + e;
        },
      },
    ]),
    e
  );
})();
Pi.default = Ai;
var ki = {},
  wi = {},
  Ci = {},
  Ii = {},
  Oi = {},
  Ni = {},
  _i = {},
  Di = {};
Object.defineProperty(Di, "__esModule", { value: !0 }),
  (Di.default = function (e, t) {
    for (var r = Object.keys(t), n = 0, i = r; n < i.length; n++) {
      var a = i[n];
      if (e[a] !== t[a]) return !1;
    }
    return !0;
  });
var Li = {};
Object.defineProperty(Li, "__esModule", { value: !0 }),
  (Li.default = function (e, t) {
    var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "";
    if (Mi.has(e)) return;
    Mi.add(e);
    var n = (function (e, t) {
        var r,
          n = Error.stackTraceLimit,
          i = Error.prepareStackTrace;
        if (
          ((Error.stackTraceLimit = 1 + e + t),
          (Error.prepareStackTrace = function (e, t) {
            r = t;
          }),
          new Error().stack,
          (Error.stackTraceLimit = n),
          (Error.prepareStackTrace = i),
          !r)
        )
          return { internal: !1, trace: "" };
        var a = r.slice(1 + e, 1 + e + t);
        return {
          internal: /[\\/]@babel[\\/]/.test(a[1].getFileName()),
          trace: a
            .map(function (e) {
              return "    at ".concat(e);
            })
            .join("\n"),
        };
      })(1, 2),
      i = n.internal,
      a = n.trace;
    if (i) return;
    console.warn(
      ""
        .concat(r, "`")
        .concat(e, "` has been deprecated, please migrate to `")
        .concat(t, "`\n")
        .concat(a)
    );
  });
var Mi = new Set();
Object.defineProperty(_i, "__esModule", { value: !0 }),
  (_i.isAccessor = function (e, t) {
    if (!e) return !1;
    if ("ClassAccessorProperty" !== e.type) return !1;
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isAnyTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "AnyTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isArgumentPlaceholder = function (e, t) {
    return (
      !!e &&
      "ArgumentPlaceholder" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isArrayExpression = function (e, t) {
    return (
      !!e &&
      "ArrayExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isArrayPattern = function (e, t) {
    return (
      !!e && "ArrayPattern" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isArrayTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "ArrayTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isArrowFunctionExpression = function (e, t) {
    return (
      !!e &&
      "ArrowFunctionExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isAssignmentExpression = function (e, t) {
    return (
      !!e &&
      "AssignmentExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isAssignmentPattern = function (e, t) {
    return (
      !!e &&
      "AssignmentPattern" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isAwaitExpression = function (e, t) {
    return (
      !!e &&
      "AwaitExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isBigIntLiteral = function (e, t) {
    return (
      !!e && "BigIntLiteral" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isBinary = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BinaryExpression":
      case "LogicalExpression":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isBinaryExpression = function (e, t) {
    return (
      !!e &&
      "BinaryExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isBindExpression = function (e, t) {
    return (
      !!e && "BindExpression" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isBlock = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "Program":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if ("BlockStatement" !== e.expectedNode) return !1;
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isBlockParent = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if ("BlockStatement" !== e.expectedNode) return !1;
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isBlockStatement = function (e, t) {
    return (
      !!e && "BlockStatement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isBooleanLiteral = function (e, t) {
    return (
      !!e && "BooleanLiteral" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isBooleanLiteralTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "BooleanLiteralTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isBooleanTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "BooleanTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isBreakStatement = function (e, t) {
    return (
      !!e && "BreakStatement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isCallExpression = function (e, t) {
    return (
      !!e && "CallExpression" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isCatchClause = function (e, t) {
    return (
      !!e && "CatchClause" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isClass = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassExpression":
      case "ClassDeclaration":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isClassAccessorProperty = function (e, t) {
    return (
      !!e &&
      "ClassAccessorProperty" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isClassBody = function (e, t) {
    return (
      !!e && "ClassBody" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isClassDeclaration = function (e, t) {
    return (
      !!e &&
      "ClassDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isClassExpression = function (e, t) {
    return (
      !!e &&
      "ClassExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isClassImplements = function (e, t) {
    return (
      !!e &&
      "ClassImplements" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isClassMethod = function (e, t) {
    return (
      !!e && "ClassMethod" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isClassPrivateMethod = function (e, t) {
    return (
      !!e &&
      "ClassPrivateMethod" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isClassPrivateProperty = function (e, t) {
    return (
      !!e &&
      "ClassPrivateProperty" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isClassProperty = function (e, t) {
    return (
      !!e && "ClassProperty" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isCompletionStatement = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isConditional = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ConditionalExpression":
      case "IfStatement":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isConditionalExpression = function (e, t) {
    return (
      !!e &&
      "ConditionalExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isContinueStatement = function (e, t) {
    return (
      !!e &&
      "ContinueStatement" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDebuggerStatement = function (e, t) {
    return (
      !!e &&
      "DebuggerStatement" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDecimalLiteral = function (e, t) {
    return (
      !!e && "DecimalLiteral" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDeclaration = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "VariableDeclaration":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
        break;
      case "Placeholder":
        if ("Declaration" !== e.expectedNode) return !1;
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isDeclareClass = function (e, t) {
    return (
      !!e && "DeclareClass" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDeclareExportAllDeclaration = function (e, t) {
    return (
      !!e &&
      "DeclareExportAllDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDeclareExportDeclaration = function (e, t) {
    return (
      !!e &&
      "DeclareExportDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDeclareFunction = function (e, t) {
    return (
      !!e &&
      "DeclareFunction" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDeclareInterface = function (e, t) {
    return (
      !!e &&
      "DeclareInterface" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDeclareModule = function (e, t) {
    return (
      !!e && "DeclareModule" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDeclareModuleExports = function (e, t) {
    return (
      !!e &&
      "DeclareModuleExports" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDeclareOpaqueType = function (e, t) {
    return (
      !!e &&
      "DeclareOpaqueType" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDeclareTypeAlias = function (e, t) {
    return (
      !!e &&
      "DeclareTypeAlias" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDeclareVariable = function (e, t) {
    return (
      !!e &&
      "DeclareVariable" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDeclaredPredicate = function (e, t) {
    return (
      !!e &&
      "DeclaredPredicate" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDecorator = function (e, t) {
    return (
      !!e && "Decorator" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDirective = function (e, t) {
    return (
      !!e && "Directive" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDirectiveLiteral = function (e, t) {
    return (
      !!e &&
      "DirectiveLiteral" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDoExpression = function (e, t) {
    return (
      !!e && "DoExpression" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isDoWhileStatement = function (e, t) {
    return (
      !!e &&
      "DoWhileStatement" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isEmptyStatement = function (e, t) {
    return (
      !!e && "EmptyStatement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isEmptyTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "EmptyTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isEnumBody = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isEnumBooleanBody = function (e, t) {
    return (
      !!e &&
      "EnumBooleanBody" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isEnumBooleanMember = function (e, t) {
    return (
      !!e &&
      "EnumBooleanMember" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isEnumDeclaration = function (e, t) {
    return (
      !!e &&
      "EnumDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isEnumDefaultedMember = function (e, t) {
    return (
      !!e &&
      "EnumDefaultedMember" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isEnumMember = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isEnumNumberBody = function (e, t) {
    return (
      !!e && "EnumNumberBody" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isEnumNumberMember = function (e, t) {
    return (
      !!e &&
      "EnumNumberMember" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isEnumStringBody = function (e, t) {
    return (
      !!e && "EnumStringBody" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isEnumStringMember = function (e, t) {
    return (
      !!e &&
      "EnumStringMember" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isEnumSymbolBody = function (e, t) {
    return (
      !!e && "EnumSymbolBody" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isExistsTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "ExistsTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isExportAllDeclaration = function (e, t) {
    return (
      !!e &&
      "ExportAllDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isExportDeclaration = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isExportDefaultDeclaration = function (e, t) {
    return (
      !!e &&
      "ExportDefaultDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isExportDefaultSpecifier = function (e, t) {
    return (
      !!e &&
      "ExportDefaultSpecifier" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isExportNamedDeclaration = function (e, t) {
    return (
      !!e &&
      "ExportNamedDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isExportNamespaceSpecifier = function (e, t) {
    return (
      !!e &&
      "ExportNamespaceSpecifier" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isExportSpecifier = function (e, t) {
    return (
      !!e &&
      "ExportSpecifier" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isExpression = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "CallExpression":
      case "ConditionalExpression":
      case "FunctionExpression":
      case "Identifier":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "ObjectExpression":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "ThisExpression":
      case "UnaryExpression":
      case "UpdateExpression":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "MetaProperty":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "TypeCastExpression":
      case "JSXElement":
      case "JSXFragment":
      case "BindExpression":
      case "DoExpression":
      case "RecordExpression":
      case "TupleExpression":
      case "DecimalLiteral":
      case "ModuleExpression":
      case "TopicReference":
      case "PipelineTopicExpression":
      case "PipelineBareFunction":
      case "PipelinePrimaryTopicReference":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Expression":
          case "Identifier":
          case "StringLiteral":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isExpressionStatement = function (e, t) {
    return (
      !!e &&
      "ExpressionStatement" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isExpressionWrapper = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExpressionStatement":
      case "ParenthesizedExpression":
      case "TypeCastExpression":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isFile = function (e, t) {
    return !!e && "File" === e.type && (null == t || (0, ji.default)(e, t));
  }),
  (_i.isFlow = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ClassImplements":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "DeclaredPredicate":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "FunctionTypeParam":
      case "GenericTypeAnnotation":
      case "InferredPredicate":
      case "InterfaceExtends":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
      case "OpaqueType":
      case "QualifiedTypeIdentifier":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "TypeAlias":
      case "TypeAnnotation":
      case "TypeCastExpression":
      case "TypeParameter":
      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
      case "UnionTypeAnnotation":
      case "Variance":
      case "VoidTypeAnnotation":
      case "EnumDeclaration":
      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
      case "EnumDefaultedMember":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isFlowBaseAnnotation = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NumberTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "VoidTypeAnnotation":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isFlowDeclaration = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isFlowPredicate = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DeclaredPredicate":
      case "InferredPredicate":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isFlowType = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AnyTypeAnnotation":
      case "ArrayTypeAnnotation":
      case "BooleanTypeAnnotation":
      case "BooleanLiteralTypeAnnotation":
      case "NullLiteralTypeAnnotation":
      case "ExistsTypeAnnotation":
      case "FunctionTypeAnnotation":
      case "GenericTypeAnnotation":
      case "InterfaceTypeAnnotation":
      case "IntersectionTypeAnnotation":
      case "MixedTypeAnnotation":
      case "EmptyTypeAnnotation":
      case "NullableTypeAnnotation":
      case "NumberLiteralTypeAnnotation":
      case "NumberTypeAnnotation":
      case "ObjectTypeAnnotation":
      case "StringLiteralTypeAnnotation":
      case "StringTypeAnnotation":
      case "SymbolTypeAnnotation":
      case "ThisTypeAnnotation":
      case "TupleTypeAnnotation":
      case "TypeofTypeAnnotation":
      case "UnionTypeAnnotation":
      case "VoidTypeAnnotation":
      case "IndexedAccessType":
      case "OptionalIndexedAccessType":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isFor = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isForInStatement = function (e, t) {
    return (
      !!e && "ForInStatement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isForOfStatement = function (e, t) {
    return (
      !!e && "ForOfStatement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isForStatement = function (e, t) {
    return (
      !!e && "ForStatement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isForXStatement = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ForInStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isFunction = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isFunctionDeclaration = function (e, t) {
    return (
      !!e &&
      "FunctionDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isFunctionExpression = function (e, t) {
    return (
      !!e &&
      "FunctionExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isFunctionParent = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ObjectMethod":
      case "ArrowFunctionExpression":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isFunctionTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "FunctionTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isFunctionTypeParam = function (e, t) {
    return (
      !!e &&
      "FunctionTypeParam" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isGenericTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "GenericTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isIdentifier = function (e, t) {
    return (
      !!e && "Identifier" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isIfStatement = function (e, t) {
    return (
      !!e && "IfStatement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isImmutable = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "BigIntLiteral":
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXOpeningElement":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if ("StringLiteral" !== e.expectedNode) return !1;
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isImport = function (e, t) {
    return !!e && "Import" === e.type && (null == t || (0, ji.default)(e, t));
  }),
  (_i.isImportAttribute = function (e, t) {
    return (
      !!e &&
      "ImportAttribute" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isImportDeclaration = function (e, t) {
    return (
      !!e &&
      "ImportDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isImportDefaultSpecifier = function (e, t) {
    return (
      !!e &&
      "ImportDefaultSpecifier" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isImportNamespaceSpecifier = function (e, t) {
    return (
      !!e &&
      "ImportNamespaceSpecifier" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isImportOrExportDeclaration = Bi),
  (_i.isImportSpecifier = function (e, t) {
    return (
      !!e &&
      "ImportSpecifier" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isIndexedAccessType = function (e, t) {
    return (
      !!e &&
      "IndexedAccessType" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isInferredPredicate = function (e, t) {
    return (
      !!e &&
      "InferredPredicate" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isInterfaceDeclaration = function (e, t) {
    return (
      !!e &&
      "InterfaceDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isInterfaceExtends = function (e, t) {
    return (
      !!e &&
      "InterfaceExtends" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isInterfaceTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "InterfaceTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isInterpreterDirective = function (e, t) {
    return (
      !!e &&
      "InterpreterDirective" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isIntersectionTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "IntersectionTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSX = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "JSXAttribute":
      case "JSXClosingElement":
      case "JSXElement":
      case "JSXEmptyExpression":
      case "JSXExpressionContainer":
      case "JSXSpreadChild":
      case "JSXIdentifier":
      case "JSXMemberExpression":
      case "JSXNamespacedName":
      case "JSXOpeningElement":
      case "JSXSpreadAttribute":
      case "JSXText":
      case "JSXFragment":
      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isJSXAttribute = function (e, t) {
    return (
      !!e && "JSXAttribute" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXClosingElement = function (e, t) {
    return (
      !!e &&
      "JSXClosingElement" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXClosingFragment = function (e, t) {
    return (
      !!e &&
      "JSXClosingFragment" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXElement = function (e, t) {
    return (
      !!e && "JSXElement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXEmptyExpression = function (e, t) {
    return (
      !!e &&
      "JSXEmptyExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXExpressionContainer = function (e, t) {
    return (
      !!e &&
      "JSXExpressionContainer" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXFragment = function (e, t) {
    return (
      !!e && "JSXFragment" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXIdentifier = function (e, t) {
    return (
      !!e && "JSXIdentifier" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXMemberExpression = function (e, t) {
    return (
      !!e &&
      "JSXMemberExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXNamespacedName = function (e, t) {
    return (
      !!e &&
      "JSXNamespacedName" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXOpeningElement = function (e, t) {
    return (
      !!e &&
      "JSXOpeningElement" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXOpeningFragment = function (e, t) {
    return (
      !!e &&
      "JSXOpeningFragment" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXSpreadAttribute = function (e, t) {
    return (
      !!e &&
      "JSXSpreadAttribute" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXSpreadChild = function (e, t) {
    return (
      !!e && "JSXSpreadChild" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isJSXText = function (e, t) {
    return !!e && "JSXText" === e.type && (null == t || (0, ji.default)(e, t));
  }),
  (_i.isLVal = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "MemberExpression":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSParameterProperty":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isLabeledStatement = function (e, t) {
    return (
      !!e &&
      "LabeledStatement" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isLiteral = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "TemplateLiteral":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if ("StringLiteral" !== e.expectedNode) return !1;
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isLogicalExpression = function (e, t) {
    return (
      !!e &&
      "LogicalExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isLoop = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "WhileStatement":
      case "ForOfStatement":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isMemberExpression = function (e, t) {
    return (
      !!e &&
      "MemberExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isMetaProperty = function (e, t) {
    return (
      !!e && "MetaProperty" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isMethod = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ClassMethod":
      case "ClassPrivateMethod":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isMiscellaneous = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Noop":
      case "Placeholder":
      case "V8IntrinsicIdentifier":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isMixedTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "MixedTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isModuleDeclaration = function (e, t) {
    return (
      (0, Fi.default)("isModuleDeclaration", "isImportOrExportDeclaration"),
      Bi(e, t)
    );
  }),
  (_i.isModuleExpression = function (e, t) {
    return (
      !!e &&
      "ModuleExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isModuleSpecifier = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ExportSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isNewExpression = function (e, t) {
    return (
      !!e && "NewExpression" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isNoop = function (e, t) {
    return !!e && "Noop" === e.type && (null == t || (0, ji.default)(e, t));
  }),
  (_i.isNullLiteral = function (e, t) {
    return (
      !!e && "NullLiteral" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isNullLiteralTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "NullLiteralTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isNullableTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "NullableTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isNumberLiteral = function (e, t) {
    return (
      (0, Fi.default)("isNumberLiteral", "isNumericLiteral"),
      !!e && "NumberLiteral" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isNumberLiteralTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "NumberLiteralTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isNumberTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "NumberTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isNumericLiteral = function (e, t) {
    return (
      !!e && "NumericLiteral" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isObjectExpression = function (e, t) {
    return (
      !!e &&
      "ObjectExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isObjectMember = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isObjectMethod = function (e, t) {
    return (
      !!e && "ObjectMethod" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isObjectPattern = function (e, t) {
    return (
      !!e && "ObjectPattern" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isObjectProperty = function (e, t) {
    return (
      !!e && "ObjectProperty" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isObjectTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "ObjectTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isObjectTypeCallProperty = function (e, t) {
    return (
      !!e &&
      "ObjectTypeCallProperty" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isObjectTypeIndexer = function (e, t) {
    return (
      !!e &&
      "ObjectTypeIndexer" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isObjectTypeInternalSlot = function (e, t) {
    return (
      !!e &&
      "ObjectTypeInternalSlot" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isObjectTypeProperty = function (e, t) {
    return (
      !!e &&
      "ObjectTypeProperty" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isObjectTypeSpreadProperty = function (e, t) {
    return (
      !!e &&
      "ObjectTypeSpreadProperty" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isOpaqueType = function (e, t) {
    return (
      !!e && "OpaqueType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isOptionalCallExpression = function (e, t) {
    return (
      !!e &&
      "OptionalCallExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isOptionalIndexedAccessType = function (e, t) {
    return (
      !!e &&
      "OptionalIndexedAccessType" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isOptionalMemberExpression = function (e, t) {
    return (
      !!e &&
      "OptionalMemberExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isParenthesizedExpression = function (e, t) {
    return (
      !!e &&
      "ParenthesizedExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isPattern = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
        break;
      case "Placeholder":
        if ("Pattern" !== e.expectedNode) return !1;
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isPatternLike = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "RestElement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ObjectPattern":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSNonNullExpression":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Pattern":
          case "Identifier":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isPipelineBareFunction = function (e, t) {
    return (
      !!e &&
      "PipelineBareFunction" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isPipelinePrimaryTopicReference = function (e, t) {
    return (
      !!e &&
      "PipelinePrimaryTopicReference" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isPipelineTopicExpression = function (e, t) {
    return (
      !!e &&
      "PipelineTopicExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isPlaceholder = function (e, t) {
    return (
      !!e && "Placeholder" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isPrivate = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isPrivateName = function (e, t) {
    return (
      !!e && "PrivateName" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isProgram = function (e, t) {
    return !!e && "Program" === e.type && (null == t || (0, ji.default)(e, t));
  }),
  (_i.isProperty = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectProperty":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isPureish = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "ArrowFunctionExpression":
      case "BigIntLiteral":
      case "DecimalLiteral":
        break;
      case "Placeholder":
        if ("StringLiteral" !== e.expectedNode) return !1;
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isQualifiedTypeIdentifier = function (e, t) {
    return (
      !!e &&
      "QualifiedTypeIdentifier" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isRecordExpression = function (e, t) {
    return (
      !!e &&
      "RecordExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isRegExpLiteral = function (e, t) {
    return (
      !!e && "RegExpLiteral" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isRegexLiteral = function (e, t) {
    return (
      (0, Fi.default)("isRegexLiteral", "isRegExpLiteral"),
      !!e && "RegexLiteral" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isRestElement = function (e, t) {
    return (
      !!e && "RestElement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isRestProperty = function (e, t) {
    return (
      (0, Fi.default)("isRestProperty", "isRestElement"),
      !!e && "RestProperty" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isReturnStatement = function (e, t) {
    return (
      !!e &&
      "ReturnStatement" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isScopable = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "CatchClause":
      case "DoWhileStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Program":
      case "ObjectMethod":
      case "SwitchStatement":
      case "WhileStatement":
      case "ArrowFunctionExpression":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ForOfStatement":
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "StaticBlock":
      case "TSModuleBlock":
        break;
      case "Placeholder":
        if ("BlockStatement" !== e.expectedNode) return !1;
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isSequenceExpression = function (e, t) {
    return (
      !!e &&
      "SequenceExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isSpreadElement = function (e, t) {
    return (
      !!e && "SpreadElement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isSpreadProperty = function (e, t) {
    return (
      (0, Fi.default)("isSpreadProperty", "isSpreadElement"),
      !!e && "SpreadProperty" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isStandardized = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ArrayExpression":
      case "AssignmentExpression":
      case "BinaryExpression":
      case "InterpreterDirective":
      case "Directive":
      case "DirectiveLiteral":
      case "BlockStatement":
      case "BreakStatement":
      case "CallExpression":
      case "CatchClause":
      case "ConditionalExpression":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "File":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "Identifier":
      case "IfStatement":
      case "LabeledStatement":
      case "StringLiteral":
      case "NumericLiteral":
      case "NullLiteral":
      case "BooleanLiteral":
      case "RegExpLiteral":
      case "LogicalExpression":
      case "MemberExpression":
      case "NewExpression":
      case "Program":
      case "ObjectExpression":
      case "ObjectMethod":
      case "ObjectProperty":
      case "RestElement":
      case "ReturnStatement":
      case "SequenceExpression":
      case "ParenthesizedExpression":
      case "SwitchCase":
      case "SwitchStatement":
      case "ThisExpression":
      case "ThrowStatement":
      case "TryStatement":
      case "UnaryExpression":
      case "UpdateExpression":
      case "VariableDeclaration":
      case "VariableDeclarator":
      case "WhileStatement":
      case "WithStatement":
      case "AssignmentPattern":
      case "ArrayPattern":
      case "ArrowFunctionExpression":
      case "ClassBody":
      case "ClassExpression":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ExportSpecifier":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "MetaProperty":
      case "ClassMethod":
      case "ObjectPattern":
      case "SpreadElement":
      case "Super":
      case "TaggedTemplateExpression":
      case "TemplateElement":
      case "TemplateLiteral":
      case "YieldExpression":
      case "AwaitExpression":
      case "Import":
      case "BigIntLiteral":
      case "ExportNamespaceSpecifier":
      case "OptionalMemberExpression":
      case "OptionalCallExpression":
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
      case "PrivateName":
      case "StaticBlock":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Identifier":
          case "StringLiteral":
          case "BlockStatement":
          case "ClassBody":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isStatement = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BlockStatement":
      case "BreakStatement":
      case "ContinueStatement":
      case "DebuggerStatement":
      case "DoWhileStatement":
      case "EmptyStatement":
      case "ExpressionStatement":
      case "ForInStatement":
      case "ForStatement":
      case "FunctionDeclaration":
      case "IfStatement":
      case "LabeledStatement":
      case "ReturnStatement":
      case "SwitchStatement":
      case "ThrowStatement":
      case "TryStatement":
      case "VariableDeclaration":
      case "WhileStatement":
      case "WithStatement":
      case "ClassDeclaration":
      case "ExportAllDeclaration":
      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
      case "ForOfStatement":
      case "ImportDeclaration":
      case "DeclareClass":
      case "DeclareFunction":
      case "DeclareInterface":
      case "DeclareModule":
      case "DeclareModuleExports":
      case "DeclareTypeAlias":
      case "DeclareOpaqueType":
      case "DeclareVariable":
      case "DeclareExportDeclaration":
      case "DeclareExportAllDeclaration":
      case "InterfaceDeclaration":
      case "OpaqueType":
      case "TypeAlias":
      case "EnumDeclaration":
      case "TSDeclareFunction":
      case "TSInterfaceDeclaration":
      case "TSTypeAliasDeclaration":
      case "TSEnumDeclaration":
      case "TSModuleDeclaration":
      case "TSImportEqualsDeclaration":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
        break;
      case "Placeholder":
        switch (e.expectedNode) {
          case "Statement":
          case "Declaration":
          case "BlockStatement":
            break;
          default:
            return !1;
        }
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isStaticBlock = function (e, t) {
    return (
      !!e && "StaticBlock" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isStringLiteral = function (e, t) {
    return (
      !!e && "StringLiteral" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isStringLiteralTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "StringLiteralTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isStringTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "StringTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isSuper = function (e, t) {
    return !!e && "Super" === e.type && (null == t || (0, ji.default)(e, t));
  }),
  (_i.isSwitchCase = function (e, t) {
    return (
      !!e && "SwitchCase" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isSwitchStatement = function (e, t) {
    return (
      !!e &&
      "SwitchStatement" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isSymbolTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "SymbolTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSAnyKeyword = function (e, t) {
    return (
      !!e && "TSAnyKeyword" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSArrayType = function (e, t) {
    return (
      !!e && "TSArrayType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSAsExpression = function (e, t) {
    return (
      !!e && "TSAsExpression" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSBaseType = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSLiteralType":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isTSBigIntKeyword = function (e, t) {
    return (
      !!e &&
      "TSBigIntKeyword" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSBooleanKeyword = function (e, t) {
    return (
      !!e &&
      "TSBooleanKeyword" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSCallSignatureDeclaration = function (e, t) {
    return (
      !!e &&
      "TSCallSignatureDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSConditionalType = function (e, t) {
    return (
      !!e &&
      "TSConditionalType" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSConstructSignatureDeclaration = function (e, t) {
    return (
      !!e &&
      "TSConstructSignatureDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSConstructorType = function (e, t) {
    return (
      !!e &&
      "TSConstructorType" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSDeclareFunction = function (e, t) {
    return (
      !!e &&
      "TSDeclareFunction" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSDeclareMethod = function (e, t) {
    return (
      !!e &&
      "TSDeclareMethod" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSEntityName = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "Identifier":
      case "TSQualifiedName":
        break;
      case "Placeholder":
        if ("Identifier" !== e.expectedNode) return !1;
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isTSEnumDeclaration = function (e, t) {
    return (
      !!e &&
      "TSEnumDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSEnumMember = function (e, t) {
    return (
      !!e && "TSEnumMember" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSExportAssignment = function (e, t) {
    return (
      !!e &&
      "TSExportAssignment" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSExpressionWithTypeArguments = function (e, t) {
    return (
      !!e &&
      "TSExpressionWithTypeArguments" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSExternalModuleReference = function (e, t) {
    return (
      !!e &&
      "TSExternalModuleReference" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSFunctionType = function (e, t) {
    return (
      !!e && "TSFunctionType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSImportEqualsDeclaration = function (e, t) {
    return (
      !!e &&
      "TSImportEqualsDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSImportType = function (e, t) {
    return (
      !!e && "TSImportType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSIndexSignature = function (e, t) {
    return (
      !!e &&
      "TSIndexSignature" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSIndexedAccessType = function (e, t) {
    return (
      !!e &&
      "TSIndexedAccessType" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSInferType = function (e, t) {
    return (
      !!e && "TSInferType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSInstantiationExpression = function (e, t) {
    return (
      !!e &&
      "TSInstantiationExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSInterfaceBody = function (e, t) {
    return (
      !!e &&
      "TSInterfaceBody" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSInterfaceDeclaration = function (e, t) {
    return (
      !!e &&
      "TSInterfaceDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSIntersectionType = function (e, t) {
    return (
      !!e &&
      "TSIntersectionType" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSIntrinsicKeyword = function (e, t) {
    return (
      !!e &&
      "TSIntrinsicKeyword" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSLiteralType = function (e, t) {
    return (
      !!e && "TSLiteralType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSMappedType = function (e, t) {
    return (
      !!e && "TSMappedType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSMethodSignature = function (e, t) {
    return (
      !!e &&
      "TSMethodSignature" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSModuleBlock = function (e, t) {
    return (
      !!e && "TSModuleBlock" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSModuleDeclaration = function (e, t) {
    return (
      !!e &&
      "TSModuleDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSNamedTupleMember = function (e, t) {
    return (
      !!e &&
      "TSNamedTupleMember" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSNamespaceExportDeclaration = function (e, t) {
    return (
      !!e &&
      "TSNamespaceExportDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSNeverKeyword = function (e, t) {
    return (
      !!e && "TSNeverKeyword" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSNonNullExpression = function (e, t) {
    return (
      !!e &&
      "TSNonNullExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSNullKeyword = function (e, t) {
    return (
      !!e && "TSNullKeyword" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSNumberKeyword = function (e, t) {
    return (
      !!e &&
      "TSNumberKeyword" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSObjectKeyword = function (e, t) {
    return (
      !!e &&
      "TSObjectKeyword" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSOptionalType = function (e, t) {
    return (
      !!e && "TSOptionalType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSParameterProperty = function (e, t) {
    return (
      !!e &&
      "TSParameterProperty" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSParenthesizedType = function (e, t) {
    return (
      !!e &&
      "TSParenthesizedType" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSPropertySignature = function (e, t) {
    return (
      !!e &&
      "TSPropertySignature" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSQualifiedName = function (e, t) {
    return (
      !!e &&
      "TSQualifiedName" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSRestType = function (e, t) {
    return (
      !!e && "TSRestType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSSatisfiesExpression = function (e, t) {
    return (
      !!e &&
      "TSSatisfiesExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSStringKeyword = function (e, t) {
    return (
      !!e &&
      "TSStringKeyword" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSSymbolKeyword = function (e, t) {
    return (
      !!e &&
      "TSSymbolKeyword" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSThisType = function (e, t) {
    return (
      !!e && "TSThisType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSTupleType = function (e, t) {
    return (
      !!e && "TSTupleType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSType = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSImportType":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isTSTypeAliasDeclaration = function (e, t) {
    return (
      !!e &&
      "TSTypeAliasDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "TSTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSTypeAssertion = function (e, t) {
    return (
      !!e &&
      "TSTypeAssertion" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSTypeElement = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isTSTypeLiteral = function (e, t) {
    return (
      !!e && "TSTypeLiteral" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSTypeOperator = function (e, t) {
    return (
      !!e && "TSTypeOperator" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSTypeParameter = function (e, t) {
    return (
      !!e &&
      "TSTypeParameter" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSTypeParameterDeclaration = function (e, t) {
    return (
      !!e &&
      "TSTypeParameterDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSTypeParameterInstantiation = function (e, t) {
    return (
      !!e &&
      "TSTypeParameterInstantiation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSTypePredicate = function (e, t) {
    return (
      !!e &&
      "TSTypePredicate" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSTypeQuery = function (e, t) {
    return (
      !!e && "TSTypeQuery" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSTypeReference = function (e, t) {
    return (
      !!e &&
      "TSTypeReference" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSUndefinedKeyword = function (e, t) {
    return (
      !!e &&
      "TSUndefinedKeyword" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSUnionType = function (e, t) {
    return (
      !!e && "TSUnionType" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSUnknownKeyword = function (e, t) {
    return (
      !!e &&
      "TSUnknownKeyword" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTSVoidKeyword = function (e, t) {
    return (
      !!e && "TSVoidKeyword" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTaggedTemplateExpression = function (e, t) {
    return (
      !!e &&
      "TaggedTemplateExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTemplateElement = function (e, t) {
    return (
      !!e &&
      "TemplateElement" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTemplateLiteral = function (e, t) {
    return (
      !!e &&
      "TemplateLiteral" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTerminatorless = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "BreakStatement":
      case "ContinueStatement":
      case "ReturnStatement":
      case "ThrowStatement":
      case "YieldExpression":
      case "AwaitExpression":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isThisExpression = function (e, t) {
    return (
      !!e && "ThisExpression" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isThisTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "ThisTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isThrowStatement = function (e, t) {
    return (
      !!e && "ThrowStatement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTopicReference = function (e, t) {
    return (
      !!e && "TopicReference" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTryStatement = function (e, t) {
    return (
      !!e && "TryStatement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTupleExpression = function (e, t) {
    return (
      !!e &&
      "TupleExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTupleTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "TupleTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTypeAlias = function (e, t) {
    return (
      !!e && "TypeAlias" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTypeAnnotation = function (e, t) {
    return (
      !!e && "TypeAnnotation" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTypeCastExpression = function (e, t) {
    return (
      !!e &&
      "TypeCastExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTypeParameter = function (e, t) {
    return (
      !!e && "TypeParameter" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTypeParameterDeclaration = function (e, t) {
    return (
      !!e &&
      "TypeParameterDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTypeParameterInstantiation = function (e, t) {
    return (
      !!e &&
      "TypeParameterInstantiation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isTypeScript = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "TSParameterProperty":
      case "TSDeclareFunction":
      case "TSDeclareMethod":
      case "TSQualifiedName":
      case "TSCallSignatureDeclaration":
      case "TSConstructSignatureDeclaration":
      case "TSPropertySignature":
      case "TSMethodSignature":
      case "TSIndexSignature":
      case "TSAnyKeyword":
      case "TSBooleanKeyword":
      case "TSBigIntKeyword":
      case "TSIntrinsicKeyword":
      case "TSNeverKeyword":
      case "TSNullKeyword":
      case "TSNumberKeyword":
      case "TSObjectKeyword":
      case "TSStringKeyword":
      case "TSSymbolKeyword":
      case "TSUndefinedKeyword":
      case "TSUnknownKeyword":
      case "TSVoidKeyword":
      case "TSThisType":
      case "TSFunctionType":
      case "TSConstructorType":
      case "TSTypeReference":
      case "TSTypePredicate":
      case "TSTypeQuery":
      case "TSTypeLiteral":
      case "TSArrayType":
      case "TSTupleType":
      case "TSOptionalType":
      case "TSRestType":
      case "TSNamedTupleMember":
      case "TSUnionType":
      case "TSIntersectionType":
      case "TSConditionalType":
      case "TSInferType":
      case "TSParenthesizedType":
      case "TSTypeOperator":
      case "TSIndexedAccessType":
      case "TSMappedType":
      case "TSLiteralType":
      case "TSExpressionWithTypeArguments":
      case "TSInterfaceDeclaration":
      case "TSInterfaceBody":
      case "TSTypeAliasDeclaration":
      case "TSInstantiationExpression":
      case "TSAsExpression":
      case "TSSatisfiesExpression":
      case "TSTypeAssertion":
      case "TSEnumDeclaration":
      case "TSEnumMember":
      case "TSModuleDeclaration":
      case "TSModuleBlock":
      case "TSImportType":
      case "TSImportEqualsDeclaration":
      case "TSExternalModuleReference":
      case "TSNonNullExpression":
      case "TSExportAssignment":
      case "TSNamespaceExportDeclaration":
      case "TSTypeAnnotation":
      case "TSTypeParameterInstantiation":
      case "TSTypeParameterDeclaration":
      case "TSTypeParameter":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isTypeofTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "TypeofTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isUnaryExpression = function (e, t) {
    return (
      !!e &&
      "UnaryExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isUnaryLike = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "UnaryExpression":
      case "SpreadElement":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isUnionTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "UnionTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isUpdateExpression = function (e, t) {
    return (
      !!e &&
      "UpdateExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isUserWhitespacable = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "ObjectMethod":
      case "ObjectProperty":
      case "ObjectTypeInternalSlot":
      case "ObjectTypeCallProperty":
      case "ObjectTypeIndexer":
      case "ObjectTypeProperty":
      case "ObjectTypeSpreadProperty":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isV8IntrinsicIdentifier = function (e, t) {
    return (
      !!e &&
      "V8IntrinsicIdentifier" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isVariableDeclaration = function (e, t) {
    return (
      !!e &&
      "VariableDeclaration" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isVariableDeclarator = function (e, t) {
    return (
      !!e &&
      "VariableDeclarator" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isVariance = function (e, t) {
    return !!e && "Variance" === e.type && (null == t || (0, ji.default)(e, t));
  }),
  (_i.isVoidTypeAnnotation = function (e, t) {
    return (
      !!e &&
      "VoidTypeAnnotation" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isWhile = function (e, t) {
    if (!e) return !1;
    switch (e.type) {
      case "DoWhileStatement":
      case "WhileStatement":
        break;
      default:
        return !1;
    }
    return null == t || (0, ji.default)(e, t);
  }),
  (_i.isWhileStatement = function (e, t) {
    return (
      !!e && "WhileStatement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isWithStatement = function (e, t) {
    return (
      !!e && "WithStatement" === e.type && (null == t || (0, ji.default)(e, t))
    );
  }),
  (_i.isYieldExpression = function (e, t) {
    return (
      !!e &&
      "YieldExpression" === e.type &&
      (null == t || (0, ji.default)(e, t))
    );
  });
var ji = Di,
  Fi = Li;
function Bi(e, t) {
  if (!e) return !1;
  switch (e.type) {
    case "ExportAllDeclaration":
    case "ExportDefaultDeclaration":
    case "ExportNamedDeclaration":
    case "ImportDeclaration":
      break;
    default:
      return !1;
  }
  return null == t || (0, ji.default)(e, t);
}
Object.defineProperty(Ni, "__esModule", { value: !0 }),
  (Ni.default = function (e, t, r) {
    if (!(0, Ri.isMemberExpression)(e)) return !1;
    var n,
      i = Array.isArray(t) ? t : t.split("."),
      a = [];
    for (n = e; (0, Ri.isMemberExpression)(n); n = n.object) a.push(n.property);
    if ((a.push(n), a.length < i.length)) return !1;
    if (!r && a.length > i.length) return !1;
    for (var s = 0, o = a.length - 1; s < i.length; s++, o--) {
      var l = a[o],
        u = void 0;
      if ((0, Ri.isIdentifier)(l)) u = l.name;
      else if ((0, Ri.isStringLiteral)(l)) u = l.value;
      else {
        if (!(0, Ri.isThisExpression)(l)) return !1;
        u = "this";
      }
      if (i[s] !== u) return !1;
    }
    return !0;
  });
var Ri = _i;
Object.defineProperty(Oi, "__esModule", { value: !0 }),
  (Oi.default = function (e, t) {
    var r = e.split(".");
    return function (e) {
      return (0, Ui.default)(e, r, t);
    };
  });
var Ui = Ni;
Object.defineProperty(Ii, "__esModule", { value: !0 }), (Ii.default = void 0);
var Vi = (0, Oi.default)("React.Component");
Ii.default = Vi;
var Ki = {};
Object.defineProperty(Ki, "__esModule", { value: !0 }),
  (Ki.default = function (e) {
    return !!e && /^[a-z]/.test(e);
  });
var Wi = {},
  qi = {},
  Hi = {},
  Yi = {},
  Ji = {},
  Xi = {},
  Gi = null;
function zi(e) {
  if (null !== Gi && g(Gi.property)) {
    var t = Gi;
    return (Gi = zi.prototype = null), t;
  }
  return (Gi = zi.prototype = null == e ? Object.create(null) : e), new zi();
}
zi();
var $i,
  Qi = function (e) {
    return zi(e);
  },
  Zi = {},
  ea = {},
  ta = {};
function ra(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return na(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return na(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function na(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function ia() {
  if ($i) return ta;
  ($i = 1),
    Object.defineProperty(ta, "__esModule", { value: !0 }),
    (ta.default = function (t, r) {
      if (t === r) return !0;
      if (e.ALIAS_KEYS[r]) return !1;
      var n = e.FLIPPED_ALIAS_KEYS[r];
      if (n) {
        if (n[0] === t) return !0;
        var i,
          a = ra(n);
        try {
          for (a.s(); !(i = a.n()).done; ) {
            if (t === i.value) return !0;
          }
        } catch (e) {
          a.e(e);
        } finally {
          a.f();
        }
      }
      return !1;
    });
  var e = Ps();
  return ta;
}
var aa,
  sa,
  oa = {};
function la(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return ua(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return ua(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function ua(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function ca() {
  if (aa) return oa;
  (aa = 1),
    Object.defineProperty(oa, "__esModule", { value: !0 }),
    (oa.default = function (t, r) {
      if (t === r) return !0;
      var n = e.PLACEHOLDERS_ALIAS[t];
      if (n) {
        var i,
          a = la(n);
        try {
          for (a.s(); !(i = a.n()).done; ) {
            if (r === i.value) return !0;
          }
        } catch (e) {
          a.e(e);
        } finally {
          a.f();
        }
      }
      return !1;
    });
  var e = Ps();
  return oa;
}
function pa() {
  if (sa) return ea;
  (sa = 1),
    Object.defineProperty(ea, "__esModule", { value: !0 }),
    (ea.default = function (i, a, s) {
      if (!a) return !1;
      var o = (0, t.default)(a.type, i);
      if (!o)
        return (
          !s &&
          "Placeholder" === a.type &&
          i in n.FLIPPED_ALIAS_KEYS &&
          (0, r.default)(a.expectedNode, i)
        );
      return void 0 === s || (0, e.default)(a, s);
    });
  var e = Di,
    t = ia(),
    r = ca(),
    n = Ps();
  return ea;
}
var ha = {},
  da = {},
  fa = {};
Object.defineProperty(fa, "__esModule", { value: !0 }),
  (fa.isIdentifierChar = Ea),
  (fa.isIdentifierName = function (e) {
    for (var t = !0, r = 0; r < e.length; r++) {
      var n = e.charCodeAt(r);
      if (55296 == (64512 & n) && r + 1 < e.length) {
        var i = e.charCodeAt(++r);
        56320 == (64512 & i) && (n = 65536 + ((1023 & n) << 10) + (1023 & i));
      }
      if (t) {
        if (((t = !1), !xa(n))) return !1;
      } else if (!Ea(n)) return !1;
    }
    return !t;
  }),
  (fa.isIdentifierStart = xa);
var ya =
    "ªµºÀ-ÖØ-öø-ˁˆ-ˑˠ-ˤˬˮͰ-ʹͶͷͺ-ͽͿΆΈ-ΊΌΎ-ΡΣ-ϵϷ-ҁҊ-ԯԱ-Ֆՙՠ-ֈא-תׯ-ײؠ-يٮٯٱ-ۓەۥۦۮۯۺ-ۼۿܐܒ-ܯݍ-ޥޱߊ-ߪߴߵߺࠀ-ࠕࠚࠤࠨࡀ-ࡘࡠ-ࡪࡰ-ࢇࢉ-ࢎࢠ-ࣉऄ-हऽॐक़-ॡॱ-ঀঅ-ঌএঐও-নপ-রলশ-হঽৎড়ঢ়য়-ৡৰৱৼਅ-ਊਏਐਓ-ਨਪ-ਰਲਲ਼ਵਸ਼ਸਹਖ਼-ੜਫ਼ੲ-ੴઅ-ઍએ-ઑઓ-નપ-રલળવ-હઽૐૠૡૹଅ-ଌଏଐଓ-ନପ-ରଲଳଵ-ହଽଡ଼ଢ଼ୟ-ୡୱஃஅ-ஊஎ-ஐஒ-கஙசஜஞடணதந-பம-ஹௐఅ-ఌఎ-ఐఒ-నప-హఽౘ-ౚౝౠౡಀಅ-ಌಎ-ಐಒ-ನಪ-ಳವ-ಹಽೝೞೠೡೱೲഄ-ഌഎ-ഐഒ-ഺഽൎൔ-ൖൟ-ൡൺ-ൿඅ-ඖක-නඳ-රලව-ෆก-ะาำเ-ๆກຂຄຆ-ຊຌ-ຣລວ-ະາຳຽເ-ໄໆໜ-ໟༀཀ-ཇཉ-ཬྈ-ྌက-ဪဿၐ-ၕၚ-ၝၡၥၦၮ-ၰၵ-ႁႎႠ-ჅჇჍა-ჺჼ-ቈቊ-ቍቐ-ቖቘቚ-ቝበ-ኈኊ-ኍነ-ኰኲ-ኵኸ-ኾዀዂ-ዅወ-ዖዘ-ጐጒ-ጕጘ-ፚᎀ-ᎏᎠ-Ᏽᏸ-ᏽᐁ-ᙬᙯ-ᙿᚁ-ᚚᚠ-ᛪᛮ-ᛸᜀ-ᜑᜟ-ᜱᝀ-ᝑᝠ-ᝬᝮ-ᝰក-ឳៗៜᠠ-ᡸᢀ-ᢨᢪᢰ-ᣵᤀ-ᤞᥐ-ᥭᥰ-ᥴᦀ-ᦫᦰ-ᧉᨀ-ᨖᨠ-ᩔᪧᬅ-ᬳᭅ-ᭌᮃ-ᮠᮮᮯᮺ-ᯥᰀ-ᰣᱍ-ᱏᱚ-ᱽᲀ-ᲈᲐ-ᲺᲽ-Ჿᳩ-ᳬᳮ-ᳳᳵᳶᳺᴀ-ᶿḀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼιῂ-ῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲ-ῴῶ-ῼⁱⁿₐ-ₜℂℇℊ-ℓℕ℘-ℝℤΩℨK-ℹℼ-ℿⅅ-ⅉⅎⅠ-ↈⰀ-ⳤⳫ-ⳮⳲⳳⴀ-ⴥⴧⴭⴰ-ⵧⵯⶀ-ⶖⶠ-ⶦⶨ-ⶮⶰ-ⶶⶸ-ⶾⷀ-ⷆⷈ-ⷎⷐ-ⷖⷘ-ⷞ々-〇〡-〩〱-〵〸-〼ぁ-ゖ゛-ゟァ-ヺー-ヿㄅ-ㄯㄱ-ㆎㆠ-ㆿㇰ-ㇿ㐀-䶿一-ꒌꓐ-ꓽꔀ-ꘌꘐ-ꘟꘪꘫꙀ-ꙮꙿ-ꚝꚠ-ꛯꜗ-ꜟꜢ-ꞈꞋ-ꟊꟐꟑꟓꟕ-ꟙꟲ-ꠁꠃ-ꠅꠇ-ꠊꠌ-ꠢꡀ-ꡳꢂ-ꢳꣲ-ꣷꣻꣽꣾꤊ-ꤥꤰ-ꥆꥠ-ꥼꦄ-ꦲꧏꧠ-ꧤꧦ-ꧯꧺ-ꧾꨀ-ꨨꩀ-ꩂꩄ-ꩋꩠ-ꩶꩺꩾ-ꪯꪱꪵꪶꪹ-ꪽꫀꫂꫛ-ꫝꫠ-ꫪꫲ-ꫴꬁ-ꬆꬉ-ꬎꬑ-ꬖꬠ-ꬦꬨ-ꬮꬰ-ꭚꭜ-ꭩꭰ-ꯢ가-힣ힰ-ퟆퟋ-ퟻ豈-舘並-龎ﬀ-ﬆﬓ-ﬗיִײַ-ﬨשׁ-זּטּ-לּמּנּסּףּפּצּ-ﮱﯓ-ﴽﵐ-ﶏﶒ-ﷇﷰ-ﷻﹰ-ﹴﹶ-ﻼＡ-Ｚａ-ｚｦ-ﾾￂ-ￇￊ-ￏￒ-ￗￚ-ￜ",
  ma =
    "‌‍·̀-ͯ·҃-֑҇-ׇֽֿׁׂׅׄؐ-ًؚ-٩ٰۖ-ۜ۟-۪ۤۧۨ-ۭ۰-۹ܑܰ-݊ަ-ް߀-߉߫-߽߳ࠖ-࠙ࠛ-ࠣࠥ-ࠧࠩ-࡙࠭-࡛࢘-࢟࣊-ࣣ࣡-ःऺ-़ा-ॏ॑-ॗॢॣ०-९ঁ-ঃ়া-ৄেৈো-্ৗৢৣ০-৯৾ਁ-ਃ਼ਾ-ੂੇੈੋ-੍ੑ੦-ੱੵઁ-ઃ઼ા-ૅે-ૉો-્ૢૣ૦-૯ૺ-૿ଁ-ଃ଼ା-ୄେୈୋ-୍୕-ୗୢୣ୦-୯ஂா-ூெ-ைொ-்ௗ௦-௯ఀ-ఄ఼ా-ౄె-ైొ-్ౕౖౢౣ౦-౯ಁ-ಃ಼ಾ-ೄೆ-ೈೊ-್ೕೖೢೣ೦-೯ೳഀ-ഃ഻഼ാ-ൄെ-ൈൊ-്ൗൢൣ൦-൯ඁ-ඃ්ා-ුූෘ-ෟ෦-෯ෲෳัิ-ฺ็-๎๐-๙ັິ-ຼ່-໎໐-໙༘༙༠-༩༹༵༷༾༿ཱ-྄྆྇ྍ-ྗྙ-ྼ࿆ါ-ှ၀-၉ၖ-ၙၞ-ၠၢ-ၤၧ-ၭၱ-ၴႂ-ႍႏ-ႝ፝-፟፩-፱ᜒ-᜕ᜲ-᜴ᝒᝓᝲᝳ឴-៓៝០-៩᠋-᠍᠏-᠙ᢩᤠ-ᤫᤰ-᤻᥆-᥏᧐-᧚ᨗ-ᨛᩕ-ᩞ᩠-᩿᩼-᪉᪐-᪙᪰-᪽ᪿ-ᫎᬀ-ᬄ᬴-᭄᭐-᭙᭫-᭳ᮀ-ᮂᮡ-ᮭ᮰-᮹᯦-᯳ᰤ-᰷᱀-᱉᱐-᱙᳐-᳔᳒-᳨᳭᳴᳷-᳹᷀-᷿‿⁀⁔⃐-⃥⃜⃡-⃰⳯-⵿⳱ⷠ-〪ⷿ-゙゚〯꘠-꘩꙯ꙴ-꙽ꚞꚟ꛰꛱ꠂ꠆ꠋꠣ-ꠧ꠬ꢀꢁꢴ-ꣅ꣐-꣙꣠-꣱ꣿ-꤉ꤦ-꤭ꥇ-꥓ꦀ-ꦃ꦳-꧀꧐-꧙ꧥ꧰-꧹ꨩ-ꨶꩃꩌꩍ꩐-꩙ꩻ-ꩽꪰꪲ-ꪴꪷꪸꪾ꪿꫁ꫫ-ꫯꫵ꫶ꯣ-ꯪ꯬꯭꯰-꯹ﬞ︀-️︠-︯︳︴﹍-﹏０-９＿",
  va = new RegExp("[" + ya + "]"),
  ga = new RegExp("[" + ya + ma + "]");
ya = ma = null;
var ba = [
    0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48,
    48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5,
    39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10,
    21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11,
    22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2,
    2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72,
    56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20,
    28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4,
    0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2,
    14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4,
    159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0,
    60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2,
    23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12,
    45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0,
    26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921,
    103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30,
    18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67,
    12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16,
    0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2,
    70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2,
    27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2,
    24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11,
    6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60,
    67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5,
    0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0,
    3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719,
    33, 4153, 7, 221, 3, 5761, 15, 7472, 3104, 541, 1507, 4938, 6, 4191,
  ],
  Ta = [
    509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1,
    574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1,
    11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13,
    9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3,
    2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3,
    8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5,
    2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0,
    10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2,
    6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4,
    14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54,
    8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31,
    3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2,
    16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983,
    6, 110, 6, 6, 9, 4759, 9, 787719, 239,
  ];
function Sa(e, t) {
  for (var r = 65536, n = 0, i = t.length; n < i; n += 2) {
    if ((r += t[n]) > e) return !1;
    if ((r += t[n + 1]) >= e) return !0;
  }
  return !1;
}
function xa(e) {
  return e < 65
    ? 36 === e
    : e <= 90 ||
        (e < 97
          ? 95 === e
          : e <= 122 ||
            (e <= 65535
              ? e >= 170 && va.test(String.fromCharCode(e))
              : Sa(e, ba)));
}
function Ea(e) {
  return e < 48
    ? 36 === e
    : e < 58 ||
        (!(e < 65) &&
          (e <= 90 ||
            (e < 97
              ? 95 === e
              : e <= 122 ||
                (e <= 65535
                  ? e >= 170 && ga.test(String.fromCharCode(e))
                  : Sa(e, ba) || Sa(e, Ta)))));
}
var Pa = {};
Object.defineProperty(Pa, "__esModule", { value: !0 }),
  (Pa.isKeyword = function (e) {
    return wa.has(e);
  }),
  (Pa.isReservedWord = Oa),
  (Pa.isStrictBindOnlyReservedWord = _a),
  (Pa.isStrictBindReservedWord = function (e, t) {
    return Na(e, t) || _a(e);
  }),
  (Pa.isStrictReservedWord = Na);
var Aa = [
    "implements",
    "interface",
    "let",
    "package",
    "private",
    "protected",
    "public",
    "static",
    "yield",
  ],
  ka = ["eval", "arguments"],
  wa = new Set([
    "break",
    "case",
    "catch",
    "continue",
    "debugger",
    "default",
    "do",
    "else",
    "finally",
    "for",
    "function",
    "if",
    "return",
    "switch",
    "throw",
    "try",
    "var",
    "const",
    "while",
    "with",
    "new",
    "this",
    "super",
    "class",
    "extends",
    "export",
    "import",
    "null",
    "true",
    "false",
    "in",
    "instanceof",
    "typeof",
    "void",
    "delete",
  ]),
  Ca = new Set(Aa),
  Ia = new Set(ka);
function Oa(e, t) {
  return (t && "await" === e) || "enum" === e;
}
function Na(e, t) {
  return Oa(e, t) || Ca.has(e);
}
function _a(e) {
  return Ia.has(e);
}
!(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    Object.defineProperty(e, "isIdentifierChar", {
      enumerable: !0,
      get: function () {
        return t.isIdentifierChar;
      },
    }),
    Object.defineProperty(e, "isIdentifierName", {
      enumerable: !0,
      get: function () {
        return t.isIdentifierName;
      },
    }),
    Object.defineProperty(e, "isIdentifierStart", {
      enumerable: !0,
      get: function () {
        return t.isIdentifierStart;
      },
    }),
    Object.defineProperty(e, "isKeyword", {
      enumerable: !0,
      get: function () {
        return r.isKeyword;
      },
    }),
    Object.defineProperty(e, "isReservedWord", {
      enumerable: !0,
      get: function () {
        return r.isReservedWord;
      },
    }),
    Object.defineProperty(e, "isStrictBindOnlyReservedWord", {
      enumerable: !0,
      get: function () {
        return r.isStrictBindOnlyReservedWord;
      },
    }),
    Object.defineProperty(e, "isStrictBindReservedWord", {
      enumerable: !0,
      get: function () {
        return r.isStrictBindReservedWord;
      },
    }),
    Object.defineProperty(e, "isStrictReservedWord", {
      enumerable: !0,
      get: function () {
        return r.isStrictReservedWord;
      },
    });
  var t = fa,
    r = Pa;
})(da),
  Object.defineProperty(ha, "__esModule", { value: !0 }),
  (ha.default = function (e) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
    if ("string" != typeof e) return !1;
    if (t && ((0, Da.isKeyword)(e) || (0, Da.isStrictReservedWord)(e, !0)))
      return !1;
    return (0, Da.isIdentifierName)(e);
  });
var Da = da;
var La,
  Ma = {};
var ja = {};
Object.defineProperty(ja, "__esModule", { value: !0 }),
  (ja.UPDATE_OPERATORS =
    ja.UNARY_OPERATORS =
    ja.STRING_UNARY_OPERATORS =
    ja.STATEMENT_OR_BLOCK_KEYS =
    ja.NUMBER_UNARY_OPERATORS =
    ja.NUMBER_BINARY_OPERATORS =
    ja.NOT_LOCAL_BINDING =
    ja.LOGICAL_OPERATORS =
    ja.INHERIT_KEYS =
    ja.FOR_INIT_KEYS =
    ja.FLATTENABLE_KEYS =
    ja.EQUALITY_BINARY_OPERATORS =
    ja.COMPARISON_BINARY_OPERATORS =
    ja.COMMENT_KEYS =
    ja.BOOLEAN_UNARY_OPERATORS =
    ja.BOOLEAN_NUMBER_BINARY_OPERATORS =
    ja.BOOLEAN_BINARY_OPERATORS =
    ja.BLOCK_SCOPED_SYMBOL =
    ja.BINARY_OPERATORS =
    ja.ASSIGNMENT_OPERATORS =
      void 0);
ja.STATEMENT_OR_BLOCK_KEYS = ["consequent", "body", "alternate"];
ja.FLATTENABLE_KEYS = ["body", "expressions"];
ja.FOR_INIT_KEYS = ["left", "init"];
ja.COMMENT_KEYS = ["leadingComments", "trailingComments", "innerComments"];
var Fa = ["||", "&&", "??"];
ja.LOGICAL_OPERATORS = Fa;
ja.UPDATE_OPERATORS = ["++", "--"];
var Ba = [">", "<", ">=", "<="];
ja.BOOLEAN_NUMBER_BINARY_OPERATORS = Ba;
var Ra = ["==", "===", "!=", "!=="];
ja.EQUALITY_BINARY_OPERATORS = Ra;
var Ua = [].concat(Ra, ["in", "instanceof"]);
ja.COMPARISON_BINARY_OPERATORS = Ua;
var Va = [].concat(K(Ua), Ba);
ja.BOOLEAN_BINARY_OPERATORS = Va;
var Ka = ["-", "/", "%", "*", "**", "&", "|", ">>", ">>>", "<<", "^"];
ja.NUMBER_BINARY_OPERATORS = Ka;
var Wa = ["+"].concat(Ka, K(Va), ["|>"]);
ja.BINARY_OPERATORS = Wa;
var qa = ["=", "+="].concat(
  K(
    Ka.map(function (e) {
      return e + "=";
    })
  ),
  K(
    Fa.map(function (e) {
      return e + "=";
    })
  )
);
ja.ASSIGNMENT_OPERATORS = qa;
var Ha = ["delete", "!"];
ja.BOOLEAN_UNARY_OPERATORS = Ha;
var Ya = ["+", "-", "~"];
ja.NUMBER_UNARY_OPERATORS = Ya;
var Ja = ["typeof"];
ja.STRING_UNARY_OPERATORS = Ja;
var Xa = ["void", "throw"].concat(Ha, Ya, Ja);
ja.UNARY_OPERATORS = Xa;
ja.INHERIT_KEYS = {
  optional: ["typeAnnotation", "typeParameters", "returnType"],
  force: ["start", "loc", "end"],
};
var Ga = Symbol.for("var used to be block scoped");
ja.BLOCK_SCOPED_SYMBOL = Ga;
var za = Symbol.for("should not be considered a local binding");
ja.NOT_LOCAL_BINDING = za;
var $a,
  Qa,
  Za = {};
function es(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return ts(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return ts(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function ts(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function rs() {
  if ($a) return Za;
  ($a = 1),
    Object.defineProperty(Za, "__esModule", { value: !0 }),
    (Za.VISITOR_KEYS =
      Za.NODE_PARENT_VALIDATIONS =
      Za.NODE_FIELDS =
      Za.FLIPPED_ALIAS_KEYS =
      Za.DEPRECATED_KEYS =
      Za.BUILDER_KEYS =
      Za.ALIAS_KEYS =
        void 0),
    (Za.arrayOf = h),
    (Za.arrayOfType = d),
    (Za.assertEach = f),
    (Za.assertNodeOrValueType = function () {
      for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
        n[i] = arguments[i];
      function a(r, i, a) {
        var s,
          o = es(n);
        try {
          for (o.s(); !(s = o.n()).done; ) {
            var l = s.value;
            if (u(a) === l || (0, e.default)(l, a))
              return void (0, t.validateChild)(r, i, a);
          }
        } catch (e) {
          o.e(e);
        } finally {
          o.f();
        }
        throw new TypeError(
          "Property "
            .concat(i, " of ")
            .concat(r.type, " expected node to be of a type ")
            .concat(JSON.stringify(n), " but instead got ")
            .concat(JSON.stringify(null == a ? void 0 : a.type))
        );
      }
      return (a.oneOfNodeOrValueTypes = n), a;
    }),
    (Za.assertNodeType = y),
    (Za.assertOneOf = function () {
      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
        t[r] = arguments[r];
      function n(e, r, n) {
        if (t.indexOf(n) < 0)
          throw new TypeError(
            "Property "
              .concat(r, " expected value to be one of ")
              .concat(JSON.stringify(t), " but got ")
              .concat(JSON.stringify(n))
          );
      }
      return (n.oneOf = t), n;
    }),
    (Za.assertOptionalChainStart = function () {
      return function (e) {
        for (var t, r = e; e; ) {
          var n = r.type;
          if ("OptionalCallExpression" !== n) {
            if ("OptionalMemberExpression" !== n) break;
            if (r.optional) return;
            r = r.object;
          } else {
            if (r.optional) return;
            r = r.callee;
          }
        }
        throw new TypeError(
          "Non-optional "
            .concat(
              e.type,
              " must chain from an optional OptionalMemberExpression or OptionalCallExpression. Found chain from "
            )
            .concat(null == (t = r) ? void 0 : t.type)
        );
      };
    }),
    (Za.assertShape = function (e) {
      function r(r, n, i) {
        for (var a = [], s = 0, o = Object.keys(e); s < o.length; s++) {
          var l = o[s];
          try {
            (0, t.validateField)(r, l, i[l], e[l]);
          } catch (e) {
            if (e instanceof TypeError) {
              a.push(e.message);
              continue;
            }
            throw e;
          }
        }
        if (a.length)
          throw new TypeError(
            "Property "
              .concat(n, " of ")
              .concat(r.type, " expected to have the following:\n")
              .concat(a.join("\n"))
          );
      }
      return (r.shapeOf = e), r;
    }),
    (Za.assertValueType = m),
    (Za.chain = v),
    (Za.default = x),
    (Za.defineAliasedType = function () {
      for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
        t[r] = arguments[r];
      return function (e) {
        var r,
          n,
          i =
            arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
          a = i.aliases;
        a ||
          (i.inherits &&
            (a = null == (n = S[i.inherits].aliases) ? void 0 : n.slice()),
          null != a || (a = []),
          (i.aliases = a));
        var s = t.filter(function (e) {
          return !a.includes(e);
        });
        (r = a).unshift.apply(r, K(s)), x(e, i);
      };
    }),
    (Za.typeIs = p),
    (Za.validate = c),
    (Za.validateArrayOfType = function (e) {
      return c(d(e));
    }),
    (Za.validateOptional = function (e) {
      return { validate: e, optional: !0 };
    }),
    (Za.validateOptionalType = function (e) {
      return { validate: p(e), optional: !0 };
    }),
    (Za.validateType = function (e) {
      return c(p(e));
    });
  var e = pa(),
    t = As(),
    r = {};
  Za.VISITOR_KEYS = r;
  var n = {};
  Za.ALIAS_KEYS = n;
  var i = {};
  Za.FLIPPED_ALIAS_KEYS = i;
  var a = {};
  Za.NODE_FIELDS = a;
  var s = {};
  Za.BUILDER_KEYS = s;
  var o = {};
  Za.DEPRECATED_KEYS = o;
  var l = {};
  function u(e) {
    return Array.isArray(e) ? "array" : null === e ? "null" : g(e);
  }
  function c(e) {
    return { validate: e };
  }
  function p(e) {
    return "string" == typeof e ? y(e) : y.apply(void 0, K(e));
  }
  function h(e) {
    return v(m("array"), f(e));
  }
  function d(e) {
    return h(p(e));
  }
  function f(e) {
    function r(r, n, i) {
      if (Array.isArray(i))
        for (var a = 0; a < i.length; a++) {
          var s = "".concat(n, "[").concat(a, "]"),
            o = i[a];
          e(r, s, o),
            process.env.BABEL_TYPES_8_BREAKING && (0, t.validateChild)(r, s, o);
        }
    }
    return (r.each = e), r;
  }
  function y() {
    for (var r = arguments.length, n = new Array(r), i = 0; i < r; i++)
      n[i] = arguments[i];
    function a(r, i, a) {
      var s,
        o = es(n);
      try {
        for (o.s(); !(s = o.n()).done; ) {
          var l = s.value;
          if ((0, e.default)(l, a)) return void (0, t.validateChild)(r, i, a);
        }
      } catch (e) {
        o.e(e);
      } finally {
        o.f();
      }
      throw new TypeError(
        "Property "
          .concat(i, " of ")
          .concat(r.type, " expected node to be of a type ")
          .concat(JSON.stringify(n), " but instead got ")
          .concat(JSON.stringify(null == a ? void 0 : a.type))
      );
    }
    return (a.oneOfNodeTypes = n), a;
  }
  function m(e) {
    function t(t, r, n) {
      if (!(u(n) === e))
        throw new TypeError(
          "Property "
            .concat(r, " expected type of ")
            .concat(e, " but got ")
            .concat(u(n))
        );
    }
    return (t.type = e), t;
  }
  function v() {
    for (var e = arguments.length, t = new Array(e), r = 0; r < e; r++)
      t[r] = arguments[r];
    function n() {
      var e,
        r = es(t);
      try {
        for (r.s(); !(e = r.n()).done; ) {
          e.value.apply(void 0, arguments);
        }
      } catch (e) {
        r.e(e);
      } finally {
        r.f();
      }
    }
    if (
      ((n.chainOf = t),
      t.length >= 2 &&
        "type" in t[0] &&
        "array" === t[0].type &&
        !("each" in t[1]))
    )
      throw new Error(
        'An assertValueType("array") validator can only be followed by an assertEach(...) validator.'
      );
    return n;
  }
  Za.NODE_PARENT_VALIDATIONS = l;
  var b = [
      "aliases",
      "builder",
      "deprecatedAlias",
      "fields",
      "inherits",
      "visitor",
      "validate",
    ],
    T = ["default", "optional", "validate"],
    S = {};
  function x(e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
      c = (t.inherits && S[t.inherits]) || {},
      p = t.fields;
    if (!p && ((p = {}), c.fields)) {
      var h,
        d = es(Object.getOwnPropertyNames(c.fields));
      try {
        for (d.s(); !(h = d.n()).done; ) {
          var f = h.value,
            y = c.fields[f],
            v = y.default;
          if (Array.isArray(v) ? v.length > 0 : v && "object" === g(v))
            throw new Error(
              "field defaults can only be primitives or empty arrays currently"
            );
          p[f] = {
            default: Array.isArray(v) ? [] : v,
            optional: y.optional,
            validate: y.validate,
          };
        }
      } catch (e) {
        d.e(e);
      } finally {
        d.f();
      }
    }
    for (
      var x = t.visitor || c.visitor || [],
        E = t.aliases || c.aliases || [],
        P = t.builder || c.builder || t.visitor || [],
        A = 0,
        k = Object.keys(t);
      A < k.length;
      A++
    ) {
      var w = k[A];
      if (-1 === b.indexOf(w))
        throw new Error('Unknown type option "'.concat(w, '" on ').concat(e));
    }
    t.deprecatedAlias && (o[t.deprecatedAlias] = e);
    var C,
      I = es(x.concat(P));
    try {
      for (I.s(); !(C = I.n()).done; ) {
        var O = C.value;
        p[O] = p[O] || {};
      }
    } catch (e) {
      I.e(e);
    } finally {
      I.f();
    }
    for (var N = 0, _ = Object.keys(p); N < _.length; N++) {
      var D = _[N],
        L = p[D];
      void 0 !== L.default && -1 === P.indexOf(D) && (L.optional = !0),
        void 0 === L.default
          ? (L.default = null)
          : L.validate || null == L.default || (L.validate = m(u(L.default)));
      for (var M = 0, j = Object.keys(L); M < j.length; M++) {
        var F = j[M];
        if (-1 === T.indexOf(F))
          throw new Error(
            'Unknown field key "'.concat(F, '" on ').concat(e, ".").concat(D)
          );
      }
    }
    (r[e] = t.visitor = x),
      (s[e] = t.builder = P),
      (a[e] = t.fields = p),
      (n[e] = t.aliases = E),
      E.forEach(function (t) {
        (i[t] = i[t] || []), i[t].push(e);
      }),
      t.validate && (l[e] = t.validate),
      (S[e] = t);
  }
  return Za;
}
function ns() {
  if (Qa) return Zi;
  (Qa = 1),
    Object.defineProperty(Zi, "__esModule", { value: !0 }),
    (Zi.patternLikeCommon =
      Zi.functionTypeAnnotationCommon =
      Zi.functionDeclarationCommon =
      Zi.functionCommon =
      Zi.classMethodOrPropertyCommon =
      Zi.classMethodOrDeclareMethodCommon =
        void 0);
  var e = pa(),
    t = ha,
    r = da,
    n = (function () {
      if (La) return Ma;
      (La = 1),
        Object.defineProperty(Ma, "__esModule", { value: !0 }),
        (Ma.readCodePoint = o),
        (Ma.readInt = s),
        (Ma.readStringContents = function (e, t, r, a, s, o) {
          for (
            var l = r, u = a, c = s, p = "", h = null, d = r, f = t.length;
            ;

          ) {
            if (r >= f) {
              o.unterminated(l, u, c), (p += t.slice(d, r));
              break;
            }
            var y = t.charCodeAt(r);
            if (n(e, y, t, r)) {
              p += t.slice(d, r);
              break;
            }
            if (92 === y) {
              p += t.slice(d, r);
              var m = i(t, r, a, s, "template" === e, o);
              null !== m.ch || h
                ? (p += m.ch)
                : (h = { pos: r, lineStart: a, curLine: s }),
                (r = m.pos),
                (a = m.lineStart),
                (s = m.curLine),
                (d = r);
            } else
              8232 === y || 8233 === y
                ? (++s, (a = ++r))
                : 10 === y || 13 === y
                ? "template" === e
                  ? ((p += t.slice(d, r) + "\n"),
                    ++r,
                    13 === y && 10 === t.charCodeAt(r) && ++r,
                    ++s,
                    (d = a = r))
                  : o.unterminated(l, u, c)
                : ++r;
          }
          return {
            pos: r,
            str: p,
            firstInvalidLoc: h,
            lineStart: a,
            curLine: s,
            containsInvalid: !!h,
          };
        });
      var e = function (e) {
          return e >= 48 && e <= 57;
        },
        t = {
          decBinOct: new Set([46, 66, 69, 79, 95, 98, 101, 111]),
          hex: new Set([46, 88, 95, 120]),
        },
        r = {
          bin: function (e) {
            return 48 === e || 49 === e;
          },
          oct: function (e) {
            return e >= 48 && e <= 55;
          },
          dec: function (e) {
            return e >= 48 && e <= 57;
          },
          hex: function (e) {
            return (
              (e >= 48 && e <= 57) ||
              (e >= 65 && e <= 70) ||
              (e >= 97 && e <= 102)
            );
          },
        };
      function n(e, t, r, n) {
        return "template" === e
          ? 96 === t || (36 === t && 123 === r.charCodeAt(n + 1))
          : t === ("double" === e ? 34 : 39);
      }
      function i(e, t, r, n, i, s) {
        var l = !i;
        t++;
        var u = function (e) {
            return { pos: t, ch: e, lineStart: r, curLine: n };
          },
          c = e.charCodeAt(t++);
        switch (c) {
          case 110:
            return u("\n");
          case 114:
            return u("\r");
          case 120:
            var p,
              h = a(e, t, r, n, 2, !1, l, s);
            return (
              (p = h.code),
              (t = h.pos),
              u(null === p ? null : String.fromCharCode(p))
            );
          case 117:
            var d,
              f = o(e, t, r, n, l, s);
            return (
              (d = f.code),
              (t = f.pos),
              u(null === d ? null : String.fromCodePoint(d))
            );
          case 116:
            return u("\t");
          case 98:
            return u("\b");
          case 118:
            return u("\v");
          case 102:
            return u("\f");
          case 13:
            10 === e.charCodeAt(t) && ++t;
          case 10:
            (r = t), ++n;
          case 8232:
          case 8233:
            return u("");
          case 56:
          case 57:
            if (i) return u(null);
            s.strictNumericEscape(t - 1, r, n);
          default:
            if (c >= 48 && c <= 55) {
              var y = t - 1,
                m = e.slice(y, t + 2).match(/^[0-7]+/)[0],
                v = parseInt(m, 8);
              v > 255 && ((m = m.slice(0, -1)), (v = parseInt(m, 8))),
                (t += m.length - 1);
              var g = e.charCodeAt(t);
              if ("0" !== m || 56 === g || 57 === g) {
                if (i) return u(null);
                s.strictNumericEscape(y, r, n);
              }
              return u(String.fromCharCode(v));
            }
            return u(String.fromCharCode(c));
        }
      }
      function a(e, t, r, n, i, a, o, l) {
        var u,
          c = t,
          p = s(e, t, r, n, 16, i, a, !1, l, !o);
        return (
          (u = p.n),
          (t = p.pos),
          null === u && (o ? l.invalidEscapeSequence(c, r, n) : (t = c - 1)),
          { code: u, pos: t }
        );
      }
      function s(n, i, a, s, o, l, u, c, p, h) {
        for (
          var d = i,
            f = 16 === o ? t.hex : t.decBinOct,
            y = 16 === o ? r.hex : 10 === o ? r.dec : 8 === o ? r.oct : r.bin,
            m = !1,
            v = 0,
            g = 0,
            b = null == l ? 1 / 0 : l;
          g < b;
          ++g
        ) {
          var T = n.charCodeAt(i),
            S = void 0;
          if (95 !== T || "bail" === c) {
            if (
              (S =
                T >= 97
                  ? T - 97 + 10
                  : T >= 65
                  ? T - 65 + 10
                  : e(T)
                  ? T - 48
                  : 1 / 0) >= o
            ) {
              if (S <= 9 && h) return { n: null, pos: i };
              if (S <= 9 && p.invalidDigit(i, a, s, o)) S = 0;
              else {
                if (!u) break;
                (S = 0), (m = !0);
              }
            }
            ++i, (v = v * o + S);
          } else {
            var x = n.charCodeAt(i - 1),
              E = n.charCodeAt(i + 1);
            if (c) {
              if (Number.isNaN(E) || !y(E) || f.has(x) || f.has(E)) {
                if (h) return { n: null, pos: i };
                p.unexpectedNumericSeparator(i, a, s);
              }
            } else {
              if (h) return { n: null, pos: i };
              p.numericSeparatorInEscapeSequence(i, a, s);
            }
            ++i;
          }
        }
        return i === d || (null != l && i - d !== l) || m
          ? { n: null, pos: i }
          : { n: v, pos: i };
      }
      function o(e, t, r, n, i, s) {
        var o;
        if (123 === e.charCodeAt(t)) {
          var l = a(e, ++t, r, n, e.indexOf("}", t) - t, !0, i, s);
          if (((o = l.code), (t = l.pos), ++t, null !== o && o > 1114111)) {
            if (!i) return { code: null, pos: t };
            s.invalidCodePoint(t, r, n);
          }
        } else {
          var u = a(e, t, r, n, 4, !1, i, s);
          (o = u.code), (t = u.pos);
        }
        return { code: o, pos: t };
      }
      return Ma;
    })(),
    i = ja,
    a = rs(),
    s = (0, a.defineAliasedType)("Standardized");
  s("ArrayExpression", {
    fields: {
      elements: {
        validate: (0, a.chain)(
          (0, a.assertValueType)("array"),
          (0, a.assertEach)(
            (0, a.assertNodeOrValueType)("null", "Expression", "SpreadElement")
          )
        ),
        default: process.env.BABEL_TYPES_8_BREAKING ? void 0 : [],
      },
    },
    visitor: ["elements"],
    aliases: ["Expression"],
  }),
    s("AssignmentExpression", {
      fields: {
        operator: {
          validate: (function () {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return (0, a.assertValueType)("string");
            var t = a.assertOneOf.apply(void 0, K(i.ASSIGNMENT_OPERATORS)),
              r = (0, a.assertOneOf)("=");
            return function (n, i, a) {
              ((0, e.default)("Pattern", n.left) ? r : t)(n, i, a);
            };
          })(),
        },
        left: {
          validate: process.env.BABEL_TYPES_8_BREAKING
            ? (0, a.assertNodeType)(
                "Identifier",
                "MemberExpression",
                "ArrayPattern",
                "ObjectPattern",
                "TSAsExpression",
                "TSSatisfiesExpression",
                "TSTypeAssertion",
                "TSNonNullExpression"
              )
            : (0, a.assertNodeType)("LVal"),
        },
        right: { validate: (0, a.assertNodeType)("Expression") },
      },
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Expression"],
    }),
    s("BinaryExpression", {
      builder: ["operator", "left", "right"],
      fields: {
        operator: {
          validate: a.assertOneOf.apply(void 0, K(i.BINARY_OPERATORS)),
        },
        left: {
          validate: (function () {
            var e = (0, a.assertNodeType)("Expression"),
              t = (0, a.assertNodeType)("Expression", "PrivateName"),
              r = Object.assign(
                function (r, n, i) {
                  ("in" === r.operator ? t : e)(r, n, i);
                },
                { oneOfNodeTypes: ["Expression", "PrivateName"] }
              );
            return r;
          })(),
        },
        right: { validate: (0, a.assertNodeType)("Expression") },
      },
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
    }),
    s("InterpreterDirective", {
      builder: ["value"],
      fields: { value: { validate: (0, a.assertValueType)("string") } },
    }),
    s("Directive", {
      visitor: ["value"],
      fields: {
        value: { validate: (0, a.assertNodeType)("DirectiveLiteral") },
      },
    }),
    s("DirectiveLiteral", {
      builder: ["value"],
      fields: { value: { validate: (0, a.assertValueType)("string") } },
    }),
    s("BlockStatement", {
      builder: ["body", "directives"],
      visitor: ["directives", "body"],
      fields: {
        directives: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Directive"))
          ),
          default: [],
        },
        body: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Statement"))
          ),
        },
      },
      aliases: ["Scopable", "BlockParent", "Block", "Statement"],
    }),
    s("BreakStatement", {
      visitor: ["label"],
      fields: {
        label: { validate: (0, a.assertNodeType)("Identifier"), optional: !0 },
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    }),
    s("CallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments"],
      aliases: ["Expression"],
      fields: Object.assign(
        {
          callee: {
            validate: (0, a.assertNodeType)(
              "Expression",
              "Super",
              "V8IntrinsicIdentifier"
            ),
          },
          arguments: {
            validate: (0, a.chain)(
              (0, a.assertValueType)("array"),
              (0, a.assertEach)(
                (0, a.assertNodeType)(
                  "Expression",
                  "SpreadElement",
                  "JSXNamespacedName",
                  "ArgumentPlaceholder"
                )
              )
            ),
          },
        },
        process.env.BABEL_TYPES_8_BREAKING
          ? {}
          : {
              optional: { validate: (0, a.assertOneOf)(!0, !1), optional: !0 },
            },
        {
          typeArguments: {
            validate: (0, a.assertNodeType)("TypeParameterInstantiation"),
            optional: !0,
          },
          typeParameters: {
            validate: (0, a.assertNodeType)("TSTypeParameterInstantiation"),
            optional: !0,
          },
        }
      ),
    }),
    s("CatchClause", {
      visitor: ["param", "body"],
      fields: {
        param: {
          validate: (0, a.assertNodeType)(
            "Identifier",
            "ArrayPattern",
            "ObjectPattern"
          ),
          optional: !0,
        },
        body: { validate: (0, a.assertNodeType)("BlockStatement") },
      },
      aliases: ["Scopable", "BlockParent"],
    }),
    s("ConditionalExpression", {
      visitor: ["test", "consequent", "alternate"],
      fields: {
        test: { validate: (0, a.assertNodeType)("Expression") },
        consequent: { validate: (0, a.assertNodeType)("Expression") },
        alternate: { validate: (0, a.assertNodeType)("Expression") },
      },
      aliases: ["Expression", "Conditional"],
    }),
    s("ContinueStatement", {
      visitor: ["label"],
      fields: {
        label: { validate: (0, a.assertNodeType)("Identifier"), optional: !0 },
      },
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
    }),
    s("DebuggerStatement", { aliases: ["Statement"] }),
    s("DoWhileStatement", {
      visitor: ["test", "body"],
      fields: {
        test: { validate: (0, a.assertNodeType)("Expression") },
        body: { validate: (0, a.assertNodeType)("Statement") },
      },
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
    }),
    s("EmptyStatement", { aliases: ["Statement"] }),
    s("ExpressionStatement", {
      visitor: ["expression"],
      fields: { expression: { validate: (0, a.assertNodeType)("Expression") } },
      aliases: ["Statement", "ExpressionWrapper"],
    }),
    s("File", {
      builder: ["program", "comments", "tokens"],
      visitor: ["program"],
      fields: {
        program: { validate: (0, a.assertNodeType)("Program") },
        comments: {
          validate: process.env.BABEL_TYPES_8_BREAKING
            ? (0, a.assertEach)(
                (0, a.assertNodeType)("CommentBlock", "CommentLine")
              )
            : Object.assign(function () {}, {
                each: { oneOfNodeTypes: ["CommentBlock", "CommentLine"] },
              }),
          optional: !0,
        },
        tokens: {
          validate: (0, a.assertEach)(
            Object.assign(function () {}, { type: "any" })
          ),
          optional: !0,
        },
      },
    }),
    s("ForInStatement", {
      visitor: ["left", "right", "body"],
      aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement",
      ],
      fields: {
        left: {
          validate: process.env.BABEL_TYPES_8_BREAKING
            ? (0, a.assertNodeType)(
                "VariableDeclaration",
                "Identifier",
                "MemberExpression",
                "ArrayPattern",
                "ObjectPattern",
                "TSAsExpression",
                "TSSatisfiesExpression",
                "TSTypeAssertion",
                "TSNonNullExpression"
              )
            : (0, a.assertNodeType)("VariableDeclaration", "LVal"),
        },
        right: { validate: (0, a.assertNodeType)("Expression") },
        body: { validate: (0, a.assertNodeType)("Statement") },
      },
    }),
    s("ForStatement", {
      visitor: ["init", "test", "update", "body"],
      aliases: ["Scopable", "Statement", "For", "BlockParent", "Loop"],
      fields: {
        init: {
          validate: (0, a.assertNodeType)("VariableDeclaration", "Expression"),
          optional: !0,
        },
        test: { validate: (0, a.assertNodeType)("Expression"), optional: !0 },
        update: { validate: (0, a.assertNodeType)("Expression"), optional: !0 },
        body: { validate: (0, a.assertNodeType)("Statement") },
      },
    });
  var o = function () {
    return {
      params: {
        validate: (0, a.chain)(
          (0, a.assertValueType)("array"),
          (0, a.assertEach)(
            (0, a.assertNodeType)("Identifier", "Pattern", "RestElement")
          )
        ),
      },
      generator: { default: !1 },
      async: { default: !1 },
    };
  };
  Zi.functionCommon = o;
  var l = function () {
    return {
      returnType: {
        validate: (0, a.assertNodeType)(
          "TypeAnnotation",
          "TSTypeAnnotation",
          "Noop"
        ),
        optional: !0,
      },
      typeParameters: {
        validate: (0, a.assertNodeType)(
          "TypeParameterDeclaration",
          "TSTypeParameterDeclaration",
          "Noop"
        ),
        optional: !0,
      },
    };
  };
  Zi.functionTypeAnnotationCommon = l;
  var u = function () {
    return Object.assign({}, o(), {
      declare: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
      id: { validate: (0, a.assertNodeType)("Identifier"), optional: !0 },
    });
  };
  (Zi.functionDeclarationCommon = u),
    s("FunctionDeclaration", {
      builder: ["id", "params", "body", "generator", "async"],
      visitor: ["id", "params", "body", "returnType", "typeParameters"],
      fields: Object.assign({}, u(), l(), {
        body: { validate: (0, a.assertNodeType)("BlockStatement") },
        predicate: {
          validate: (0, a.assertNodeType)(
            "DeclaredPredicate",
            "InferredPredicate"
          ),
          optional: !0,
        },
      }),
      aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Statement",
        "Pureish",
        "Declaration",
      ],
      validate: (function () {
        if (!process.env.BABEL_TYPES_8_BREAKING) return function () {};
        var t = (0, a.assertNodeType)("Identifier");
        return function (r, n, i) {
          (0, e.default)("ExportDefaultDeclaration", r) || t(i, "id", i.id);
        };
      })(),
    }),
    s("FunctionExpression", {
      inherits: "FunctionDeclaration",
      aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish",
      ],
      fields: Object.assign({}, o(), l(), {
        id: { validate: (0, a.assertNodeType)("Identifier"), optional: !0 },
        body: { validate: (0, a.assertNodeType)("BlockStatement") },
        predicate: {
          validate: (0, a.assertNodeType)(
            "DeclaredPredicate",
            "InferredPredicate"
          ),
          optional: !0,
        },
      }),
    });
  var c,
    p,
    h,
    d,
    f,
    y = function () {
      return {
        typeAnnotation: {
          validate: (0, a.assertNodeType)(
            "TypeAnnotation",
            "TSTypeAnnotation",
            "Noop"
          ),
          optional: !0,
        },
        optional: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
        decorators: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
          ),
          optional: !0,
        },
      };
    };
  (Zi.patternLikeCommon = y),
    s("Identifier", {
      builder: ["name"],
      visitor: ["typeAnnotation", "decorators"],
      aliases: ["Expression", "PatternLike", "LVal", "TSEntityName"],
      fields: Object.assign({}, y(), {
        name: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("string"),
            Object.assign(
              function (e, r, n) {
                if (
                  process.env.BABEL_TYPES_8_BREAKING &&
                  !(0, t.default)(n, !1)
                )
                  throw new TypeError(
                    '"'.concat(n, '" is not a valid identifier name')
                  );
              },
              { type: "string" }
            )
          ),
        },
      }),
      validate: function (t, n, i) {
        if (process.env.BABEL_TYPES_8_BREAKING) {
          var a = /\.(\w+)$/.exec(n);
          if (a) {
            var s = H(a, 2)[1],
              o = { computed: !1 };
            if ("property" === s) {
              if ((0, e.default)("MemberExpression", t, o)) return;
              if ((0, e.default)("OptionalMemberExpression", t, o)) return;
            } else if ("key" === s) {
              if ((0, e.default)("Property", t, o)) return;
              if ((0, e.default)("Method", t, o)) return;
            } else if ("exported" === s) {
              if ((0, e.default)("ExportSpecifier", t)) return;
            } else if ("imported" === s) {
              if ((0, e.default)("ImportSpecifier", t, { imported: i })) return;
            } else if (
              "meta" === s &&
              (0, e.default)("MetaProperty", t, { meta: i })
            )
              return;
            if (
              ((0, r.isKeyword)(i.name) || (0, r.isReservedWord)(i.name, !1)) &&
              "this" !== i.name
            )
              throw new TypeError(
                '"'.concat(i.name, '" is not a valid identifier')
              );
          }
        }
      },
    }),
    s("IfStatement", {
      visitor: ["test", "consequent", "alternate"],
      aliases: ["Statement", "Conditional"],
      fields: {
        test: { validate: (0, a.assertNodeType)("Expression") },
        consequent: { validate: (0, a.assertNodeType)("Statement") },
        alternate: {
          optional: !0,
          validate: (0, a.assertNodeType)("Statement"),
        },
      },
    }),
    s("LabeledStatement", {
      visitor: ["label", "body"],
      aliases: ["Statement"],
      fields: {
        label: { validate: (0, a.assertNodeType)("Identifier") },
        body: { validate: (0, a.assertNodeType)("Statement") },
      },
    }),
    s("StringLiteral", {
      builder: ["value"],
      fields: { value: { validate: (0, a.assertValueType)("string") } },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"],
    }),
    s("NumericLiteral", {
      builder: ["value"],
      deprecatedAlias: "NumberLiteral",
      fields: { value: { validate: (0, a.assertValueType)("number") } },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"],
    }),
    s("NullLiteral", {
      aliases: ["Expression", "Pureish", "Literal", "Immutable"],
    }),
    s("BooleanLiteral", {
      builder: ["value"],
      fields: { value: { validate: (0, a.assertValueType)("boolean") } },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"],
    }),
    s("RegExpLiteral", {
      builder: ["pattern", "flags"],
      deprecatedAlias: "RegexLiteral",
      aliases: ["Expression", "Pureish", "Literal"],
      fields: {
        pattern: { validate: (0, a.assertValueType)("string") },
        flags: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("string"),
            Object.assign(
              function (e, t, r) {
                if (process.env.BABEL_TYPES_8_BREAKING) {
                  var n = /[^gimsuy]/.exec(r);
                  if (n)
                    throw new TypeError(
                      '"'.concat(n[0], '" is not a valid RegExp flag')
                    );
                }
              },
              { type: "string" }
            )
          ),
          default: "",
        },
      },
    }),
    s("LogicalExpression", {
      builder: ["operator", "left", "right"],
      visitor: ["left", "right"],
      aliases: ["Binary", "Expression"],
      fields: {
        operator: {
          validate: a.assertOneOf.apply(void 0, K(i.LOGICAL_OPERATORS)),
        },
        left: { validate: (0, a.assertNodeType)("Expression") },
        right: { validate: (0, a.assertNodeType)("Expression") },
      },
    }),
    s("MemberExpression", {
      builder: ["object", "property", "computed"].concat(
        K(process.env.BABEL_TYPES_8_BREAKING ? [] : ["optional"])
      ),
      visitor: ["object", "property"],
      aliases: ["Expression", "LVal"],
      fields: Object.assign(
        {
          object: { validate: (0, a.assertNodeType)("Expression", "Super") },
          property: {
            validate:
              ((c = (0, a.assertNodeType)("Identifier", "PrivateName")),
              (p = (0, a.assertNodeType)("Expression")),
              (h = function (e, t, r) {
                var n = e.computed ? p : c;
                n(e, t, r);
              }),
              (h.oneOfNodeTypes = ["Expression", "Identifier", "PrivateName"]),
              h),
          },
          computed: { default: !1 },
        },
        process.env.BABEL_TYPES_8_BREAKING
          ? {}
          : { optional: { validate: (0, a.assertOneOf)(!0, !1), optional: !0 } }
      ),
    }),
    s("NewExpression", { inherits: "CallExpression" }),
    s("Program", {
      visitor: ["directives", "body"],
      builder: ["body", "directives", "sourceType", "interpreter"],
      fields: {
        sourceFile: { validate: (0, a.assertValueType)("string") },
        sourceType: {
          validate: (0, a.assertOneOf)("script", "module"),
          default: "script",
        },
        interpreter: {
          validate: (0, a.assertNodeType)("InterpreterDirective"),
          default: null,
          optional: !0,
        },
        directives: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Directive"))
          ),
          default: [],
        },
        body: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Statement"))
          ),
        },
      },
      aliases: ["Scopable", "BlockParent", "Block"],
    }),
    s("ObjectExpression", {
      visitor: ["properties"],
      aliases: ["Expression"],
      fields: {
        properties: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)(
              (0, a.assertNodeType)(
                "ObjectMethod",
                "ObjectProperty",
                "SpreadElement"
              )
            )
          ),
        },
      },
    }),
    s("ObjectMethod", {
      builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "generator",
        "async",
      ],
      fields: Object.assign({}, o(), l(), {
        kind: Object.assign(
          { validate: (0, a.assertOneOf)("method", "get", "set") },
          process.env.BABEL_TYPES_8_BREAKING ? {} : { default: "method" }
        ),
        computed: { default: !1 },
        key: {
          validate: (function () {
            var e = (0, a.assertNodeType)(
                "Identifier",
                "StringLiteral",
                "NumericLiteral",
                "BigIntLiteral"
              ),
              t = (0, a.assertNodeType)("Expression"),
              r = function (r, n, i) {
                var a = r.computed ? t : e;
                a(r, n, i);
              };
            return (
              (r.oneOfNodeTypes = [
                "Expression",
                "Identifier",
                "StringLiteral",
                "NumericLiteral",
                "BigIntLiteral",
              ]),
              r
            );
          })(),
        },
        decorators: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
          ),
          optional: !0,
        },
        body: { validate: (0, a.assertNodeType)("BlockStatement") },
      }),
      visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters",
      ],
      aliases: [
        "UserWhitespacable",
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "ObjectMember",
      ],
    }),
    s("ObjectProperty", {
      builder: ["key", "value", "computed", "shorthand"].concat(
        K(process.env.BABEL_TYPES_8_BREAKING ? [] : ["decorators"])
      ),
      fields: {
        computed: { default: !1 },
        key: {
          validate: (function () {
            var e = (0, a.assertNodeType)(
                "Identifier",
                "StringLiteral",
                "NumericLiteral",
                "BigIntLiteral",
                "DecimalLiteral",
                "PrivateName"
              ),
              t = (0, a.assertNodeType)("Expression"),
              r = Object.assign(
                function (r, n, i) {
                  (r.computed ? t : e)(r, n, i);
                },
                {
                  oneOfNodeTypes: [
                    "Expression",
                    "Identifier",
                    "StringLiteral",
                    "NumericLiteral",
                    "BigIntLiteral",
                    "DecimalLiteral",
                    "PrivateName",
                  ],
                }
              );
            return r;
          })(),
        },
        value: { validate: (0, a.assertNodeType)("Expression", "PatternLike") },
        shorthand: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("boolean"),
            Object.assign(
              function (e, t, r) {
                if (process.env.BABEL_TYPES_8_BREAKING && r && e.computed)
                  throw new TypeError(
                    "Property shorthand of ObjectProperty cannot be true if computed is true"
                  );
              },
              { type: "boolean" }
            ),
            function (t, r, n) {
              if (
                process.env.BABEL_TYPES_8_BREAKING &&
                n &&
                !(0, e.default)("Identifier", t.key)
              )
                throw new TypeError(
                  "Property shorthand of ObjectProperty cannot be true if key is not an Identifier"
                );
            }
          ),
          default: !1,
        },
        decorators: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
          ),
          optional: !0,
        },
      },
      visitor: ["key", "value", "decorators"],
      aliases: ["UserWhitespacable", "Property", "ObjectMember"],
      validate: (function () {
        var t = (0, a.assertNodeType)(
            "Identifier",
            "Pattern",
            "TSAsExpression",
            "TSSatisfiesExpression",
            "TSNonNullExpression",
            "TSTypeAssertion"
          ),
          r = (0, a.assertNodeType)("Expression");
        return function (n, i, a) {
          process.env.BABEL_TYPES_8_BREAKING &&
            ((0, e.default)("ObjectPattern", n) ? t : r)(a, "value", a.value);
        };
      })(),
    }),
    s("RestElement", {
      visitor: ["argument", "typeAnnotation"],
      builder: ["argument"],
      aliases: ["LVal", "PatternLike"],
      deprecatedAlias: "RestProperty",
      fields: Object.assign({}, y(), {
        argument: {
          validate: process.env.BABEL_TYPES_8_BREAKING
            ? (0, a.assertNodeType)(
                "Identifier",
                "ArrayPattern",
                "ObjectPattern",
                "MemberExpression",
                "TSAsExpression",
                "TSSatisfiesExpression",
                "TSTypeAssertion",
                "TSNonNullExpression"
              )
            : (0, a.assertNodeType)("LVal"),
        },
      }),
      validate: function (e, t) {
        if (process.env.BABEL_TYPES_8_BREAKING) {
          var r = /(\w+)\[(\d+)\]/.exec(t);
          if (!r) throw new Error("Internal Babel error: malformed key.");
          var n = H(r, 3),
            i = n[1],
            a = n[2];
          if (e[i].length > +a + 1)
            throw new TypeError(
              "RestElement must be last element of ".concat(i)
            );
        }
      },
    }),
    s("ReturnStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: {
        argument: {
          validate: (0, a.assertNodeType)("Expression"),
          optional: !0,
        },
      },
    }),
    s("SequenceExpression", {
      visitor: ["expressions"],
      fields: {
        expressions: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Expression"))
          ),
        },
      },
      aliases: ["Expression"],
    }),
    s("ParenthesizedExpression", {
      visitor: ["expression"],
      aliases: ["Expression", "ExpressionWrapper"],
      fields: { expression: { validate: (0, a.assertNodeType)("Expression") } },
    }),
    s("SwitchCase", {
      visitor: ["test", "consequent"],
      fields: {
        test: { validate: (0, a.assertNodeType)("Expression"), optional: !0 },
        consequent: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Statement"))
          ),
        },
      },
    }),
    s("SwitchStatement", {
      visitor: ["discriminant", "cases"],
      aliases: ["Statement", "BlockParent", "Scopable"],
      fields: {
        discriminant: { validate: (0, a.assertNodeType)("Expression") },
        cases: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("SwitchCase"))
          ),
        },
      },
    }),
    s("ThisExpression", { aliases: ["Expression"] }),
    s("ThrowStatement", {
      visitor: ["argument"],
      aliases: ["Statement", "Terminatorless", "CompletionStatement"],
      fields: { argument: { validate: (0, a.assertNodeType)("Expression") } },
    }),
    s("TryStatement", {
      visitor: ["block", "handler", "finalizer"],
      aliases: ["Statement"],
      fields: {
        block: {
          validate: (0, a.chain)(
            (0, a.assertNodeType)("BlockStatement"),
            Object.assign(
              function (e) {
                if (
                  process.env.BABEL_TYPES_8_BREAKING &&
                  !e.handler &&
                  !e.finalizer
                )
                  throw new TypeError(
                    "TryStatement expects either a handler or finalizer, or both"
                  );
              },
              { oneOfNodeTypes: ["BlockStatement"] }
            )
          ),
        },
        handler: {
          optional: !0,
          validate: (0, a.assertNodeType)("CatchClause"),
        },
        finalizer: {
          optional: !0,
          validate: (0, a.assertNodeType)("BlockStatement"),
        },
      },
    }),
    s("UnaryExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: { default: !0 },
        argument: { validate: (0, a.assertNodeType)("Expression") },
        operator: {
          validate: a.assertOneOf.apply(void 0, K(i.UNARY_OPERATORS)),
        },
      },
      visitor: ["argument"],
      aliases: ["UnaryLike", "Expression"],
    }),
    s("UpdateExpression", {
      builder: ["operator", "argument", "prefix"],
      fields: {
        prefix: { default: !1 },
        argument: {
          validate: process.env.BABEL_TYPES_8_BREAKING
            ? (0, a.assertNodeType)("Identifier", "MemberExpression")
            : (0, a.assertNodeType)("Expression"),
        },
        operator: {
          validate: a.assertOneOf.apply(void 0, K(i.UPDATE_OPERATORS)),
        },
      },
      visitor: ["argument"],
      aliases: ["Expression"],
    }),
    s("VariableDeclaration", {
      builder: ["kind", "declarations"],
      visitor: ["declarations"],
      aliases: ["Statement", "Declaration"],
      fields: {
        declare: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
        kind: { validate: (0, a.assertOneOf)("var", "let", "const", "using") },
        declarations: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("VariableDeclarator"))
          ),
        },
      },
      validate: function (t, r, n) {
        if (
          process.env.BABEL_TYPES_8_BREAKING &&
          (0, e.default)("ForXStatement", t, { left: n }) &&
          1 !== n.declarations.length
        )
          throw new TypeError(
            "Exactly one VariableDeclarator is required in the VariableDeclaration of a ".concat(
              t.type
            )
          );
      },
    }),
    s("VariableDeclarator", {
      visitor: ["id", "init"],
      fields: {
        id: {
          validate: (function () {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return (0, a.assertNodeType)("LVal");
            var e = (0, a.assertNodeType)(
                "Identifier",
                "ArrayPattern",
                "ObjectPattern"
              ),
              t = (0, a.assertNodeType)("Identifier");
            return function (r, n, i) {
              (r.init ? e : t)(r, n, i);
            };
          })(),
        },
        definite: { optional: !0, validate: (0, a.assertValueType)("boolean") },
        init: { optional: !0, validate: (0, a.assertNodeType)("Expression") },
      },
    }),
    s("WhileStatement", {
      visitor: ["test", "body"],
      aliases: ["Statement", "BlockParent", "Loop", "While", "Scopable"],
      fields: {
        test: { validate: (0, a.assertNodeType)("Expression") },
        body: { validate: (0, a.assertNodeType)("Statement") },
      },
    }),
    s("WithStatement", {
      visitor: ["object", "body"],
      aliases: ["Statement"],
      fields: {
        object: { validate: (0, a.assertNodeType)("Expression") },
        body: { validate: (0, a.assertNodeType)("Statement") },
      },
    }),
    s("AssignmentPattern", {
      visitor: ["left", "right", "decorators"],
      builder: ["left", "right"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, y(), {
        left: {
          validate: (0, a.assertNodeType)(
            "Identifier",
            "ObjectPattern",
            "ArrayPattern",
            "MemberExpression",
            "TSAsExpression",
            "TSSatisfiesExpression",
            "TSTypeAssertion",
            "TSNonNullExpression"
          ),
        },
        right: { validate: (0, a.assertNodeType)("Expression") },
        decorators: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
          ),
          optional: !0,
        },
      }),
    }),
    s("ArrayPattern", {
      visitor: ["elements", "typeAnnotation"],
      builder: ["elements"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, y(), {
        elements: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)(
              (0, a.assertNodeOrValueType)("null", "PatternLike", "LVal")
            )
          ),
        },
      }),
    }),
    s("ArrowFunctionExpression", {
      builder: ["params", "body", "async"],
      visitor: ["params", "body", "returnType", "typeParameters"],
      aliases: [
        "Scopable",
        "Function",
        "BlockParent",
        "FunctionParent",
        "Expression",
        "Pureish",
      ],
      fields: Object.assign({}, o(), l(), {
        expression: { validate: (0, a.assertValueType)("boolean") },
        body: {
          validate: (0, a.assertNodeType)("BlockStatement", "Expression"),
        },
        predicate: {
          validate: (0, a.assertNodeType)(
            "DeclaredPredicate",
            "InferredPredicate"
          ),
          optional: !0,
        },
      }),
    }),
    s("ClassBody", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)(
              (0, a.assertNodeType)(
                "ClassMethod",
                "ClassPrivateMethod",
                "ClassProperty",
                "ClassPrivateProperty",
                "ClassAccessorProperty",
                "TSDeclareMethod",
                "TSIndexSignature",
                "StaticBlock"
              )
            )
          ),
        },
      },
    }),
    s("ClassExpression", {
      builder: ["id", "superClass", "body", "decorators"],
      visitor: [
        "id",
        "body",
        "superClass",
        "mixins",
        "typeParameters",
        "superTypeParameters",
        "implements",
        "decorators",
      ],
      aliases: ["Scopable", "Class", "Expression"],
      fields: {
        id: { validate: (0, a.assertNodeType)("Identifier"), optional: !0 },
        typeParameters: {
          validate: (0, a.assertNodeType)(
            "TypeParameterDeclaration",
            "TSTypeParameterDeclaration",
            "Noop"
          ),
          optional: !0,
        },
        body: { validate: (0, a.assertNodeType)("ClassBody") },
        superClass: {
          optional: !0,
          validate: (0, a.assertNodeType)("Expression"),
        },
        superTypeParameters: {
          validate: (0, a.assertNodeType)(
            "TypeParameterInstantiation",
            "TSTypeParameterInstantiation"
          ),
          optional: !0,
        },
        implements: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)(
              (0, a.assertNodeType)(
                "TSExpressionWithTypeArguments",
                "ClassImplements"
              )
            )
          ),
          optional: !0,
        },
        decorators: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
          ),
          optional: !0,
        },
        mixins: {
          validate: (0, a.assertNodeType)("InterfaceExtends"),
          optional: !0,
        },
      },
    }),
    s("ClassDeclaration", {
      inherits: "ClassExpression",
      aliases: ["Scopable", "Class", "Statement", "Declaration"],
      fields: {
        id: { validate: (0, a.assertNodeType)("Identifier") },
        typeParameters: {
          validate: (0, a.assertNodeType)(
            "TypeParameterDeclaration",
            "TSTypeParameterDeclaration",
            "Noop"
          ),
          optional: !0,
        },
        body: { validate: (0, a.assertNodeType)("ClassBody") },
        superClass: {
          optional: !0,
          validate: (0, a.assertNodeType)("Expression"),
        },
        superTypeParameters: {
          validate: (0, a.assertNodeType)(
            "TypeParameterInstantiation",
            "TSTypeParameterInstantiation"
          ),
          optional: !0,
        },
        implements: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)(
              (0, a.assertNodeType)(
                "TSExpressionWithTypeArguments",
                "ClassImplements"
              )
            )
          ),
          optional: !0,
        },
        decorators: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
          ),
          optional: !0,
        },
        mixins: {
          validate: (0, a.assertNodeType)("InterfaceExtends"),
          optional: !0,
        },
        declare: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
        abstract: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
      },
      validate: (function () {
        var t = (0, a.assertNodeType)("Identifier");
        return function (r, n, i) {
          process.env.BABEL_TYPES_8_BREAKING &&
            ((0, e.default)("ExportDefaultDeclaration", r) || t(i, "id", i.id));
        };
      })(),
    }),
    s("ExportAllDeclaration", {
      visitor: ["source"],
      aliases: [
        "Statement",
        "Declaration",
        "ImportOrExportDeclaration",
        "ExportDeclaration",
      ],
      fields: {
        source: { validate: (0, a.assertNodeType)("StringLiteral") },
        exportKind: (0, a.validateOptional)(
          (0, a.assertOneOf)("type", "value")
        ),
        assertions: {
          optional: !0,
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("ImportAttribute"))
          ),
        },
      },
    }),
    s("ExportDefaultDeclaration", {
      visitor: ["declaration"],
      aliases: [
        "Statement",
        "Declaration",
        "ImportOrExportDeclaration",
        "ExportDeclaration",
      ],
      fields: {
        declaration: {
          validate: (0, a.assertNodeType)(
            "TSDeclareFunction",
            "FunctionDeclaration",
            "ClassDeclaration",
            "Expression"
          ),
        },
        exportKind: (0, a.validateOptional)((0, a.assertOneOf)("value")),
      },
    }),
    s("ExportNamedDeclaration", {
      visitor: ["declaration", "specifiers", "source"],
      aliases: [
        "Statement",
        "Declaration",
        "ImportOrExportDeclaration",
        "ExportDeclaration",
      ],
      fields: {
        declaration: {
          optional: !0,
          validate: (0, a.chain)(
            (0, a.assertNodeType)("Declaration"),
            Object.assign(
              function (e, t, r) {
                if (
                  process.env.BABEL_TYPES_8_BREAKING &&
                  r &&
                  e.specifiers.length
                )
                  throw new TypeError(
                    "Only declaration or specifiers is allowed on ExportNamedDeclaration"
                  );
              },
              { oneOfNodeTypes: ["Declaration"] }
            ),
            function (e, t, r) {
              if (process.env.BABEL_TYPES_8_BREAKING && r && e.source)
                throw new TypeError(
                  "Cannot export a declaration from a source"
                );
            }
          ),
        },
        assertions: {
          optional: !0,
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("ImportAttribute"))
          ),
        },
        specifiers: {
          default: [],
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)(
              ((d = (0, a.assertNodeType)(
                "ExportSpecifier",
                "ExportDefaultSpecifier",
                "ExportNamespaceSpecifier"
              )),
              (f = (0, a.assertNodeType)("ExportSpecifier")),
              process.env.BABEL_TYPES_8_BREAKING
                ? function (e, t, r) {
                    (e.source ? d : f)(e, t, r);
                  }
                : d)
            )
          ),
        },
        source: {
          validate: (0, a.assertNodeType)("StringLiteral"),
          optional: !0,
        },
        exportKind: (0, a.validateOptional)(
          (0, a.assertOneOf)("type", "value")
        ),
      },
    }),
    s("ExportSpecifier", {
      visitor: ["local", "exported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: { validate: (0, a.assertNodeType)("Identifier") },
        exported: {
          validate: (0, a.assertNodeType)("Identifier", "StringLiteral"),
        },
        exportKind: {
          validate: (0, a.assertOneOf)("type", "value"),
          optional: !0,
        },
      },
    }),
    s("ForOfStatement", {
      visitor: ["left", "right", "body"],
      builder: ["left", "right", "body", "await"],
      aliases: [
        "Scopable",
        "Statement",
        "For",
        "BlockParent",
        "Loop",
        "ForXStatement",
      ],
      fields: {
        left: {
          validate: (function () {
            if (!process.env.BABEL_TYPES_8_BREAKING)
              return (0, a.assertNodeType)("VariableDeclaration", "LVal");
            var t = (0, a.assertNodeType)("VariableDeclaration"),
              r = (0, a.assertNodeType)(
                "Identifier",
                "MemberExpression",
                "ArrayPattern",
                "ObjectPattern",
                "TSAsExpression",
                "TSSatisfiesExpression",
                "TSTypeAssertion",
                "TSNonNullExpression"
              );
            return function (n, i, a) {
              (0, e.default)("VariableDeclaration", a)
                ? t(n, i, a)
                : r(n, i, a);
            };
          })(),
        },
        right: { validate: (0, a.assertNodeType)("Expression") },
        body: { validate: (0, a.assertNodeType)("Statement") },
        await: { default: !1 },
      },
    }),
    s("ImportDeclaration", {
      visitor: ["specifiers", "source"],
      aliases: ["Statement", "Declaration", "ImportOrExportDeclaration"],
      fields: {
        assertions: {
          optional: !0,
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("ImportAttribute"))
          ),
        },
        module: { optional: !0, validate: (0, a.assertValueType)("boolean") },
        specifiers: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)(
              (0, a.assertNodeType)(
                "ImportSpecifier",
                "ImportDefaultSpecifier",
                "ImportNamespaceSpecifier"
              )
            )
          ),
        },
        source: { validate: (0, a.assertNodeType)("StringLiteral") },
        importKind: {
          validate: (0, a.assertOneOf)("type", "typeof", "value"),
          optional: !0,
        },
      },
    }),
    s("ImportDefaultSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: { local: { validate: (0, a.assertNodeType)("Identifier") } },
    }),
    s("ImportNamespaceSpecifier", {
      visitor: ["local"],
      aliases: ["ModuleSpecifier"],
      fields: { local: { validate: (0, a.assertNodeType)("Identifier") } },
    }),
    s("ImportSpecifier", {
      visitor: ["local", "imported"],
      aliases: ["ModuleSpecifier"],
      fields: {
        local: { validate: (0, a.assertNodeType)("Identifier") },
        imported: {
          validate: (0, a.assertNodeType)("Identifier", "StringLiteral"),
        },
        importKind: {
          validate: (0, a.assertOneOf)("type", "typeof", "value"),
          optional: !0,
        },
      },
    }),
    s("MetaProperty", {
      visitor: ["meta", "property"],
      aliases: ["Expression"],
      fields: {
        meta: {
          validate: (0, a.chain)(
            (0, a.assertNodeType)("Identifier"),
            Object.assign(
              function (t, r, n) {
                if (process.env.BABEL_TYPES_8_BREAKING) {
                  var i;
                  switch (n.name) {
                    case "function":
                      i = "sent";
                      break;
                    case "new":
                      i = "target";
                      break;
                    case "import":
                      i = "meta";
                  }
                  if (!(0, e.default)("Identifier", t.property, { name: i }))
                    throw new TypeError("Unrecognised MetaProperty");
                }
              },
              { oneOfNodeTypes: ["Identifier"] }
            )
          ),
        },
        property: { validate: (0, a.assertNodeType)("Identifier") },
      },
    });
  var m = function () {
    return {
      abstract: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
      accessibility: {
        validate: (0, a.assertOneOf)("public", "private", "protected"),
        optional: !0,
      },
      static: { default: !1 },
      override: { default: !1 },
      computed: { default: !1 },
      optional: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
      key: {
        validate: (0, a.chain)(
          (function () {
            var e = (0, a.assertNodeType)(
                "Identifier",
                "StringLiteral",
                "NumericLiteral"
              ),
              t = (0, a.assertNodeType)("Expression");
            return function (r, n, i) {
              (r.computed ? t : e)(r, n, i);
            };
          })(),
          (0, a.assertNodeType)(
            "Identifier",
            "StringLiteral",
            "NumericLiteral",
            "BigIntLiteral",
            "Expression"
          )
        ),
      },
    };
  };
  Zi.classMethodOrPropertyCommon = m;
  var v = function () {
    return Object.assign({}, o(), m(), {
      params: {
        validate: (0, a.chain)(
          (0, a.assertValueType)("array"),
          (0, a.assertEach)(
            (0, a.assertNodeType)(
              "Identifier",
              "Pattern",
              "RestElement",
              "TSParameterProperty"
            )
          )
        ),
      },
      kind: {
        validate: (0, a.assertOneOf)("get", "set", "method", "constructor"),
        default: "method",
      },
      access: {
        validate: (0, a.chain)(
          (0, a.assertValueType)("string"),
          (0, a.assertOneOf)("public", "private", "protected")
        ),
        optional: !0,
      },
      decorators: {
        validate: (0, a.chain)(
          (0, a.assertValueType)("array"),
          (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
        ),
        optional: !0,
      },
    });
  };
  return (
    (Zi.classMethodOrDeclareMethodCommon = v),
    s("ClassMethod", {
      aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
      ],
      builder: [
        "kind",
        "key",
        "params",
        "body",
        "computed",
        "static",
        "generator",
        "async",
      ],
      visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters",
      ],
      fields: Object.assign({}, v(), l(), {
        body: { validate: (0, a.assertNodeType)("BlockStatement") },
      }),
    }),
    s("ObjectPattern", {
      visitor: ["properties", "typeAnnotation", "decorators"],
      builder: ["properties"],
      aliases: ["Pattern", "PatternLike", "LVal"],
      fields: Object.assign({}, y(), {
        properties: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)(
              (0, a.assertNodeType)("RestElement", "ObjectProperty")
            )
          ),
        },
      }),
    }),
    s("SpreadElement", {
      visitor: ["argument"],
      aliases: ["UnaryLike"],
      deprecatedAlias: "SpreadProperty",
      fields: { argument: { validate: (0, a.assertNodeType)("Expression") } },
    }),
    s("Super", { aliases: ["Expression"] }),
    s("TaggedTemplateExpression", {
      visitor: ["tag", "quasi", "typeParameters"],
      builder: ["tag", "quasi"],
      aliases: ["Expression"],
      fields: {
        tag: { validate: (0, a.assertNodeType)("Expression") },
        quasi: { validate: (0, a.assertNodeType)("TemplateLiteral") },
        typeParameters: {
          validate: (0, a.assertNodeType)(
            "TypeParameterInstantiation",
            "TSTypeParameterInstantiation"
          ),
          optional: !0,
        },
      },
    }),
    s("TemplateElement", {
      builder: ["value", "tail"],
      fields: {
        value: {
          validate: (0, a.chain)(
            (0, a.assertShape)({
              raw: { validate: (0, a.assertValueType)("string") },
              cooked: {
                validate: (0, a.assertValueType)("string"),
                optional: !0,
              },
            }),
            function (e) {
              var t = e.value.raw,
                r = !1,
                i = function () {
                  throw new Error("Internal @babel/types error.");
                },
                a = (0, n.readStringContents)("template", t, 0, 0, 0, {
                  unterminated: function () {
                    r = !0;
                  },
                  strictNumericEscape: i,
                  invalidEscapeSequence: i,
                  numericSeparatorInEscapeSequence: i,
                  unexpectedNumericSeparator: i,
                  invalidDigit: i,
                  invalidCodePoint: i,
                }),
                s = a.str,
                o = a.firstInvalidLoc;
              if (!r) throw new Error("Invalid raw");
              e.value.cooked = o ? null : s;
            }
          ),
        },
        tail: { default: !1 },
      },
    }),
    s("TemplateLiteral", {
      visitor: ["quasis", "expressions"],
      aliases: ["Expression", "Literal"],
      fields: {
        quasis: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("TemplateElement"))
          ),
        },
        expressions: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Expression", "TSType")),
            function (e, t, r) {
              if (e.quasis.length !== r.length + 1)
                throw new TypeError(
                  "Number of "
                    .concat(
                      e.type,
                      " quasis should be exactly one more than the number of expressions.\nExpected "
                    )
                    .concat(r.length + 1, " quasis but got ")
                    .concat(e.quasis.length)
                );
            }
          ),
        },
      },
    }),
    s("YieldExpression", {
      builder: ["argument", "delegate"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: {
        delegate: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("boolean"),
            Object.assign(
              function (e, t, r) {
                if (process.env.BABEL_TYPES_8_BREAKING && r && !e.argument)
                  throw new TypeError(
                    "Property delegate of YieldExpression cannot be true if there is no argument"
                  );
              },
              { type: "boolean" }
            )
          ),
          default: !1,
        },
        argument: {
          optional: !0,
          validate: (0, a.assertNodeType)("Expression"),
        },
      },
    }),
    s("AwaitExpression", {
      builder: ["argument"],
      visitor: ["argument"],
      aliases: ["Expression", "Terminatorless"],
      fields: { argument: { validate: (0, a.assertNodeType)("Expression") } },
    }),
    s("Import", { aliases: ["Expression"] }),
    s("BigIntLiteral", {
      builder: ["value"],
      fields: { value: { validate: (0, a.assertValueType)("string") } },
      aliases: ["Expression", "Pureish", "Literal", "Immutable"],
    }),
    s("ExportNamespaceSpecifier", {
      visitor: ["exported"],
      aliases: ["ModuleSpecifier"],
      fields: { exported: { validate: (0, a.assertNodeType)("Identifier") } },
    }),
    s("OptionalMemberExpression", {
      builder: ["object", "property", "computed", "optional"],
      visitor: ["object", "property"],
      aliases: ["Expression"],
      fields: {
        object: { validate: (0, a.assertNodeType)("Expression") },
        property: {
          validate: (function () {
            var e = (0, a.assertNodeType)("Identifier"),
              t = (0, a.assertNodeType)("Expression"),
              r = Object.assign(
                function (r, n, i) {
                  (r.computed ? t : e)(r, n, i);
                },
                { oneOfNodeTypes: ["Expression", "Identifier"] }
              );
            return r;
          })(),
        },
        computed: { default: !1 },
        optional: {
          validate: process.env.BABEL_TYPES_8_BREAKING
            ? (0, a.chain)(
                (0, a.assertValueType)("boolean"),
                (0, a.assertOptionalChainStart)()
              )
            : (0, a.assertValueType)("boolean"),
        },
      },
    }),
    s("OptionalCallExpression", {
      visitor: ["callee", "arguments", "typeParameters", "typeArguments"],
      builder: ["callee", "arguments", "optional"],
      aliases: ["Expression"],
      fields: {
        callee: { validate: (0, a.assertNodeType)("Expression") },
        arguments: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)(
              (0, a.assertNodeType)(
                "Expression",
                "SpreadElement",
                "JSXNamespacedName",
                "ArgumentPlaceholder"
              )
            )
          ),
        },
        optional: {
          validate: process.env.BABEL_TYPES_8_BREAKING
            ? (0, a.chain)(
                (0, a.assertValueType)("boolean"),
                (0, a.assertOptionalChainStart)()
              )
            : (0, a.assertValueType)("boolean"),
        },
        typeArguments: {
          validate: (0, a.assertNodeType)("TypeParameterInstantiation"),
          optional: !0,
        },
        typeParameters: {
          validate: (0, a.assertNodeType)("TSTypeParameterInstantiation"),
          optional: !0,
        },
      },
    }),
    s("ClassProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: [
        "key",
        "value",
        "typeAnnotation",
        "decorators",
        "computed",
        "static",
      ],
      aliases: ["Property"],
      fields: Object.assign({}, m(), {
        value: { validate: (0, a.assertNodeType)("Expression"), optional: !0 },
        definite: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
        typeAnnotation: {
          validate: (0, a.assertNodeType)(
            "TypeAnnotation",
            "TSTypeAnnotation",
            "Noop"
          ),
          optional: !0,
        },
        decorators: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
          ),
          optional: !0,
        },
        readonly: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
        declare: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
        variance: { validate: (0, a.assertNodeType)("Variance"), optional: !0 },
      }),
    }),
    s("ClassAccessorProperty", {
      visitor: ["key", "value", "typeAnnotation", "decorators"],
      builder: [
        "key",
        "value",
        "typeAnnotation",
        "decorators",
        "computed",
        "static",
      ],
      aliases: ["Property", "Accessor"],
      fields: Object.assign({}, m(), {
        key: {
          validate: (0, a.chain)(
            (function () {
              var e = (0, a.assertNodeType)(
                  "Identifier",
                  "StringLiteral",
                  "NumericLiteral",
                  "BigIntLiteral",
                  "PrivateName"
                ),
                t = (0, a.assertNodeType)("Expression");
              return function (r, n, i) {
                (r.computed ? t : e)(r, n, i);
              };
            })(),
            (0, a.assertNodeType)(
              "Identifier",
              "StringLiteral",
              "NumericLiteral",
              "BigIntLiteral",
              "Expression",
              "PrivateName"
            )
          ),
        },
        value: { validate: (0, a.assertNodeType)("Expression"), optional: !0 },
        definite: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
        typeAnnotation: {
          validate: (0, a.assertNodeType)(
            "TypeAnnotation",
            "TSTypeAnnotation",
            "Noop"
          ),
          optional: !0,
        },
        decorators: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
          ),
          optional: !0,
        },
        readonly: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
        declare: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
        variance: { validate: (0, a.assertNodeType)("Variance"), optional: !0 },
      }),
    }),
    s("ClassPrivateProperty", {
      visitor: ["key", "value", "decorators", "typeAnnotation"],
      builder: ["key", "value", "decorators", "static"],
      aliases: ["Property", "Private"],
      fields: {
        key: { validate: (0, a.assertNodeType)("PrivateName") },
        value: { validate: (0, a.assertNodeType)("Expression"), optional: !0 },
        typeAnnotation: {
          validate: (0, a.assertNodeType)(
            "TypeAnnotation",
            "TSTypeAnnotation",
            "Noop"
          ),
          optional: !0,
        },
        decorators: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Decorator"))
          ),
          optional: !0,
        },
        static: { validate: (0, a.assertValueType)("boolean"), default: !1 },
        readonly: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
        definite: { validate: (0, a.assertValueType)("boolean"), optional: !0 },
        variance: { validate: (0, a.assertNodeType)("Variance"), optional: !0 },
      },
    }),
    s("ClassPrivateMethod", {
      builder: ["kind", "key", "params", "body", "static"],
      visitor: [
        "key",
        "params",
        "body",
        "decorators",
        "returnType",
        "typeParameters",
      ],
      aliases: [
        "Function",
        "Scopable",
        "BlockParent",
        "FunctionParent",
        "Method",
        "Private",
      ],
      fields: Object.assign({}, v(), l(), {
        kind: {
          validate: (0, a.assertOneOf)("get", "set", "method"),
          default: "method",
        },
        key: { validate: (0, a.assertNodeType)("PrivateName") },
        body: { validate: (0, a.assertNodeType)("BlockStatement") },
      }),
    }),
    s("PrivateName", {
      visitor: ["id"],
      aliases: ["Private"],
      fields: { id: { validate: (0, a.assertNodeType)("Identifier") } },
    }),
    s("StaticBlock", {
      visitor: ["body"],
      fields: {
        body: {
          validate: (0, a.chain)(
            (0, a.assertValueType)("array"),
            (0, a.assertEach)((0, a.assertNodeType)("Statement"))
          ),
        },
      },
      aliases: ["Scopable", "BlockParent", "FunctionParent"],
    }),
    Zi
  );
}
var is,
  as = {};
var ss,
  os = {};
var ls,
  us,
  cs = {},
  ps = {};
function hs() {
  if (ls) return ps;
  (ls = 1),
    Object.defineProperty(ps, "__esModule", { value: !0 }),
    (ps.PLACEHOLDERS_FLIPPED_ALIAS =
      ps.PLACEHOLDERS_ALIAS =
      ps.PLACEHOLDERS =
        void 0);
  var e = rs(),
    t = [
      "Identifier",
      "StringLiteral",
      "Expression",
      "Statement",
      "Declaration",
      "BlockStatement",
      "ClassBody",
      "Pattern",
    ];
  ps.PLACEHOLDERS = t;
  var r = { Declaration: ["Statement"], Pattern: ["PatternLike", "LVal"] };
  ps.PLACEHOLDERS_ALIAS = r;
  for (var n = 0, i = t; n < i.length; n++) {
    var a = i[n],
      s = e.ALIAS_KEYS[a];
    null != s && s.length && (r[a] = s);
  }
  var o = {};
  return (
    (ps.PLACEHOLDERS_FLIPPED_ALIAS = o),
    Object.keys(r).forEach(function (e) {
      r[e].forEach(function (t) {
        Object.hasOwnProperty.call(o, t) || (o[t] = []), o[t].push(e);
      });
    }),
    ps
  );
}
var ds,
  fs = {};
var ys,
  ms = {};
var vs = {};
Object.defineProperty(vs, "__esModule", { value: !0 }),
  (vs.DEPRECATED_ALIASES = void 0);
var gs, bs, Ts, Ss, xs, Es;
function Ps() {
  return (
    gs ||
      ((gs = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          Object.defineProperty(e, "ALIAS_KEYS", {
            enumerable: !0,
            get: function () {
              return r.ALIAS_KEYS;
            },
          }),
          Object.defineProperty(e, "BUILDER_KEYS", {
            enumerable: !0,
            get: function () {
              return r.BUILDER_KEYS;
            },
          }),
          Object.defineProperty(e, "DEPRECATED_ALIASES", {
            enumerable: !0,
            get: function () {
              return i.DEPRECATED_ALIASES;
            },
          }),
          Object.defineProperty(e, "DEPRECATED_KEYS", {
            enumerable: !0,
            get: function () {
              return r.DEPRECATED_KEYS;
            },
          }),
          Object.defineProperty(e, "FLIPPED_ALIAS_KEYS", {
            enumerable: !0,
            get: function () {
              return r.FLIPPED_ALIAS_KEYS;
            },
          }),
          Object.defineProperty(e, "NODE_FIELDS", {
            enumerable: !0,
            get: function () {
              return r.NODE_FIELDS;
            },
          }),
          Object.defineProperty(e, "NODE_PARENT_VALIDATIONS", {
            enumerable: !0,
            get: function () {
              return r.NODE_PARENT_VALIDATIONS;
            },
          }),
          Object.defineProperty(e, "PLACEHOLDERS", {
            enumerable: !0,
            get: function () {
              return n.PLACEHOLDERS;
            },
          }),
          Object.defineProperty(e, "PLACEHOLDERS_ALIAS", {
            enumerable: !0,
            get: function () {
              return n.PLACEHOLDERS_ALIAS;
            },
          }),
          Object.defineProperty(e, "PLACEHOLDERS_FLIPPED_ALIAS", {
            enumerable: !0,
            get: function () {
              return n.PLACEHOLDERS_FLIPPED_ALIAS;
            },
          }),
          (e.TYPES = void 0),
          Object.defineProperty(e, "VISITOR_KEYS", {
            enumerable: !0,
            get: function () {
              return r.VISITOR_KEYS;
            },
          });
        var t = Qi;
        ns(),
          (function () {
            if (is) return as;
            is = 1;
            var e = rs(),
              t = (0, e.defineAliasedType)("Flow"),
              r = function (r) {
                var n = "DeclareClass" === r;
                t(r, {
                  builder: ["id", "typeParameters", "extends", "body"],
                  visitor: ["id", "typeParameters", "extends"].concat(
                    K(n ? ["mixins", "implements"] : []),
                    ["body"]
                  ),
                  aliases: ["FlowDeclaration", "Statement", "Declaration"],
                  fields: Object.assign(
                    {
                      id: (0, e.validateType)("Identifier"),
                      typeParameters: (0, e.validateOptionalType)(
                        "TypeParameterDeclaration"
                      ),
                      extends: (0, e.validateOptional)(
                        (0, e.arrayOfType)("InterfaceExtends")
                      ),
                    },
                    n
                      ? {
                          mixins: (0, e.validateOptional)(
                            (0, e.arrayOfType)("InterfaceExtends")
                          ),
                          implements: (0, e.validateOptional)(
                            (0, e.arrayOfType)("ClassImplements")
                          ),
                        }
                      : {},
                    { body: (0, e.validateType)("ObjectTypeAnnotation") }
                  ),
                });
              };
            t("AnyTypeAnnotation", {
              aliases: ["FlowType", "FlowBaseAnnotation"],
            }),
              t("ArrayTypeAnnotation", {
                visitor: ["elementType"],
                aliases: ["FlowType"],
                fields: { elementType: (0, e.validateType)("FlowType") },
              }),
              t("BooleanTypeAnnotation", {
                aliases: ["FlowType", "FlowBaseAnnotation"],
              }),
              t("BooleanLiteralTypeAnnotation", {
                builder: ["value"],
                aliases: ["FlowType"],
                fields: {
                  value: (0, e.validate)((0, e.assertValueType)("boolean")),
                },
              }),
              t("NullLiteralTypeAnnotation", {
                aliases: ["FlowType", "FlowBaseAnnotation"],
              }),
              t("ClassImplements", {
                visitor: ["id", "typeParameters"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  typeParameters: (0, e.validateOptionalType)(
                    "TypeParameterInstantiation"
                  ),
                },
              }),
              r("DeclareClass"),
              t("DeclareFunction", {
                visitor: ["id"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  predicate: (0, e.validateOptionalType)("DeclaredPredicate"),
                },
              }),
              r("DeclareInterface"),
              t("DeclareModule", {
                builder: ["id", "body", "kind"],
                visitor: ["id", "body"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: {
                  id: (0, e.validateType)(["Identifier", "StringLiteral"]),
                  body: (0, e.validateType)("BlockStatement"),
                  kind: (0, e.validateOptional)(
                    (0, e.assertOneOf)("CommonJS", "ES")
                  ),
                },
              }),
              t("DeclareModuleExports", {
                visitor: ["typeAnnotation"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: {
                  typeAnnotation: (0, e.validateType)("TypeAnnotation"),
                },
              }),
              t("DeclareTypeAlias", {
                visitor: ["id", "typeParameters", "right"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  typeParameters: (0, e.validateOptionalType)(
                    "TypeParameterDeclaration"
                  ),
                  right: (0, e.validateType)("FlowType"),
                },
              }),
              t("DeclareOpaqueType", {
                visitor: ["id", "typeParameters", "supertype"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  typeParameters: (0, e.validateOptionalType)(
                    "TypeParameterDeclaration"
                  ),
                  supertype: (0, e.validateOptionalType)("FlowType"),
                  impltype: (0, e.validateOptionalType)("FlowType"),
                },
              }),
              t("DeclareVariable", {
                visitor: ["id"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: { id: (0, e.validateType)("Identifier") },
              }),
              t("DeclareExportDeclaration", {
                visitor: ["declaration", "specifiers", "source"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: {
                  declaration: (0, e.validateOptionalType)("Flow"),
                  specifiers: (0, e.validateOptional)(
                    (0, e.arrayOfType)([
                      "ExportSpecifier",
                      "ExportNamespaceSpecifier",
                    ])
                  ),
                  source: (0, e.validateOptionalType)("StringLiteral"),
                  default: (0, e.validateOptional)(
                    (0, e.assertValueType)("boolean")
                  ),
                },
              }),
              t("DeclareExportAllDeclaration", {
                visitor: ["source"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: {
                  source: (0, e.validateType)("StringLiteral"),
                  exportKind: (0, e.validateOptional)(
                    (0, e.assertOneOf)("type", "value")
                  ),
                },
              }),
              t("DeclaredPredicate", {
                visitor: ["value"],
                aliases: ["FlowPredicate"],
                fields: { value: (0, e.validateType)("Flow") },
              }),
              t("ExistsTypeAnnotation", { aliases: ["FlowType"] }),
              t("FunctionTypeAnnotation", {
                visitor: ["typeParameters", "params", "rest", "returnType"],
                aliases: ["FlowType"],
                fields: {
                  typeParameters: (0, e.validateOptionalType)(
                    "TypeParameterDeclaration"
                  ),
                  params: (0, e.validate)(
                    (0, e.arrayOfType)("FunctionTypeParam")
                  ),
                  rest: (0, e.validateOptionalType)("FunctionTypeParam"),
                  this: (0, e.validateOptionalType)("FunctionTypeParam"),
                  returnType: (0, e.validateType)("FlowType"),
                },
              }),
              t("FunctionTypeParam", {
                visitor: ["name", "typeAnnotation"],
                fields: {
                  name: (0, e.validateOptionalType)("Identifier"),
                  typeAnnotation: (0, e.validateType)("FlowType"),
                  optional: (0, e.validateOptional)(
                    (0, e.assertValueType)("boolean")
                  ),
                },
              }),
              t("GenericTypeAnnotation", {
                visitor: ["id", "typeParameters"],
                aliases: ["FlowType"],
                fields: {
                  id: (0, e.validateType)([
                    "Identifier",
                    "QualifiedTypeIdentifier",
                  ]),
                  typeParameters: (0, e.validateOptionalType)(
                    "TypeParameterInstantiation"
                  ),
                },
              }),
              t("InferredPredicate", { aliases: ["FlowPredicate"] }),
              t("InterfaceExtends", {
                visitor: ["id", "typeParameters"],
                fields: {
                  id: (0, e.validateType)([
                    "Identifier",
                    "QualifiedTypeIdentifier",
                  ]),
                  typeParameters: (0, e.validateOptionalType)(
                    "TypeParameterInstantiation"
                  ),
                },
              }),
              r("InterfaceDeclaration"),
              t("InterfaceTypeAnnotation", {
                visitor: ["extends", "body"],
                aliases: ["FlowType"],
                fields: {
                  extends: (0, e.validateOptional)(
                    (0, e.arrayOfType)("InterfaceExtends")
                  ),
                  body: (0, e.validateType)("ObjectTypeAnnotation"),
                },
              }),
              t("IntersectionTypeAnnotation", {
                visitor: ["types"],
                aliases: ["FlowType"],
                fields: {
                  types: (0, e.validate)((0, e.arrayOfType)("FlowType")),
                },
              }),
              t("MixedTypeAnnotation", {
                aliases: ["FlowType", "FlowBaseAnnotation"],
              }),
              t("EmptyTypeAnnotation", {
                aliases: ["FlowType", "FlowBaseAnnotation"],
              }),
              t("NullableTypeAnnotation", {
                visitor: ["typeAnnotation"],
                aliases: ["FlowType"],
                fields: { typeAnnotation: (0, e.validateType)("FlowType") },
              }),
              t("NumberLiteralTypeAnnotation", {
                builder: ["value"],
                aliases: ["FlowType"],
                fields: {
                  value: (0, e.validate)((0, e.assertValueType)("number")),
                },
              }),
              t("NumberTypeAnnotation", {
                aliases: ["FlowType", "FlowBaseAnnotation"],
              }),
              t("ObjectTypeAnnotation", {
                visitor: [
                  "properties",
                  "indexers",
                  "callProperties",
                  "internalSlots",
                ],
                aliases: ["FlowType"],
                builder: [
                  "properties",
                  "indexers",
                  "callProperties",
                  "internalSlots",
                  "exact",
                ],
                fields: {
                  properties: (0, e.validate)(
                    (0, e.arrayOfType)([
                      "ObjectTypeProperty",
                      "ObjectTypeSpreadProperty",
                    ])
                  ),
                  indexers: {
                    validate: (0, e.arrayOfType)("ObjectTypeIndexer"),
                    optional: !0,
                    default: [],
                  },
                  callProperties: {
                    validate: (0, e.arrayOfType)("ObjectTypeCallProperty"),
                    optional: !0,
                    default: [],
                  },
                  internalSlots: {
                    validate: (0, e.arrayOfType)("ObjectTypeInternalSlot"),
                    optional: !0,
                    default: [],
                  },
                  exact: {
                    validate: (0, e.assertValueType)("boolean"),
                    default: !1,
                  },
                  inexact: (0, e.validateOptional)(
                    (0, e.assertValueType)("boolean")
                  ),
                },
              }),
              t("ObjectTypeInternalSlot", {
                visitor: ["id", "value", "optional", "static", "method"],
                aliases: ["UserWhitespacable"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  value: (0, e.validateType)("FlowType"),
                  optional: (0, e.validate)((0, e.assertValueType)("boolean")),
                  static: (0, e.validate)((0, e.assertValueType)("boolean")),
                  method: (0, e.validate)((0, e.assertValueType)("boolean")),
                },
              }),
              t("ObjectTypeCallProperty", {
                visitor: ["value"],
                aliases: ["UserWhitespacable"],
                fields: {
                  value: (0, e.validateType)("FlowType"),
                  static: (0, e.validate)((0, e.assertValueType)("boolean")),
                },
              }),
              t("ObjectTypeIndexer", {
                visitor: ["id", "key", "value", "variance"],
                aliases: ["UserWhitespacable"],
                fields: {
                  id: (0, e.validateOptionalType)("Identifier"),
                  key: (0, e.validateType)("FlowType"),
                  value: (0, e.validateType)("FlowType"),
                  static: (0, e.validate)((0, e.assertValueType)("boolean")),
                  variance: (0, e.validateOptionalType)("Variance"),
                },
              }),
              t("ObjectTypeProperty", {
                visitor: ["key", "value", "variance"],
                aliases: ["UserWhitespacable"],
                fields: {
                  key: (0, e.validateType)(["Identifier", "StringLiteral"]),
                  value: (0, e.validateType)("FlowType"),
                  kind: (0, e.validate)(
                    (0, e.assertOneOf)("init", "get", "set")
                  ),
                  static: (0, e.validate)((0, e.assertValueType)("boolean")),
                  proto: (0, e.validate)((0, e.assertValueType)("boolean")),
                  optional: (0, e.validate)((0, e.assertValueType)("boolean")),
                  variance: (0, e.validateOptionalType)("Variance"),
                  method: (0, e.validate)((0, e.assertValueType)("boolean")),
                },
              }),
              t("ObjectTypeSpreadProperty", {
                visitor: ["argument"],
                aliases: ["UserWhitespacable"],
                fields: { argument: (0, e.validateType)("FlowType") },
              }),
              t("OpaqueType", {
                visitor: ["id", "typeParameters", "supertype", "impltype"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  typeParameters: (0, e.validateOptionalType)(
                    "TypeParameterDeclaration"
                  ),
                  supertype: (0, e.validateOptionalType)("FlowType"),
                  impltype: (0, e.validateType)("FlowType"),
                },
              }),
              t("QualifiedTypeIdentifier", {
                visitor: ["id", "qualification"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  qualification: (0, e.validateType)([
                    "Identifier",
                    "QualifiedTypeIdentifier",
                  ]),
                },
              }),
              t("StringLiteralTypeAnnotation", {
                builder: ["value"],
                aliases: ["FlowType"],
                fields: {
                  value: (0, e.validate)((0, e.assertValueType)("string")),
                },
              }),
              t("StringTypeAnnotation", {
                aliases: ["FlowType", "FlowBaseAnnotation"],
              }),
              t("SymbolTypeAnnotation", {
                aliases: ["FlowType", "FlowBaseAnnotation"],
              }),
              t("ThisTypeAnnotation", {
                aliases: ["FlowType", "FlowBaseAnnotation"],
              }),
              t("TupleTypeAnnotation", {
                visitor: ["types"],
                aliases: ["FlowType"],
                fields: {
                  types: (0, e.validate)((0, e.arrayOfType)("FlowType")),
                },
              }),
              t("TypeofTypeAnnotation", {
                visitor: ["argument"],
                aliases: ["FlowType"],
                fields: { argument: (0, e.validateType)("FlowType") },
              }),
              t("TypeAlias", {
                visitor: ["id", "typeParameters", "right"],
                aliases: ["FlowDeclaration", "Statement", "Declaration"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  typeParameters: (0, e.validateOptionalType)(
                    "TypeParameterDeclaration"
                  ),
                  right: (0, e.validateType)("FlowType"),
                },
              }),
              t("TypeAnnotation", {
                visitor: ["typeAnnotation"],
                fields: { typeAnnotation: (0, e.validateType)("FlowType") },
              }),
              t("TypeCastExpression", {
                visitor: ["expression", "typeAnnotation"],
                aliases: ["ExpressionWrapper", "Expression"],
                fields: {
                  expression: (0, e.validateType)("Expression"),
                  typeAnnotation: (0, e.validateType)("TypeAnnotation"),
                },
              }),
              t("TypeParameter", {
                visitor: ["bound", "default", "variance"],
                fields: {
                  name: (0, e.validate)((0, e.assertValueType)("string")),
                  bound: (0, e.validateOptionalType)("TypeAnnotation"),
                  default: (0, e.validateOptionalType)("FlowType"),
                  variance: (0, e.validateOptionalType)("Variance"),
                },
              }),
              t("TypeParameterDeclaration", {
                visitor: ["params"],
                fields: {
                  params: (0, e.validate)((0, e.arrayOfType)("TypeParameter")),
                },
              }),
              t("TypeParameterInstantiation", {
                visitor: ["params"],
                fields: {
                  params: (0, e.validate)((0, e.arrayOfType)("FlowType")),
                },
              }),
              t("UnionTypeAnnotation", {
                visitor: ["types"],
                aliases: ["FlowType"],
                fields: {
                  types: (0, e.validate)((0, e.arrayOfType)("FlowType")),
                },
              }),
              t("Variance", {
                builder: ["kind"],
                fields: {
                  kind: (0, e.validate)((0, e.assertOneOf)("minus", "plus")),
                },
              }),
              t("VoidTypeAnnotation", {
                aliases: ["FlowType", "FlowBaseAnnotation"],
              }),
              t("EnumDeclaration", {
                aliases: ["Statement", "Declaration"],
                visitor: ["id", "body"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  body: (0, e.validateType)([
                    "EnumBooleanBody",
                    "EnumNumberBody",
                    "EnumStringBody",
                    "EnumSymbolBody",
                  ]),
                },
              }),
              t("EnumBooleanBody", {
                aliases: ["EnumBody"],
                visitor: ["members"],
                fields: {
                  explicitType: (0, e.validate)(
                    (0, e.assertValueType)("boolean")
                  ),
                  members: (0, e.validateArrayOfType)("EnumBooleanMember"),
                  hasUnknownMembers: (0, e.validate)(
                    (0, e.assertValueType)("boolean")
                  ),
                },
              }),
              t("EnumNumberBody", {
                aliases: ["EnumBody"],
                visitor: ["members"],
                fields: {
                  explicitType: (0, e.validate)(
                    (0, e.assertValueType)("boolean")
                  ),
                  members: (0, e.validateArrayOfType)("EnumNumberMember"),
                  hasUnknownMembers: (0, e.validate)(
                    (0, e.assertValueType)("boolean")
                  ),
                },
              }),
              t("EnumStringBody", {
                aliases: ["EnumBody"],
                visitor: ["members"],
                fields: {
                  explicitType: (0, e.validate)(
                    (0, e.assertValueType)("boolean")
                  ),
                  members: (0, e.validateArrayOfType)([
                    "EnumStringMember",
                    "EnumDefaultedMember",
                  ]),
                  hasUnknownMembers: (0, e.validate)(
                    (0, e.assertValueType)("boolean")
                  ),
                },
              }),
              t("EnumSymbolBody", {
                aliases: ["EnumBody"],
                visitor: ["members"],
                fields: {
                  members: (0, e.validateArrayOfType)("EnumDefaultedMember"),
                  hasUnknownMembers: (0, e.validate)(
                    (0, e.assertValueType)("boolean")
                  ),
                },
              }),
              t("EnumBooleanMember", {
                aliases: ["EnumMember"],
                visitor: ["id"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  init: (0, e.validateType)("BooleanLiteral"),
                },
              }),
              t("EnumNumberMember", {
                aliases: ["EnumMember"],
                visitor: ["id", "init"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  init: (0, e.validateType)("NumericLiteral"),
                },
              }),
              t("EnumStringMember", {
                aliases: ["EnumMember"],
                visitor: ["id", "init"],
                fields: {
                  id: (0, e.validateType)("Identifier"),
                  init: (0, e.validateType)("StringLiteral"),
                },
              }),
              t("EnumDefaultedMember", {
                aliases: ["EnumMember"],
                visitor: ["id"],
                fields: { id: (0, e.validateType)("Identifier") },
              }),
              t("IndexedAccessType", {
                visitor: ["objectType", "indexType"],
                aliases: ["FlowType"],
                fields: {
                  objectType: (0, e.validateType)("FlowType"),
                  indexType: (0, e.validateType)("FlowType"),
                },
              }),
              t("OptionalIndexedAccessType", {
                visitor: ["objectType", "indexType"],
                aliases: ["FlowType"],
                fields: {
                  objectType: (0, e.validateType)("FlowType"),
                  indexType: (0, e.validateType)("FlowType"),
                  optional: (0, e.validate)((0, e.assertValueType)("boolean")),
                },
              });
          })(),
          (function () {
            if (ss) return os;
            ss = 1;
            var e = rs(),
              t = (0, e.defineAliasedType)("JSX");
            t("JSXAttribute", {
              visitor: ["name", "value"],
              aliases: ["Immutable"],
              fields: {
                name: {
                  validate: (0, e.assertNodeType)(
                    "JSXIdentifier",
                    "JSXNamespacedName"
                  ),
                },
                value: {
                  optional: !0,
                  validate: (0, e.assertNodeType)(
                    "JSXElement",
                    "JSXFragment",
                    "StringLiteral",
                    "JSXExpressionContainer"
                  ),
                },
              },
            }),
              t("JSXClosingElement", {
                visitor: ["name"],
                aliases: ["Immutable"],
                fields: {
                  name: {
                    validate: (0, e.assertNodeType)(
                      "JSXIdentifier",
                      "JSXMemberExpression",
                      "JSXNamespacedName"
                    ),
                  },
                },
              }),
              t("JSXElement", {
                builder: [
                  "openingElement",
                  "closingElement",
                  "children",
                  "selfClosing",
                ],
                visitor: ["openingElement", "children", "closingElement"],
                aliases: ["Immutable", "Expression"],
                fields: Object.assign(
                  {
                    openingElement: {
                      validate: (0, e.assertNodeType)("JSXOpeningElement"),
                    },
                    closingElement: {
                      optional: !0,
                      validate: (0, e.assertNodeType)("JSXClosingElement"),
                    },
                    children: {
                      validate: (0, e.chain)(
                        (0, e.assertValueType)("array"),
                        (0, e.assertEach)(
                          (0, e.assertNodeType)(
                            "JSXText",
                            "JSXExpressionContainer",
                            "JSXSpreadChild",
                            "JSXElement",
                            "JSXFragment"
                          )
                        )
                      ),
                    },
                  },
                  {
                    selfClosing: {
                      validate: (0, e.assertValueType)("boolean"),
                      optional: !0,
                    },
                  }
                ),
              }),
              t("JSXEmptyExpression", {}),
              t("JSXExpressionContainer", {
                visitor: ["expression"],
                aliases: ["Immutable"],
                fields: {
                  expression: {
                    validate: (0, e.assertNodeType)(
                      "Expression",
                      "JSXEmptyExpression"
                    ),
                  },
                },
              }),
              t("JSXSpreadChild", {
                visitor: ["expression"],
                aliases: ["Immutable"],
                fields: {
                  expression: { validate: (0, e.assertNodeType)("Expression") },
                },
              }),
              t("JSXIdentifier", {
                builder: ["name"],
                fields: {
                  name: { validate: (0, e.assertValueType)("string") },
                },
              }),
              t("JSXMemberExpression", {
                visitor: ["object", "property"],
                fields: {
                  object: {
                    validate: (0, e.assertNodeType)(
                      "JSXMemberExpression",
                      "JSXIdentifier"
                    ),
                  },
                  property: {
                    validate: (0, e.assertNodeType)("JSXIdentifier"),
                  },
                },
              }),
              t("JSXNamespacedName", {
                visitor: ["namespace", "name"],
                fields: {
                  namespace: {
                    validate: (0, e.assertNodeType)("JSXIdentifier"),
                  },
                  name: { validate: (0, e.assertNodeType)("JSXIdentifier") },
                },
              }),
              t("JSXOpeningElement", {
                builder: ["name", "attributes", "selfClosing"],
                visitor: ["name", "attributes"],
                aliases: ["Immutable"],
                fields: {
                  name: {
                    validate: (0, e.assertNodeType)(
                      "JSXIdentifier",
                      "JSXMemberExpression",
                      "JSXNamespacedName"
                    ),
                  },
                  selfClosing: { default: !1 },
                  attributes: {
                    validate: (0, e.chain)(
                      (0, e.assertValueType)("array"),
                      (0, e.assertEach)(
                        (0, e.assertNodeType)(
                          "JSXAttribute",
                          "JSXSpreadAttribute"
                        )
                      )
                    ),
                  },
                  typeParameters: {
                    validate: (0, e.assertNodeType)(
                      "TypeParameterInstantiation",
                      "TSTypeParameterInstantiation"
                    ),
                    optional: !0,
                  },
                },
              }),
              t("JSXSpreadAttribute", {
                visitor: ["argument"],
                fields: {
                  argument: { validate: (0, e.assertNodeType)("Expression") },
                },
              }),
              t("JSXText", {
                aliases: ["Immutable"],
                builder: ["value"],
                fields: {
                  value: { validate: (0, e.assertValueType)("string") },
                },
              }),
              t("JSXFragment", {
                builder: ["openingFragment", "closingFragment", "children"],
                visitor: ["openingFragment", "children", "closingFragment"],
                aliases: ["Immutable", "Expression"],
                fields: {
                  openingFragment: {
                    validate: (0, e.assertNodeType)("JSXOpeningFragment"),
                  },
                  closingFragment: {
                    validate: (0, e.assertNodeType)("JSXClosingFragment"),
                  },
                  children: {
                    validate: (0, e.chain)(
                      (0, e.assertValueType)("array"),
                      (0, e.assertEach)(
                        (0, e.assertNodeType)(
                          "JSXText",
                          "JSXExpressionContainer",
                          "JSXSpreadChild",
                          "JSXElement",
                          "JSXFragment"
                        )
                      )
                    ),
                  },
                },
              }),
              t("JSXOpeningFragment", { aliases: ["Immutable"] }),
              t("JSXClosingFragment", { aliases: ["Immutable"] });
          })(),
          (function () {
            if (us) return cs;
            us = 1;
            var e = rs(),
              t = hs(),
              r = (0, e.defineAliasedType)("Miscellaneous");
            r("Noop", { visitor: [] }),
              r("Placeholder", {
                visitor: [],
                builder: ["expectedNode", "name"],
                fields: {
                  name: { validate: (0, e.assertNodeType)("Identifier") },
                  expectedNode: {
                    validate: e.assertOneOf.apply(void 0, K(t.PLACEHOLDERS)),
                  },
                },
              }),
              r("V8IntrinsicIdentifier", {
                builder: ["name"],
                fields: {
                  name: { validate: (0, e.assertValueType)("string") },
                },
              });
          })(),
          (function () {
            if (ds) return fs;
            ds = 1;
            var e = rs();
            (0, e.default)("ArgumentPlaceholder", {}),
              (0, e.default)("BindExpression", {
                visitor: ["object", "callee"],
                aliases: ["Expression"],
                fields: process.env.BABEL_TYPES_8_BREAKING
                  ? {
                      object: { validate: (0, e.assertNodeType)("Expression") },
                      callee: { validate: (0, e.assertNodeType)("Expression") },
                    }
                  : {
                      object: {
                        validate: Object.assign(function () {}, {
                          oneOfNodeTypes: ["Expression"],
                        }),
                      },
                      callee: {
                        validate: Object.assign(function () {}, {
                          oneOfNodeTypes: ["Expression"],
                        }),
                      },
                    },
              }),
              (0, e.default)("ImportAttribute", {
                visitor: ["key", "value"],
                fields: {
                  key: {
                    validate: (0, e.assertNodeType)(
                      "Identifier",
                      "StringLiteral"
                    ),
                  },
                  value: { validate: (0, e.assertNodeType)("StringLiteral") },
                },
              }),
              (0, e.default)("Decorator", {
                visitor: ["expression"],
                fields: {
                  expression: { validate: (0, e.assertNodeType)("Expression") },
                },
              }),
              (0, e.default)("DoExpression", {
                visitor: ["body"],
                builder: ["body", "async"],
                aliases: ["Expression"],
                fields: {
                  body: { validate: (0, e.assertNodeType)("BlockStatement") },
                  async: {
                    validate: (0, e.assertValueType)("boolean"),
                    default: !1,
                  },
                },
              }),
              (0, e.default)("ExportDefaultSpecifier", {
                visitor: ["exported"],
                aliases: ["ModuleSpecifier"],
                fields: {
                  exported: { validate: (0, e.assertNodeType)("Identifier") },
                },
              }),
              (0, e.default)("RecordExpression", {
                visitor: ["properties"],
                aliases: ["Expression"],
                fields: {
                  properties: {
                    validate: (0, e.chain)(
                      (0, e.assertValueType)("array"),
                      (0, e.assertEach)(
                        (0, e.assertNodeType)("ObjectProperty", "SpreadElement")
                      )
                    ),
                  },
                },
              }),
              (0, e.default)("TupleExpression", {
                fields: {
                  elements: {
                    validate: (0, e.chain)(
                      (0, e.assertValueType)("array"),
                      (0, e.assertEach)(
                        (0, e.assertNodeType)("Expression", "SpreadElement")
                      )
                    ),
                    default: [],
                  },
                },
                visitor: ["elements"],
                aliases: ["Expression"],
              }),
              (0, e.default)("DecimalLiteral", {
                builder: ["value"],
                fields: {
                  value: { validate: (0, e.assertValueType)("string") },
                },
                aliases: ["Expression", "Pureish", "Literal", "Immutable"],
              }),
              (0, e.default)("ModuleExpression", {
                visitor: ["body"],
                fields: {
                  body: { validate: (0, e.assertNodeType)("Program") },
                },
                aliases: ["Expression"],
              }),
              (0, e.default)("TopicReference", { aliases: ["Expression"] }),
              (0, e.default)("PipelineTopicExpression", {
                builder: ["expression"],
                visitor: ["expression"],
                fields: {
                  expression: { validate: (0, e.assertNodeType)("Expression") },
                },
                aliases: ["Expression"],
              }),
              (0, e.default)("PipelineBareFunction", {
                builder: ["callee"],
                visitor: ["callee"],
                fields: {
                  callee: { validate: (0, e.assertNodeType)("Expression") },
                },
                aliases: ["Expression"],
              }),
              (0, e.default)("PipelinePrimaryTopicReference", {
                aliases: ["Expression"],
              });
          })(),
          (function () {
            if (ys) return ms;
            ys = 1;
            var e = rs(),
              t = ns(),
              r = pa(),
              n = (0, e.defineAliasedType)("TypeScript"),
              i = (0, e.assertValueType)("boolean"),
              a = function () {
                return {
                  returnType: {
                    validate: (0, e.assertNodeType)("TSTypeAnnotation", "Noop"),
                    optional: !0,
                  },
                  typeParameters: {
                    validate: (0, e.assertNodeType)(
                      "TSTypeParameterDeclaration",
                      "Noop"
                    ),
                    optional: !0,
                  },
                };
              };
            n("TSParameterProperty", {
              aliases: ["LVal"],
              visitor: ["parameter"],
              fields: {
                accessibility: {
                  validate: (0, e.assertOneOf)(
                    "public",
                    "private",
                    "protected"
                  ),
                  optional: !0,
                },
                readonly: {
                  validate: (0, e.assertValueType)("boolean"),
                  optional: !0,
                },
                parameter: {
                  validate: (0, e.assertNodeType)(
                    "Identifier",
                    "AssignmentPattern"
                  ),
                },
                override: {
                  validate: (0, e.assertValueType)("boolean"),
                  optional: !0,
                },
                decorators: {
                  validate: (0, e.chain)(
                    (0, e.assertValueType)("array"),
                    (0, e.assertEach)((0, e.assertNodeType)("Decorator"))
                  ),
                  optional: !0,
                },
              },
            }),
              n("TSDeclareFunction", {
                aliases: ["Statement", "Declaration"],
                visitor: ["id", "typeParameters", "params", "returnType"],
                fields: Object.assign(
                  {},
                  (0, t.functionDeclarationCommon)(),
                  a()
                ),
              }),
              n("TSDeclareMethod", {
                visitor: [
                  "decorators",
                  "key",
                  "typeParameters",
                  "params",
                  "returnType",
                ],
                fields: Object.assign(
                  {},
                  (0, t.classMethodOrDeclareMethodCommon)(),
                  a()
                ),
              }),
              n("TSQualifiedName", {
                aliases: ["TSEntityName"],
                visitor: ["left", "right"],
                fields: {
                  left: (0, e.validateType)("TSEntityName"),
                  right: (0, e.validateType)("Identifier"),
                },
              });
            var s = function () {
                var t;
                return (
                  T(
                    (t = {
                      typeParameters: (0, e.validateOptionalType)(
                        "TSTypeParameterDeclaration"
                      ),
                    }),
                    "parameters",
                    (0, e.validateArrayOfType)(["Identifier", "RestElement"])
                  ),
                  T(
                    t,
                    "typeAnnotation",
                    (0, e.validateOptionalType)("TSTypeAnnotation")
                  ),
                  t
                );
              },
              o = {
                aliases: ["TSTypeElement"],
                visitor: ["typeParameters", "parameters", "typeAnnotation"],
                fields: s(),
              };
            n("TSCallSignatureDeclaration", o),
              n("TSConstructSignatureDeclaration", o);
            var l = function () {
              return {
                key: (0, e.validateType)("Expression"),
                computed: { default: !1 },
                optional: (0, e.validateOptional)(i),
              };
            };
            n("TSPropertySignature", {
              aliases: ["TSTypeElement"],
              visitor: ["key", "typeAnnotation", "initializer"],
              fields: Object.assign({}, l(), {
                readonly: (0, e.validateOptional)(i),
                typeAnnotation: (0, e.validateOptionalType)("TSTypeAnnotation"),
                initializer: (0, e.validateOptionalType)("Expression"),
                kind: { validate: (0, e.assertOneOf)("get", "set") },
              }),
            }),
              n("TSMethodSignature", {
                aliases: ["TSTypeElement"],
                visitor: [
                  "key",
                  "typeParameters",
                  "parameters",
                  "typeAnnotation",
                ],
                fields: Object.assign({}, s(), l(), {
                  kind: {
                    validate: (0, e.assertOneOf)("method", "get", "set"),
                  },
                }),
              }),
              n("TSIndexSignature", {
                aliases: ["TSTypeElement"],
                visitor: ["parameters", "typeAnnotation"],
                fields: {
                  readonly: (0, e.validateOptional)(i),
                  static: (0, e.validateOptional)(i),
                  parameters: (0, e.validateArrayOfType)("Identifier"),
                  typeAnnotation: (0, e.validateOptionalType)(
                    "TSTypeAnnotation"
                  ),
                },
              });
            for (
              var u = 0,
                c = [
                  "TSAnyKeyword",
                  "TSBooleanKeyword",
                  "TSBigIntKeyword",
                  "TSIntrinsicKeyword",
                  "TSNeverKeyword",
                  "TSNullKeyword",
                  "TSNumberKeyword",
                  "TSObjectKeyword",
                  "TSStringKeyword",
                  "TSSymbolKeyword",
                  "TSUndefinedKeyword",
                  "TSUnknownKeyword",
                  "TSVoidKeyword",
                ];
              u < c.length;
              u++
            )
              n(c[u], {
                aliases: ["TSType", "TSBaseType"],
                visitor: [],
                fields: {},
              });
            n("TSThisType", {
              aliases: ["TSType", "TSBaseType"],
              visitor: [],
              fields: {},
            });
            var p = {
              aliases: ["TSType"],
              visitor: ["typeParameters", "parameters", "typeAnnotation"],
            };
            n("TSFunctionType", Object.assign({}, p, { fields: s() })),
              n(
                "TSConstructorType",
                Object.assign({}, p, {
                  fields: Object.assign({}, s(), {
                    abstract: (0, e.validateOptional)(i),
                  }),
                })
              ),
              n("TSTypeReference", {
                aliases: ["TSType"],
                visitor: ["typeName", "typeParameters"],
                fields: {
                  typeName: (0, e.validateType)("TSEntityName"),
                  typeParameters: (0, e.validateOptionalType)(
                    "TSTypeParameterInstantiation"
                  ),
                },
              }),
              n("TSTypePredicate", {
                aliases: ["TSType"],
                visitor: ["parameterName", "typeAnnotation"],
                builder: ["parameterName", "typeAnnotation", "asserts"],
                fields: {
                  parameterName: (0, e.validateType)([
                    "Identifier",
                    "TSThisType",
                  ]),
                  typeAnnotation: (0, e.validateOptionalType)(
                    "TSTypeAnnotation"
                  ),
                  asserts: (0, e.validateOptional)(i),
                },
              }),
              n("TSTypeQuery", {
                aliases: ["TSType"],
                visitor: ["exprName", "typeParameters"],
                fields: {
                  exprName: (0, e.validateType)([
                    "TSEntityName",
                    "TSImportType",
                  ]),
                  typeParameters: (0, e.validateOptionalType)(
                    "TSTypeParameterInstantiation"
                  ),
                },
              }),
              n("TSTypeLiteral", {
                aliases: ["TSType"],
                visitor: ["members"],
                fields: {
                  members: (0, e.validateArrayOfType)("TSTypeElement"),
                },
              }),
              n("TSArrayType", {
                aliases: ["TSType"],
                visitor: ["elementType"],
                fields: { elementType: (0, e.validateType)("TSType") },
              }),
              n("TSTupleType", {
                aliases: ["TSType"],
                visitor: ["elementTypes"],
                fields: {
                  elementTypes: (0, e.validateArrayOfType)([
                    "TSType",
                    "TSNamedTupleMember",
                  ]),
                },
              }),
              n("TSOptionalType", {
                aliases: ["TSType"],
                visitor: ["typeAnnotation"],
                fields: { typeAnnotation: (0, e.validateType)("TSType") },
              }),
              n("TSRestType", {
                aliases: ["TSType"],
                visitor: ["typeAnnotation"],
                fields: { typeAnnotation: (0, e.validateType)("TSType") },
              }),
              n("TSNamedTupleMember", {
                visitor: ["label", "elementType"],
                builder: ["label", "elementType", "optional"],
                fields: {
                  label: (0, e.validateType)("Identifier"),
                  optional: { validate: i, default: !1 },
                  elementType: (0, e.validateType)("TSType"),
                },
              });
            var h = {
              aliases: ["TSType"],
              visitor: ["types"],
              fields: { types: (0, e.validateArrayOfType)("TSType") },
            };
            n("TSUnionType", h),
              n("TSIntersectionType", h),
              n("TSConditionalType", {
                aliases: ["TSType"],
                visitor: ["checkType", "extendsType", "trueType", "falseType"],
                fields: {
                  checkType: (0, e.validateType)("TSType"),
                  extendsType: (0, e.validateType)("TSType"),
                  trueType: (0, e.validateType)("TSType"),
                  falseType: (0, e.validateType)("TSType"),
                },
              }),
              n("TSInferType", {
                aliases: ["TSType"],
                visitor: ["typeParameter"],
                fields: {
                  typeParameter: (0, e.validateType)("TSTypeParameter"),
                },
              }),
              n("TSParenthesizedType", {
                aliases: ["TSType"],
                visitor: ["typeAnnotation"],
                fields: { typeAnnotation: (0, e.validateType)("TSType") },
              }),
              n("TSTypeOperator", {
                aliases: ["TSType"],
                visitor: ["typeAnnotation"],
                fields: {
                  operator: (0, e.validate)((0, e.assertValueType)("string")),
                  typeAnnotation: (0, e.validateType)("TSType"),
                },
              }),
              n("TSIndexedAccessType", {
                aliases: ["TSType"],
                visitor: ["objectType", "indexType"],
                fields: {
                  objectType: (0, e.validateType)("TSType"),
                  indexType: (0, e.validateType)("TSType"),
                },
              }),
              n("TSMappedType", {
                aliases: ["TSType"],
                visitor: ["typeParameter", "typeAnnotation", "nameType"],
                fields: {
                  readonly: (0, e.validateOptional)(
                    (0, e.assertOneOf)(!0, !1, "+", "-")
                  ),
                  typeParameter: (0, e.validateType)("TSTypeParameter"),
                  optional: (0, e.validateOptional)(
                    (0, e.assertOneOf)(!0, !1, "+", "-")
                  ),
                  typeAnnotation: (0, e.validateOptionalType)("TSType"),
                  nameType: (0, e.validateOptionalType)("TSType"),
                },
              }),
              n("TSLiteralType", {
                aliases: ["TSType", "TSBaseType"],
                visitor: ["literal"],
                fields: {
                  literal: {
                    validate: (function () {
                      var t = (0, e.assertNodeType)(
                          "NumericLiteral",
                          "BigIntLiteral"
                        ),
                        n = (0, e.assertOneOf)("-"),
                        i = (0, e.assertNodeType)(
                          "NumericLiteral",
                          "StringLiteral",
                          "BooleanLiteral",
                          "BigIntLiteral",
                          "TemplateLiteral"
                        );
                      function a(e, a, s) {
                        (0, r.default)("UnaryExpression", s)
                          ? (n(s, "operator", s.operator),
                            t(s, "argument", s.argument))
                          : i(e, a, s);
                      }
                      return (
                        (a.oneOfNodeTypes = [
                          "NumericLiteral",
                          "StringLiteral",
                          "BooleanLiteral",
                          "BigIntLiteral",
                          "TemplateLiteral",
                          "UnaryExpression",
                        ]),
                        a
                      );
                    })(),
                  },
                },
              }),
              n("TSExpressionWithTypeArguments", {
                aliases: ["TSType"],
                visitor: ["expression", "typeParameters"],
                fields: {
                  expression: (0, e.validateType)("TSEntityName"),
                  typeParameters: (0, e.validateOptionalType)(
                    "TSTypeParameterInstantiation"
                  ),
                },
              }),
              n("TSInterfaceDeclaration", {
                aliases: ["Statement", "Declaration"],
                visitor: ["id", "typeParameters", "extends", "body"],
                fields: {
                  declare: (0, e.validateOptional)(i),
                  id: (0, e.validateType)("Identifier"),
                  typeParameters: (0, e.validateOptionalType)(
                    "TSTypeParameterDeclaration"
                  ),
                  extends: (0, e.validateOptional)(
                    (0, e.arrayOfType)("TSExpressionWithTypeArguments")
                  ),
                  body: (0, e.validateType)("TSInterfaceBody"),
                },
              }),
              n("TSInterfaceBody", {
                visitor: ["body"],
                fields: { body: (0, e.validateArrayOfType)("TSTypeElement") },
              }),
              n("TSTypeAliasDeclaration", {
                aliases: ["Statement", "Declaration"],
                visitor: ["id", "typeParameters", "typeAnnotation"],
                fields: {
                  declare: (0, e.validateOptional)(i),
                  id: (0, e.validateType)("Identifier"),
                  typeParameters: (0, e.validateOptionalType)(
                    "TSTypeParameterDeclaration"
                  ),
                  typeAnnotation: (0, e.validateType)("TSType"),
                },
              }),
              n("TSInstantiationExpression", {
                aliases: ["Expression"],
                visitor: ["expression", "typeParameters"],
                fields: {
                  expression: (0, e.validateType)("Expression"),
                  typeParameters: (0, e.validateOptionalType)(
                    "TSTypeParameterInstantiation"
                  ),
                },
              });
            var d = {
              aliases: ["Expression", "LVal", "PatternLike"],
              visitor: ["expression", "typeAnnotation"],
              fields: {
                expression: (0, e.validateType)("Expression"),
                typeAnnotation: (0, e.validateType)("TSType"),
              },
            };
            n("TSAsExpression", d),
              n("TSSatisfiesExpression", d),
              n("TSTypeAssertion", {
                aliases: ["Expression", "LVal", "PatternLike"],
                visitor: ["typeAnnotation", "expression"],
                fields: {
                  typeAnnotation: (0, e.validateType)("TSType"),
                  expression: (0, e.validateType)("Expression"),
                },
              }),
              n("TSEnumDeclaration", {
                aliases: ["Statement", "Declaration"],
                visitor: ["id", "members"],
                fields: {
                  declare: (0, e.validateOptional)(i),
                  const: (0, e.validateOptional)(i),
                  id: (0, e.validateType)("Identifier"),
                  members: (0, e.validateArrayOfType)("TSEnumMember"),
                  initializer: (0, e.validateOptionalType)("Expression"),
                },
              }),
              n("TSEnumMember", {
                visitor: ["id", "initializer"],
                fields: {
                  id: (0, e.validateType)(["Identifier", "StringLiteral"]),
                  initializer: (0, e.validateOptionalType)("Expression"),
                },
              }),
              n("TSModuleDeclaration", {
                aliases: ["Statement", "Declaration"],
                visitor: ["id", "body"],
                fields: {
                  declare: (0, e.validateOptional)(i),
                  global: (0, e.validateOptional)(i),
                  id: (0, e.validateType)(["Identifier", "StringLiteral"]),
                  body: (0, e.validateType)([
                    "TSModuleBlock",
                    "TSModuleDeclaration",
                  ]),
                },
              }),
              n("TSModuleBlock", {
                aliases: ["Scopable", "Block", "BlockParent", "FunctionParent"],
                visitor: ["body"],
                fields: { body: (0, e.validateArrayOfType)("Statement") },
              }),
              n("TSImportType", {
                aliases: ["TSType"],
                visitor: ["argument", "qualifier", "typeParameters"],
                fields: {
                  argument: (0, e.validateType)("StringLiteral"),
                  qualifier: (0, e.validateOptionalType)("TSEntityName"),
                  typeParameters: (0, e.validateOptionalType)(
                    "TSTypeParameterInstantiation"
                  ),
                },
              }),
              n("TSImportEqualsDeclaration", {
                aliases: ["Statement"],
                visitor: ["id", "moduleReference"],
                fields: {
                  isExport: (0, e.validate)(i),
                  id: (0, e.validateType)("Identifier"),
                  moduleReference: (0, e.validateType)([
                    "TSEntityName",
                    "TSExternalModuleReference",
                  ]),
                  importKind: {
                    validate: (0, e.assertOneOf)("type", "value"),
                    optional: !0,
                  },
                },
              }),
              n("TSExternalModuleReference", {
                visitor: ["expression"],
                fields: { expression: (0, e.validateType)("StringLiteral") },
              }),
              n("TSNonNullExpression", {
                aliases: ["Expression", "LVal", "PatternLike"],
                visitor: ["expression"],
                fields: { expression: (0, e.validateType)("Expression") },
              }),
              n("TSExportAssignment", {
                aliases: ["Statement"],
                visitor: ["expression"],
                fields: { expression: (0, e.validateType)("Expression") },
              }),
              n("TSNamespaceExportDeclaration", {
                aliases: ["Statement"],
                visitor: ["id"],
                fields: { id: (0, e.validateType)("Identifier") },
              }),
              n("TSTypeAnnotation", {
                visitor: ["typeAnnotation"],
                fields: {
                  typeAnnotation: { validate: (0, e.assertNodeType)("TSType") },
                },
              }),
              n("TSTypeParameterInstantiation", {
                visitor: ["params"],
                fields: {
                  params: {
                    validate: (0, e.chain)(
                      (0, e.assertValueType)("array"),
                      (0, e.assertEach)((0, e.assertNodeType)("TSType"))
                    ),
                  },
                },
              }),
              n("TSTypeParameterDeclaration", {
                visitor: ["params"],
                fields: {
                  params: {
                    validate: (0, e.chain)(
                      (0, e.assertValueType)("array"),
                      (0, e.assertEach)(
                        (0, e.assertNodeType)("TSTypeParameter")
                      )
                    ),
                  },
                },
              }),
              n("TSTypeParameter", {
                builder: ["constraint", "default", "name"],
                visitor: ["constraint", "default"],
                fields: {
                  name: { validate: (0, e.assertValueType)("string") },
                  in: {
                    validate: (0, e.assertValueType)("boolean"),
                    optional: !0,
                  },
                  out: {
                    validate: (0, e.assertValueType)("boolean"),
                    optional: !0,
                  },
                  const: {
                    validate: (0, e.assertValueType)("boolean"),
                    optional: !0,
                  },
                  constraint: {
                    validate: (0, e.assertNodeType)("TSType"),
                    optional: !0,
                  },
                  default: {
                    validate: (0, e.assertNodeType)("TSType"),
                    optional: !0,
                  },
                },
              });
          })();
        var r = rs(),
          n = hs(),
          i = vs;
        Object.keys(i.DEPRECATED_ALIASES).forEach(function (e) {
          r.FLIPPED_ALIAS_KEYS[e] =
            r.FLIPPED_ALIAS_KEYS[i.DEPRECATED_ALIASES[e]];
        }),
          t(r.VISITOR_KEYS),
          t(r.ALIAS_KEYS),
          t(r.FLIPPED_ALIAS_KEYS),
          t(r.NODE_FIELDS),
          t(r.BUILDER_KEYS),
          t(r.DEPRECATED_KEYS),
          t(n.PLACEHOLDERS_ALIAS),
          t(n.PLACEHOLDERS_FLIPPED_ALIAS);
        var a = [].concat(
          Object.keys(r.VISITOR_KEYS),
          Object.keys(r.FLIPPED_ALIAS_KEYS),
          Object.keys(r.DEPRECATED_KEYS)
        );
        e.TYPES = a;
      })(Xi)),
    Xi
  );
}
function As() {
  if (bs) return Ji;
  (bs = 1),
    Object.defineProperty(Ji, "__esModule", { value: !0 }),
    (Ji.default = function (n, i, a) {
      if (!n) return;
      var s = e.NODE_FIELDS[n.type];
      if (!s) return;
      var o = s[i];
      t(n, i, a, o), r(n, i, a);
    }),
    (Ji.validateChild = r),
    (Ji.validateField = t);
  var e = Ps();
  function t(e, t, r, n) {
    null != n &&
      n.validate &&
      ((n.optional && null == r) || n.validate(e, t, r));
  }
  function r(t, r, n) {
    if (null != n) {
      var i = e.NODE_PARENT_VALIDATIONS[n.type];
      i && i(t, r, n);
    }
  }
  return Ji;
}
function ks(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return ws(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return ws(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function ws(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Cs() {
  if (Ss) return Hi;
  (Ss = 1),
    Object.defineProperty(Hi, "__esModule", { value: !0 }),
    (Hi.anyTypeAnnotation = function () {
      return { type: "AnyTypeAnnotation" };
    }),
    (Hi.argumentPlaceholder = function () {
      return { type: "ArgumentPlaceholder" };
    }),
    (Hi.arrayExpression = function () {
      var t =
        arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      return (0, e.default)({ type: "ArrayExpression", elements: t });
    }),
    (Hi.arrayPattern = function (t) {
      return (0, e.default)({ type: "ArrayPattern", elements: t });
    }),
    (Hi.arrayTypeAnnotation = function (t) {
      return (0, e.default)({ type: "ArrayTypeAnnotation", elementType: t });
    }),
    (Hi.arrowFunctionExpression = function (t, r) {
      var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      return (0, e.default)({
        type: "ArrowFunctionExpression",
        params: t,
        body: r,
        async: n,
        expression: null,
      });
    }),
    (Hi.assignmentExpression = function (t, r, n) {
      return (0, e.default)({
        type: "AssignmentExpression",
        operator: t,
        left: r,
        right: n,
      });
    }),
    (Hi.assignmentPattern = function (t, r) {
      return (0, e.default)({ type: "AssignmentPattern", left: t, right: r });
    }),
    (Hi.awaitExpression = function (t) {
      return (0, e.default)({ type: "AwaitExpression", argument: t });
    }),
    (Hi.bigIntLiteral = function (t) {
      return (0, e.default)({ type: "BigIntLiteral", value: t });
    }),
    (Hi.binaryExpression = function (t, r, n) {
      return (0, e.default)({
        type: "BinaryExpression",
        operator: t,
        left: r,
        right: n,
      });
    }),
    (Hi.bindExpression = function (t, r) {
      return (0, e.default)({ type: "BindExpression", object: t, callee: r });
    }),
    (Hi.blockStatement = function (t) {
      var r =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [];
      return (0, e.default)({ type: "BlockStatement", body: t, directives: r });
    }),
    (Hi.booleanLiteral = function (t) {
      return (0, e.default)({ type: "BooleanLiteral", value: t });
    }),
    (Hi.booleanLiteralTypeAnnotation = function (t) {
      return (0, e.default)({ type: "BooleanLiteralTypeAnnotation", value: t });
    }),
    (Hi.booleanTypeAnnotation = function () {
      return { type: "BooleanTypeAnnotation" };
    }),
    (Hi.breakStatement = function () {
      var t =
        arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
      return (0, e.default)({ type: "BreakStatement", label: t });
    }),
    (Hi.callExpression = function (t, r) {
      return (0, e.default)({
        type: "CallExpression",
        callee: t,
        arguments: r,
      });
    }),
    (Hi.catchClause = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r = arguments.length > 1 ? arguments[1] : void 0;
      return (0, e.default)({ type: "CatchClause", param: t, body: r });
    }),
    (Hi.classAccessorProperty = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
        i =
          arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
        a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
        s = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
      return (0, e.default)({
        type: "ClassAccessorProperty",
        key: t,
        value: r,
        typeAnnotation: n,
        decorators: i,
        computed: a,
        static: s,
      });
    }),
    (Hi.classBody = function (t) {
      return (0, e.default)({ type: "ClassBody", body: t });
    }),
    (Hi.classDeclaration = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n = arguments.length > 2 ? arguments[2] : void 0,
        i =
          arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
      return (0, e.default)({
        type: "ClassDeclaration",
        id: t,
        superClass: r,
        body: n,
        decorators: i,
      });
    }),
    (Hi.classExpression = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n = arguments.length > 2 ? arguments[2] : void 0,
        i =
          arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
      return (0, e.default)({
        type: "ClassExpression",
        id: t,
        superClass: r,
        body: n,
        decorators: i,
      });
    }),
    (Hi.classImplements = function (t) {
      var r =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      return (0, e.default)({
        type: "ClassImplements",
        id: t,
        typeParameters: r,
      });
    }),
    (Hi.classMethod = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0]
            ? arguments[0]
            : "method",
        r = arguments.length > 1 ? arguments[1] : void 0,
        n = arguments.length > 2 ? arguments[2] : void 0,
        i = arguments.length > 3 ? arguments[3] : void 0,
        a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
        s = arguments.length > 5 && void 0 !== arguments[5] && arguments[5],
        o = arguments.length > 6 && void 0 !== arguments[6] && arguments[6],
        l = arguments.length > 7 && void 0 !== arguments[7] && arguments[7];
      return (0, e.default)({
        type: "ClassMethod",
        kind: t,
        key: r,
        params: n,
        body: i,
        computed: a,
        static: s,
        generator: o,
        async: l,
      });
    }),
    (Hi.classPrivateMethod = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0]
            ? arguments[0]
            : "method",
        r = arguments.length > 1 ? arguments[1] : void 0,
        n = arguments.length > 2 ? arguments[2] : void 0,
        i = arguments.length > 3 ? arguments[3] : void 0,
        a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
      return (0, e.default)({
        type: "ClassPrivateMethod",
        kind: t,
        key: r,
        params: n,
        body: i,
        static: a,
      });
    }),
    (Hi.classPrivateProperty = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
        i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
      return (0, e.default)({
        type: "ClassPrivateProperty",
        key: t,
        value: r,
        decorators: n,
        static: i,
      });
    }),
    (Hi.classProperty = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
        i =
          arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null,
        a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
        s = arguments.length > 5 && void 0 !== arguments[5] && arguments[5];
      return (0, e.default)({
        type: "ClassProperty",
        key: t,
        value: r,
        typeAnnotation: n,
        decorators: i,
        computed: a,
        static: s,
      });
    }),
    (Hi.conditionalExpression = function (t, r, n) {
      return (0, e.default)({
        type: "ConditionalExpression",
        test: t,
        consequent: r,
        alternate: n,
      });
    }),
    (Hi.continueStatement = function () {
      var t =
        arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
      return (0, e.default)({ type: "ContinueStatement", label: t });
    }),
    (Hi.debuggerStatement = function () {
      return { type: "DebuggerStatement" };
    }),
    (Hi.decimalLiteral = function (t) {
      return (0, e.default)({ type: "DecimalLiteral", value: t });
    }),
    (Hi.declareClass = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
        i = arguments.length > 3 ? arguments[3] : void 0;
      return (0, e.default)({
        type: "DeclareClass",
        id: t,
        typeParameters: r,
        extends: n,
        body: i,
      });
    }),
    (Hi.declareExportAllDeclaration = function (t) {
      return (0, e.default)({ type: "DeclareExportAllDeclaration", source: t });
    }),
    (Hi.declareExportDeclaration = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
      return (0, e.default)({
        type: "DeclareExportDeclaration",
        declaration: t,
        specifiers: r,
        source: n,
      });
    }),
    (Hi.declareFunction = function (t) {
      return (0, e.default)({ type: "DeclareFunction", id: t });
    }),
    (Hi.declareInterface = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
        i = arguments.length > 3 ? arguments[3] : void 0;
      return (0, e.default)({
        type: "DeclareInterface",
        id: t,
        typeParameters: r,
        extends: n,
        body: i,
      });
    }),
    (Hi.declareModule = function (t, r) {
      var n =
        arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
      return (0, e.default)({ type: "DeclareModule", id: t, body: r, kind: n });
    }),
    (Hi.declareModuleExports = function (t) {
      return (0, e.default)({
        type: "DeclareModuleExports",
        typeAnnotation: t,
      });
    }),
    (Hi.declareOpaqueType = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
      return (0, e.default)({
        type: "DeclareOpaqueType",
        id: t,
        typeParameters: r,
        supertype: n,
      });
    }),
    (Hi.declareTypeAlias = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n = arguments.length > 2 ? arguments[2] : void 0;
      return (0, e.default)({
        type: "DeclareTypeAlias",
        id: t,
        typeParameters: r,
        right: n,
      });
    }),
    (Hi.declareVariable = function (t) {
      return (0, e.default)({ type: "DeclareVariable", id: t });
    }),
    (Hi.declaredPredicate = function (t) {
      return (0, e.default)({ type: "DeclaredPredicate", value: t });
    }),
    (Hi.decorator = function (t) {
      return (0, e.default)({ type: "Decorator", expression: t });
    }),
    (Hi.directive = function (t) {
      return (0, e.default)({ type: "Directive", value: t });
    }),
    (Hi.directiveLiteral = function (t) {
      return (0, e.default)({ type: "DirectiveLiteral", value: t });
    }),
    (Hi.doExpression = function (t) {
      var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      return (0, e.default)({ type: "DoExpression", body: t, async: r });
    }),
    (Hi.doWhileStatement = function (t, r) {
      return (0, e.default)({ type: "DoWhileStatement", test: t, body: r });
    }),
    (Hi.emptyStatement = function () {
      return { type: "EmptyStatement" };
    }),
    (Hi.emptyTypeAnnotation = function () {
      return { type: "EmptyTypeAnnotation" };
    }),
    (Hi.enumBooleanBody = function (t) {
      return (0, e.default)({
        type: "EnumBooleanBody",
        members: t,
        explicitType: null,
        hasUnknownMembers: null,
      });
    }),
    (Hi.enumBooleanMember = function (t) {
      return (0, e.default)({ type: "EnumBooleanMember", id: t, init: null });
    }),
    (Hi.enumDeclaration = function (t, r) {
      return (0, e.default)({ type: "EnumDeclaration", id: t, body: r });
    }),
    (Hi.enumDefaultedMember = function (t) {
      return (0, e.default)({ type: "EnumDefaultedMember", id: t });
    }),
    (Hi.enumNumberBody = function (t) {
      return (0, e.default)({
        type: "EnumNumberBody",
        members: t,
        explicitType: null,
        hasUnknownMembers: null,
      });
    }),
    (Hi.enumNumberMember = function (t, r) {
      return (0, e.default)({ type: "EnumNumberMember", id: t, init: r });
    }),
    (Hi.enumStringBody = function (t) {
      return (0, e.default)({
        type: "EnumStringBody",
        members: t,
        explicitType: null,
        hasUnknownMembers: null,
      });
    }),
    (Hi.enumStringMember = function (t, r) {
      return (0, e.default)({ type: "EnumStringMember", id: t, init: r });
    }),
    (Hi.enumSymbolBody = function (t) {
      return (0, e.default)({
        type: "EnumSymbolBody",
        members: t,
        hasUnknownMembers: null,
      });
    }),
    (Hi.existsTypeAnnotation = function () {
      return { type: "ExistsTypeAnnotation" };
    }),
    (Hi.exportAllDeclaration = function (t) {
      return (0, e.default)({ type: "ExportAllDeclaration", source: t });
    }),
    (Hi.exportDefaultDeclaration = function (t) {
      return (0, e.default)({
        type: "ExportDefaultDeclaration",
        declaration: t,
      });
    }),
    (Hi.exportDefaultSpecifier = function (t) {
      return (0, e.default)({ type: "ExportDefaultSpecifier", exported: t });
    }),
    (Hi.exportNamedDeclaration = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
      return (0, e.default)({
        type: "ExportNamedDeclaration",
        declaration: t,
        specifiers: r,
        source: n,
      });
    }),
    (Hi.exportNamespaceSpecifier = function (t) {
      return (0, e.default)({ type: "ExportNamespaceSpecifier", exported: t });
    }),
    (Hi.exportSpecifier = function (t, r) {
      return (0, e.default)({ type: "ExportSpecifier", local: t, exported: r });
    }),
    (Hi.expressionStatement = function (t) {
      return (0, e.default)({ type: "ExpressionStatement", expression: t });
    }),
    (Hi.file = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
      return (0, e.default)({
        type: "File",
        program: t,
        comments: r,
        tokens: n,
      });
    }),
    (Hi.forInStatement = function (t, r, n) {
      return (0, e.default)({
        type: "ForInStatement",
        left: t,
        right: r,
        body: n,
      });
    }),
    (Hi.forOfStatement = function (t, r, n) {
      var i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3];
      return (0, e.default)({
        type: "ForOfStatement",
        left: t,
        right: r,
        body: n,
        await: i,
      });
    }),
    (Hi.forStatement = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
        i = arguments.length > 3 ? arguments[3] : void 0;
      return (0, e.default)({
        type: "ForStatement",
        init: t,
        test: r,
        update: n,
        body: i,
      });
    }),
    (Hi.functionDeclaration = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r = arguments.length > 1 ? arguments[1] : void 0,
        n = arguments.length > 2 ? arguments[2] : void 0,
        i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
        a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
      return (0, e.default)({
        type: "FunctionDeclaration",
        id: t,
        params: r,
        body: n,
        generator: i,
        async: a,
      });
    }),
    (Hi.functionExpression = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r = arguments.length > 1 ? arguments[1] : void 0,
        n = arguments.length > 2 ? arguments[2] : void 0,
        i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
        a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
      return (0, e.default)({
        type: "FunctionExpression",
        id: t,
        params: r,
        body: n,
        generator: i,
        async: a,
      });
    }),
    (Hi.functionTypeAnnotation = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r = arguments.length > 1 ? arguments[1] : void 0,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
        i = arguments.length > 3 ? arguments[3] : void 0;
      return (0, e.default)({
        type: "FunctionTypeAnnotation",
        typeParameters: t,
        params: r,
        rest: n,
        returnType: i,
      });
    }),
    (Hi.functionTypeParam = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r = arguments.length > 1 ? arguments[1] : void 0;
      return (0, e.default)({
        type: "FunctionTypeParam",
        name: t,
        typeAnnotation: r,
      });
    }),
    (Hi.genericTypeAnnotation = function (t) {
      var r =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      return (0, e.default)({
        type: "GenericTypeAnnotation",
        id: t,
        typeParameters: r,
      });
    }),
    (Hi.identifier = function (t) {
      return (0, e.default)({ type: "Identifier", name: t });
    }),
    (Hi.ifStatement = function (t, r) {
      var n =
        arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
      return (0, e.default)({
        type: "IfStatement",
        test: t,
        consequent: r,
        alternate: n,
      });
    }),
    (Hi.import = function () {
      return { type: "Import" };
    }),
    (Hi.importAttribute = function (t, r) {
      return (0, e.default)({ type: "ImportAttribute", key: t, value: r });
    }),
    (Hi.importDeclaration = function (t, r) {
      return (0, e.default)({
        type: "ImportDeclaration",
        specifiers: t,
        source: r,
      });
    }),
    (Hi.importDefaultSpecifier = function (t) {
      return (0, e.default)({ type: "ImportDefaultSpecifier", local: t });
    }),
    (Hi.importNamespaceSpecifier = function (t) {
      return (0, e.default)({ type: "ImportNamespaceSpecifier", local: t });
    }),
    (Hi.importSpecifier = function (t, r) {
      return (0, e.default)({ type: "ImportSpecifier", local: t, imported: r });
    }),
    (Hi.indexedAccessType = function (t, r) {
      return (0, e.default)({
        type: "IndexedAccessType",
        objectType: t,
        indexType: r,
      });
    }),
    (Hi.inferredPredicate = function () {
      return { type: "InferredPredicate" };
    }),
    (Hi.interfaceDeclaration = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
        i = arguments.length > 3 ? arguments[3] : void 0;
      return (0, e.default)({
        type: "InterfaceDeclaration",
        id: t,
        typeParameters: r,
        extends: n,
        body: i,
      });
    }),
    (Hi.interfaceExtends = function (t) {
      var r =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      return (0, e.default)({
        type: "InterfaceExtends",
        id: t,
        typeParameters: r,
      });
    }),
    (Hi.interfaceTypeAnnotation = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r = arguments.length > 1 ? arguments[1] : void 0;
      return (0, e.default)({
        type: "InterfaceTypeAnnotation",
        extends: t,
        body: r,
      });
    }),
    (Hi.interpreterDirective = function (t) {
      return (0, e.default)({ type: "InterpreterDirective", value: t });
    }),
    (Hi.intersectionTypeAnnotation = function (t) {
      return (0, e.default)({ type: "IntersectionTypeAnnotation", types: t });
    }),
    (Hi.jSXAttribute = Hi.jsxAttribute =
      function (t) {
        var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        return (0, e.default)({ type: "JSXAttribute", name: t, value: r });
      }),
    (Hi.jSXClosingElement = Hi.jsxClosingElement =
      function (t) {
        return (0, e.default)({ type: "JSXClosingElement", name: t });
      }),
    (Hi.jSXClosingFragment = Hi.jsxClosingFragment =
      function () {
        return { type: "JSXClosingFragment" };
      }),
    (Hi.jSXElement = Hi.jsxElement =
      function (t) {
        var r =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null,
          n = arguments.length > 2 ? arguments[2] : void 0,
          i =
            arguments.length > 3 && void 0 !== arguments[3]
              ? arguments[3]
              : null;
        return (0, e.default)({
          type: "JSXElement",
          openingElement: t,
          closingElement: r,
          children: n,
          selfClosing: i,
        });
      }),
    (Hi.jSXEmptyExpression = Hi.jsxEmptyExpression =
      function () {
        return { type: "JSXEmptyExpression" };
      }),
    (Hi.jSXExpressionContainer = Hi.jsxExpressionContainer =
      function (t) {
        return (0, e.default)({
          type: "JSXExpressionContainer",
          expression: t,
        });
      }),
    (Hi.jSXFragment = Hi.jsxFragment =
      function (t, r, n) {
        return (0, e.default)({
          type: "JSXFragment",
          openingFragment: t,
          closingFragment: r,
          children: n,
        });
      }),
    (Hi.jSXIdentifier = Hi.jsxIdentifier =
      function (t) {
        return (0, e.default)({ type: "JSXIdentifier", name: t });
      }),
    (Hi.jSXMemberExpression = Hi.jsxMemberExpression =
      function (t, r) {
        return (0, e.default)({
          type: "JSXMemberExpression",
          object: t,
          property: r,
        });
      }),
    (Hi.jSXNamespacedName = Hi.jsxNamespacedName =
      function (t, r) {
        return (0, e.default)({
          type: "JSXNamespacedName",
          namespace: t,
          name: r,
        });
      }),
    (Hi.jSXOpeningElement = Hi.jsxOpeningElement =
      function (t, r) {
        var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return (0, e.default)({
          type: "JSXOpeningElement",
          name: t,
          attributes: r,
          selfClosing: n,
        });
      }),
    (Hi.jSXOpeningFragment = Hi.jsxOpeningFragment =
      function () {
        return { type: "JSXOpeningFragment" };
      }),
    (Hi.jSXSpreadAttribute = Hi.jsxSpreadAttribute =
      function (t) {
        return (0, e.default)({ type: "JSXSpreadAttribute", argument: t });
      }),
    (Hi.jSXSpreadChild = Hi.jsxSpreadChild =
      function (t) {
        return (0, e.default)({ type: "JSXSpreadChild", expression: t });
      }),
    (Hi.jSXText = Hi.jsxText =
      function (t) {
        return (0, e.default)({ type: "JSXText", value: t });
      }),
    (Hi.labeledStatement = function (t, r) {
      return (0, e.default)({ type: "LabeledStatement", label: t, body: r });
    }),
    (Hi.logicalExpression = function (t, r, n) {
      return (0, e.default)({
        type: "LogicalExpression",
        operator: t,
        left: r,
        right: n,
      });
    }),
    (Hi.memberExpression = function (t, r) {
      var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
        i =
          arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
      return (0, e.default)({
        type: "MemberExpression",
        object: t,
        property: r,
        computed: n,
        optional: i,
      });
    }),
    (Hi.metaProperty = function (t, r) {
      return (0, e.default)({ type: "MetaProperty", meta: t, property: r });
    }),
    (Hi.mixedTypeAnnotation = function () {
      return { type: "MixedTypeAnnotation" };
    }),
    (Hi.moduleExpression = function (t) {
      return (0, e.default)({ type: "ModuleExpression", body: t });
    }),
    (Hi.newExpression = function (t, r) {
      return (0, e.default)({ type: "NewExpression", callee: t, arguments: r });
    }),
    (Hi.noop = function () {
      return { type: "Noop" };
    }),
    (Hi.nullLiteral = function () {
      return { type: "NullLiteral" };
    }),
    (Hi.nullLiteralTypeAnnotation = function () {
      return { type: "NullLiteralTypeAnnotation" };
    }),
    (Hi.nullableTypeAnnotation = function (t) {
      return (0, e.default)({
        type: "NullableTypeAnnotation",
        typeAnnotation: t,
      });
    }),
    (Hi.numberLiteral = function (e) {
      return (
        (0, t.default)("NumberLiteral", "NumericLiteral", "The node type "),
        r(e)
      );
    }),
    (Hi.numberLiteralTypeAnnotation = function (t) {
      return (0, e.default)({ type: "NumberLiteralTypeAnnotation", value: t });
    }),
    (Hi.numberTypeAnnotation = function () {
      return { type: "NumberTypeAnnotation" };
    }),
    (Hi.numericLiteral = r),
    (Hi.objectExpression = function (t) {
      return (0, e.default)({ type: "ObjectExpression", properties: t });
    }),
    (Hi.objectMethod = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0]
            ? arguments[0]
            : "method",
        r = arguments.length > 1 ? arguments[1] : void 0,
        n = arguments.length > 2 ? arguments[2] : void 0,
        i = arguments.length > 3 ? arguments[3] : void 0,
        a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4],
        s = arguments.length > 5 && void 0 !== arguments[5] && arguments[5],
        o = arguments.length > 6 && void 0 !== arguments[6] && arguments[6];
      return (0, e.default)({
        type: "ObjectMethod",
        kind: t,
        key: r,
        params: n,
        body: i,
        computed: a,
        generator: s,
        async: o,
      });
    }),
    (Hi.objectPattern = function (t) {
      return (0, e.default)({ type: "ObjectPattern", properties: t });
    }),
    (Hi.objectProperty = function (t, r) {
      var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
        i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
        a =
          arguments.length > 4 && void 0 !== arguments[4] ? arguments[4] : null;
      return (0, e.default)({
        type: "ObjectProperty",
        key: t,
        value: r,
        computed: n,
        shorthand: i,
        decorators: a,
      });
    }),
    (Hi.objectTypeAnnotation = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
        n = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : [],
        i = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : [],
        a = arguments.length > 4 && void 0 !== arguments[4] && arguments[4];
      return (0, e.default)({
        type: "ObjectTypeAnnotation",
        properties: t,
        indexers: r,
        callProperties: n,
        internalSlots: i,
        exact: a,
      });
    }),
    (Hi.objectTypeCallProperty = function (t) {
      return (0, e.default)({
        type: "ObjectTypeCallProperty",
        value: t,
        static: null,
      });
    }),
    (Hi.objectTypeIndexer = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r = arguments.length > 1 ? arguments[1] : void 0,
        n = arguments.length > 2 ? arguments[2] : void 0,
        i =
          arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
      return (0, e.default)({
        type: "ObjectTypeIndexer",
        id: t,
        key: r,
        value: n,
        variance: i,
        static: null,
      });
    }),
    (Hi.objectTypeInternalSlot = function (t, r, n, i, a) {
      return (0, e.default)({
        type: "ObjectTypeInternalSlot",
        id: t,
        value: r,
        optional: n,
        static: i,
        method: a,
      });
    }),
    (Hi.objectTypeProperty = function (t, r) {
      var n =
        arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
      return (0, e.default)({
        type: "ObjectTypeProperty",
        key: t,
        value: r,
        variance: n,
        kind: null,
        method: null,
        optional: null,
        proto: null,
        static: null,
      });
    }),
    (Hi.objectTypeSpreadProperty = function (t) {
      return (0, e.default)({ type: "ObjectTypeSpreadProperty", argument: t });
    }),
    (Hi.opaqueType = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null,
        i = arguments.length > 3 ? arguments[3] : void 0;
      return (0, e.default)({
        type: "OpaqueType",
        id: t,
        typeParameters: r,
        supertype: n,
        impltype: i,
      });
    }),
    (Hi.optionalCallExpression = function (t, r, n) {
      return (0, e.default)({
        type: "OptionalCallExpression",
        callee: t,
        arguments: r,
        optional: n,
      });
    }),
    (Hi.optionalIndexedAccessType = function (t, r) {
      return (0, e.default)({
        type: "OptionalIndexedAccessType",
        objectType: t,
        indexType: r,
        optional: null,
      });
    }),
    (Hi.optionalMemberExpression = function (t, r) {
      var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
        i = arguments.length > 3 ? arguments[3] : void 0;
      return (0, e.default)({
        type: "OptionalMemberExpression",
        object: t,
        property: r,
        computed: n,
        optional: i,
      });
    }),
    (Hi.parenthesizedExpression = function (t) {
      return (0, e.default)({ type: "ParenthesizedExpression", expression: t });
    }),
    (Hi.pipelineBareFunction = function (t) {
      return (0, e.default)({ type: "PipelineBareFunction", callee: t });
    }),
    (Hi.pipelinePrimaryTopicReference = function () {
      return { type: "PipelinePrimaryTopicReference" };
    }),
    (Hi.pipelineTopicExpression = function (t) {
      return (0, e.default)({ type: "PipelineTopicExpression", expression: t });
    }),
    (Hi.placeholder = function (t, r) {
      return (0, e.default)({ type: "Placeholder", expectedNode: t, name: r });
    }),
    (Hi.privateName = function (t) {
      return (0, e.default)({ type: "PrivateName", id: t });
    }),
    (Hi.program = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
        n =
          arguments.length > 2 && void 0 !== arguments[2]
            ? arguments[2]
            : "script",
        i =
          arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : null;
      return (0, e.default)({
        type: "Program",
        body: t,
        directives: r,
        sourceType: n,
        interpreter: i,
        sourceFile: null,
      });
    }),
    (Hi.qualifiedTypeIdentifier = function (t, r) {
      return (0, e.default)({
        type: "QualifiedTypeIdentifier",
        id: t,
        qualification: r,
      });
    }),
    (Hi.recordExpression = function (t) {
      return (0, e.default)({ type: "RecordExpression", properties: t });
    }),
    (Hi.regExpLiteral = n),
    (Hi.regexLiteral = function (e) {
      var r =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
      return (
        (0, t.default)("RegexLiteral", "RegExpLiteral", "The node type "),
        n(e, r)
      );
    }),
    (Hi.restElement = i),
    (Hi.restProperty = function (e) {
      return (
        (0, t.default)("RestProperty", "RestElement", "The node type "), i(e)
      );
    }),
    (Hi.returnStatement = function () {
      var t =
        arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null;
      return (0, e.default)({ type: "ReturnStatement", argument: t });
    }),
    (Hi.sequenceExpression = function (t) {
      return (0, e.default)({ type: "SequenceExpression", expressions: t });
    }),
    (Hi.spreadElement = a),
    (Hi.spreadProperty = function (e) {
      return (
        (0, t.default)("SpreadProperty", "SpreadElement", "The node type "),
        a(e)
      );
    }),
    (Hi.staticBlock = function (t) {
      return (0, e.default)({ type: "StaticBlock", body: t });
    }),
    (Hi.stringLiteral = function (t) {
      return (0, e.default)({ type: "StringLiteral", value: t });
    }),
    (Hi.stringLiteralTypeAnnotation = function (t) {
      return (0, e.default)({ type: "StringLiteralTypeAnnotation", value: t });
    }),
    (Hi.stringTypeAnnotation = function () {
      return { type: "StringTypeAnnotation" };
    }),
    (Hi.super = function () {
      return { type: "Super" };
    }),
    (Hi.switchCase = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r = arguments.length > 1 ? arguments[1] : void 0;
      return (0, e.default)({ type: "SwitchCase", test: t, consequent: r });
    }),
    (Hi.switchStatement = function (t, r) {
      return (0, e.default)({
        type: "SwitchStatement",
        discriminant: t,
        cases: r,
      });
    }),
    (Hi.symbolTypeAnnotation = function () {
      return { type: "SymbolTypeAnnotation" };
    }),
    (Hi.taggedTemplateExpression = function (t, r) {
      return (0, e.default)({
        type: "TaggedTemplateExpression",
        tag: t,
        quasi: r,
      });
    }),
    (Hi.templateElement = function (t) {
      var r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      return (0, e.default)({ type: "TemplateElement", value: t, tail: r });
    }),
    (Hi.templateLiteral = function (t, r) {
      return (0, e.default)({
        type: "TemplateLiteral",
        quasis: t,
        expressions: r,
      });
    }),
    (Hi.thisExpression = function () {
      return { type: "ThisExpression" };
    }),
    (Hi.thisTypeAnnotation = function () {
      return { type: "ThisTypeAnnotation" };
    }),
    (Hi.throwStatement = function (t) {
      return (0, e.default)({ type: "ThrowStatement", argument: t });
    }),
    (Hi.topicReference = function () {
      return { type: "TopicReference" };
    }),
    (Hi.tryStatement = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
      return (0, e.default)({
        type: "TryStatement",
        block: t,
        handler: r,
        finalizer: n,
      });
    }),
    (Hi.tSAnyKeyword = Hi.tsAnyKeyword =
      function () {
        return { type: "TSAnyKeyword" };
      }),
    (Hi.tSArrayType = Hi.tsArrayType =
      function (t) {
        return (0, e.default)({ type: "TSArrayType", elementType: t });
      }),
    (Hi.tSAsExpression = Hi.tsAsExpression =
      function (t, r) {
        return (0, e.default)({
          type: "TSAsExpression",
          expression: t,
          typeAnnotation: r,
        });
      }),
    (Hi.tSBigIntKeyword = Hi.tsBigIntKeyword =
      function () {
        return { type: "TSBigIntKeyword" };
      }),
    (Hi.tSBooleanKeyword = Hi.tsBooleanKeyword =
      function () {
        return { type: "TSBooleanKeyword" };
      }),
    (Hi.tSCallSignatureDeclaration = Hi.tsCallSignatureDeclaration =
      function () {
        var t =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : null,
          r = arguments.length > 1 ? arguments[1] : void 0,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : null;
        return (0, e.default)({
          type: "TSCallSignatureDeclaration",
          typeParameters: t,
          parameters: r,
          typeAnnotation: n,
        });
      }),
    (Hi.tSConditionalType = Hi.tsConditionalType =
      function (t, r, n, i) {
        return (0, e.default)({
          type: "TSConditionalType",
          checkType: t,
          extendsType: r,
          trueType: n,
          falseType: i,
        });
      }),
    (Hi.tSConstructSignatureDeclaration = Hi.tsConstructSignatureDeclaration =
      function () {
        var t =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : null,
          r = arguments.length > 1 ? arguments[1] : void 0,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : null;
        return (0, e.default)({
          type: "TSConstructSignatureDeclaration",
          typeParameters: t,
          parameters: r,
          typeAnnotation: n,
        });
      }),
    (Hi.tSConstructorType = Hi.tsConstructorType =
      function () {
        var t =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : null,
          r = arguments.length > 1 ? arguments[1] : void 0,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : null;
        return (0, e.default)({
          type: "TSConstructorType",
          typeParameters: t,
          parameters: r,
          typeAnnotation: n,
        });
      }),
    (Hi.tSDeclareFunction = Hi.tsDeclareFunction =
      function () {
        var t =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : null,
          r =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null,
          n = arguments.length > 2 ? arguments[2] : void 0,
          i =
            arguments.length > 3 && void 0 !== arguments[3]
              ? arguments[3]
              : null;
        return (0, e.default)({
          type: "TSDeclareFunction",
          id: t,
          typeParameters: r,
          params: n,
          returnType: i,
        });
      }),
    (Hi.tSDeclareMethod = Hi.tsDeclareMethod =
      function () {
        var t =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : null,
          r = arguments.length > 1 ? arguments[1] : void 0,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : null,
          i = arguments.length > 3 ? arguments[3] : void 0,
          a =
            arguments.length > 4 && void 0 !== arguments[4]
              ? arguments[4]
              : null;
        return (0, e.default)({
          type: "TSDeclareMethod",
          decorators: t,
          key: r,
          typeParameters: n,
          params: i,
          returnType: a,
        });
      }),
    (Hi.tSEnumDeclaration = Hi.tsEnumDeclaration =
      function (t, r) {
        return (0, e.default)({ type: "TSEnumDeclaration", id: t, members: r });
      }),
    (Hi.tSEnumMember = Hi.tsEnumMember =
      function (t) {
        var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        return (0, e.default)({ type: "TSEnumMember", id: t, initializer: r });
      }),
    (Hi.tSExportAssignment = Hi.tsExportAssignment =
      function (t) {
        return (0, e.default)({ type: "TSExportAssignment", expression: t });
      }),
    (Hi.tSExpressionWithTypeArguments = Hi.tsExpressionWithTypeArguments =
      function (t) {
        var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        return (0, e.default)({
          type: "TSExpressionWithTypeArguments",
          expression: t,
          typeParameters: r,
        });
      }),
    (Hi.tSExternalModuleReference = Hi.tsExternalModuleReference =
      function (t) {
        return (0, e.default)({
          type: "TSExternalModuleReference",
          expression: t,
        });
      }),
    (Hi.tSFunctionType = Hi.tsFunctionType =
      function () {
        var t =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : null,
          r = arguments.length > 1 ? arguments[1] : void 0,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : null;
        return (0, e.default)({
          type: "TSFunctionType",
          typeParameters: t,
          parameters: r,
          typeAnnotation: n,
        });
      }),
    (Hi.tSImportEqualsDeclaration = Hi.tsImportEqualsDeclaration =
      function (t, r) {
        return (0, e.default)({
          type: "TSImportEqualsDeclaration",
          id: t,
          moduleReference: r,
          isExport: null,
        });
      }),
    (Hi.tSImportType = Hi.tsImportType =
      function (t) {
        var r =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : null;
        return (0, e.default)({
          type: "TSImportType",
          argument: t,
          qualifier: r,
          typeParameters: n,
        });
      }),
    (Hi.tSIndexSignature = Hi.tsIndexSignature =
      function (t) {
        var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        return (0, e.default)({
          type: "TSIndexSignature",
          parameters: t,
          typeAnnotation: r,
        });
      }),
    (Hi.tSIndexedAccessType = Hi.tsIndexedAccessType =
      function (t, r) {
        return (0, e.default)({
          type: "TSIndexedAccessType",
          objectType: t,
          indexType: r,
        });
      }),
    (Hi.tSInferType = Hi.tsInferType =
      function (t) {
        return (0, e.default)({ type: "TSInferType", typeParameter: t });
      }),
    (Hi.tSInstantiationExpression = Hi.tsInstantiationExpression =
      function (t) {
        var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        return (0, e.default)({
          type: "TSInstantiationExpression",
          expression: t,
          typeParameters: r,
        });
      }),
    (Hi.tSInterfaceBody = Hi.tsInterfaceBody =
      function (t) {
        return (0, e.default)({ type: "TSInterfaceBody", body: t });
      }),
    (Hi.tSInterfaceDeclaration = Hi.tsInterfaceDeclaration =
      function (t) {
        var r =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : null,
          i = arguments.length > 3 ? arguments[3] : void 0;
        return (0, e.default)({
          type: "TSInterfaceDeclaration",
          id: t,
          typeParameters: r,
          extends: n,
          body: i,
        });
      }),
    (Hi.tSIntersectionType = Hi.tsIntersectionType =
      function (t) {
        return (0, e.default)({ type: "TSIntersectionType", types: t });
      }),
    (Hi.tSIntrinsicKeyword = Hi.tsIntrinsicKeyword =
      function () {
        return { type: "TSIntrinsicKeyword" };
      }),
    (Hi.tSLiteralType = Hi.tsLiteralType =
      function (t) {
        return (0, e.default)({ type: "TSLiteralType", literal: t });
      }),
    (Hi.tSMappedType = Hi.tsMappedType =
      function (t) {
        var r =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : null;
        return (0, e.default)({
          type: "TSMappedType",
          typeParameter: t,
          typeAnnotation: r,
          nameType: n,
        });
      }),
    (Hi.tSMethodSignature = Hi.tsMethodSignature =
      function (t) {
        var r =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null,
          n = arguments.length > 2 ? arguments[2] : void 0,
          i =
            arguments.length > 3 && void 0 !== arguments[3]
              ? arguments[3]
              : null;
        return (0, e.default)({
          type: "TSMethodSignature",
          key: t,
          typeParameters: r,
          parameters: n,
          typeAnnotation: i,
          kind: null,
        });
      }),
    (Hi.tSModuleBlock = Hi.tsModuleBlock =
      function (t) {
        return (0, e.default)({ type: "TSModuleBlock", body: t });
      }),
    (Hi.tSModuleDeclaration = Hi.tsModuleDeclaration =
      function (t, r) {
        return (0, e.default)({ type: "TSModuleDeclaration", id: t, body: r });
      }),
    (Hi.tSNamedTupleMember = Hi.tsNamedTupleMember =
      function (t, r) {
        var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
        return (0, e.default)({
          type: "TSNamedTupleMember",
          label: t,
          elementType: r,
          optional: n,
        });
      }),
    (Hi.tSNamespaceExportDeclaration = Hi.tsNamespaceExportDeclaration =
      function (t) {
        return (0, e.default)({ type: "TSNamespaceExportDeclaration", id: t });
      }),
    (Hi.tSNeverKeyword = Hi.tsNeverKeyword =
      function () {
        return { type: "TSNeverKeyword" };
      }),
    (Hi.tSNonNullExpression = Hi.tsNonNullExpression =
      function (t) {
        return (0, e.default)({ type: "TSNonNullExpression", expression: t });
      }),
    (Hi.tSNullKeyword = Hi.tsNullKeyword =
      function () {
        return { type: "TSNullKeyword" };
      }),
    (Hi.tSNumberKeyword = Hi.tsNumberKeyword =
      function () {
        return { type: "TSNumberKeyword" };
      }),
    (Hi.tSObjectKeyword = Hi.tsObjectKeyword =
      function () {
        return { type: "TSObjectKeyword" };
      }),
    (Hi.tSOptionalType = Hi.tsOptionalType =
      function (t) {
        return (0, e.default)({ type: "TSOptionalType", typeAnnotation: t });
      }),
    (Hi.tSParameterProperty = Hi.tsParameterProperty =
      function (t) {
        return (0, e.default)({ type: "TSParameterProperty", parameter: t });
      }),
    (Hi.tSParenthesizedType = Hi.tsParenthesizedType =
      function (t) {
        return (0, e.default)({
          type: "TSParenthesizedType",
          typeAnnotation: t,
        });
      }),
    (Hi.tSPropertySignature = Hi.tsPropertySignature =
      function (t) {
        var r =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : null;
        return (0, e.default)({
          type: "TSPropertySignature",
          key: t,
          typeAnnotation: r,
          initializer: n,
          kind: null,
        });
      }),
    (Hi.tSQualifiedName = Hi.tsQualifiedName =
      function (t, r) {
        return (0, e.default)({ type: "TSQualifiedName", left: t, right: r });
      }),
    (Hi.tSRestType = Hi.tsRestType =
      function (t) {
        return (0, e.default)({ type: "TSRestType", typeAnnotation: t });
      }),
    (Hi.tSSatisfiesExpression = Hi.tsSatisfiesExpression =
      function (t, r) {
        return (0, e.default)({
          type: "TSSatisfiesExpression",
          expression: t,
          typeAnnotation: r,
        });
      }),
    (Hi.tSStringKeyword = Hi.tsStringKeyword =
      function () {
        return { type: "TSStringKeyword" };
      }),
    (Hi.tSSymbolKeyword = Hi.tsSymbolKeyword =
      function () {
        return { type: "TSSymbolKeyword" };
      }),
    (Hi.tSThisType = Hi.tsThisType =
      function () {
        return { type: "TSThisType" };
      }),
    (Hi.tSTupleType = Hi.tsTupleType =
      function (t) {
        return (0, e.default)({ type: "TSTupleType", elementTypes: t });
      }),
    (Hi.tSTypeAliasDeclaration = Hi.tsTypeAliasDeclaration =
      function (t) {
        var r =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null,
          n = arguments.length > 2 ? arguments[2] : void 0;
        return (0, e.default)({
          type: "TSTypeAliasDeclaration",
          id: t,
          typeParameters: r,
          typeAnnotation: n,
        });
      }),
    (Hi.tSTypeAnnotation = Hi.tsTypeAnnotation =
      function (t) {
        return (0, e.default)({ type: "TSTypeAnnotation", typeAnnotation: t });
      }),
    (Hi.tSTypeAssertion = Hi.tsTypeAssertion =
      function (t, r) {
        return (0, e.default)({
          type: "TSTypeAssertion",
          typeAnnotation: t,
          expression: r,
        });
      }),
    (Hi.tSTypeLiteral = Hi.tsTypeLiteral =
      function (t) {
        return (0, e.default)({ type: "TSTypeLiteral", members: t });
      }),
    (Hi.tSTypeOperator = Hi.tsTypeOperator =
      function (t) {
        return (0, e.default)({
          type: "TSTypeOperator",
          typeAnnotation: t,
          operator: null,
        });
      }),
    (Hi.tSTypeParameter = Hi.tsTypeParameter =
      function () {
        var t =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : null,
          r =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null,
          n = arguments.length > 2 ? arguments[2] : void 0;
        return (0, e.default)({
          type: "TSTypeParameter",
          constraint: t,
          default: r,
          name: n,
        });
      }),
    (Hi.tSTypeParameterDeclaration = Hi.tsTypeParameterDeclaration =
      function (t) {
        return (0, e.default)({
          type: "TSTypeParameterDeclaration",
          params: t,
        });
      }),
    (Hi.tSTypeParameterInstantiation = Hi.tsTypeParameterInstantiation =
      function (t) {
        return (0, e.default)({
          type: "TSTypeParameterInstantiation",
          params: t,
        });
      }),
    (Hi.tSTypePredicate = Hi.tsTypePredicate =
      function (t) {
        var r =
            arguments.length > 1 && void 0 !== arguments[1]
              ? arguments[1]
              : null,
          n =
            arguments.length > 2 && void 0 !== arguments[2]
              ? arguments[2]
              : null;
        return (0, e.default)({
          type: "TSTypePredicate",
          parameterName: t,
          typeAnnotation: r,
          asserts: n,
        });
      }),
    (Hi.tSTypeQuery = Hi.tsTypeQuery =
      function (t) {
        var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        return (0, e.default)({
          type: "TSTypeQuery",
          exprName: t,
          typeParameters: r,
        });
      }),
    (Hi.tSTypeReference = Hi.tsTypeReference =
      function (t) {
        var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
        return (0, e.default)({
          type: "TSTypeReference",
          typeName: t,
          typeParameters: r,
        });
      }),
    (Hi.tSUndefinedKeyword = Hi.tsUndefinedKeyword =
      function () {
        return { type: "TSUndefinedKeyword" };
      }),
    (Hi.tSUnionType = Hi.tsUnionType =
      function (t) {
        return (0, e.default)({ type: "TSUnionType", types: t });
      }),
    (Hi.tSUnknownKeyword = Hi.tsUnknownKeyword =
      function () {
        return { type: "TSUnknownKeyword" };
      }),
    (Hi.tSVoidKeyword = Hi.tsVoidKeyword =
      function () {
        return { type: "TSVoidKeyword" };
      }),
    (Hi.tupleExpression = function () {
      var t =
        arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [];
      return (0, e.default)({ type: "TupleExpression", elements: t });
    }),
    (Hi.tupleTypeAnnotation = function (t) {
      return (0, e.default)({ type: "TupleTypeAnnotation", types: t });
    }),
    (Hi.typeAlias = function (t) {
      var r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n = arguments.length > 2 ? arguments[2] : void 0;
      return (0, e.default)({
        type: "TypeAlias",
        id: t,
        typeParameters: r,
        right: n,
      });
    }),
    (Hi.typeAnnotation = function (t) {
      return (0, e.default)({ type: "TypeAnnotation", typeAnnotation: t });
    }),
    (Hi.typeCastExpression = function (t, r) {
      return (0, e.default)({
        type: "TypeCastExpression",
        expression: t,
        typeAnnotation: r,
      });
    }),
    (Hi.typeParameter = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null,
        n =
          arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : null;
      return (0, e.default)({
        type: "TypeParameter",
        bound: t,
        default: r,
        variance: n,
        name: null,
      });
    }),
    (Hi.typeParameterDeclaration = function (t) {
      return (0, e.default)({ type: "TypeParameterDeclaration", params: t });
    }),
    (Hi.typeParameterInstantiation = function (t) {
      return (0, e.default)({ type: "TypeParameterInstantiation", params: t });
    }),
    (Hi.typeofTypeAnnotation = function (t) {
      return (0, e.default)({ type: "TypeofTypeAnnotation", argument: t });
    }),
    (Hi.unaryExpression = function (t, r) {
      var n =
        !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2];
      return (0, e.default)({
        type: "UnaryExpression",
        operator: t,
        argument: r,
        prefix: n,
      });
    }),
    (Hi.unionTypeAnnotation = function (t) {
      return (0, e.default)({ type: "UnionTypeAnnotation", types: t });
    }),
    (Hi.updateExpression = function (t, r) {
      var n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
      return (0, e.default)({
        type: "UpdateExpression",
        operator: t,
        argument: r,
        prefix: n,
      });
    }),
    (Hi.v8IntrinsicIdentifier = function (t) {
      return (0, e.default)({ type: "V8IntrinsicIdentifier", name: t });
    }),
    (Hi.variableDeclaration = function (t, r) {
      return (0, e.default)({
        type: "VariableDeclaration",
        kind: t,
        declarations: r,
      });
    }),
    (Hi.variableDeclarator = function (t) {
      var r =
        arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : null;
      return (0, e.default)({ type: "VariableDeclarator", id: t, init: r });
    }),
    (Hi.variance = function (t) {
      return (0, e.default)({ type: "Variance", kind: t });
    }),
    (Hi.voidTypeAnnotation = function () {
      return { type: "VoidTypeAnnotation" };
    }),
    (Hi.whileStatement = function (t, r) {
      return (0, e.default)({ type: "WhileStatement", test: t, body: r });
    }),
    (Hi.withStatement = function (t, r) {
      return (0, e.default)({ type: "WithStatement", object: t, body: r });
    }),
    (Hi.yieldExpression = function () {
      var t =
          arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : null,
        r = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
      return (0, e.default)({
        type: "YieldExpression",
        argument: t,
        delegate: r,
      });
    });
  var e = (function () {
      if (Ts) return Yi;
      (Ts = 1),
        Object.defineProperty(Yi, "__esModule", { value: !0 }),
        (Yi.default = function (r) {
          var n,
            i = ks(t.BUILDER_KEYS[r.type]);
          try {
            for (i.s(); !(n = i.n()).done; ) {
              var a = n.value;
              (0, e.default)(r, a, r[a]);
            }
          } catch (e) {
            i.e(e);
          } finally {
            i.f();
          }
          return r;
        });
      var e = As(),
        t = mc();
      return Yi;
    })(),
    t = Li;
  function r(t) {
    return (0, e.default)({ type: "NumericLiteral", value: t });
  }
  function n(t) {
    var r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "";
    return (0, e.default)({ type: "RegExpLiteral", pattern: t, flags: r });
  }
  function i(t) {
    return (0, e.default)({ type: "RestElement", argument: t });
  }
  function a(t) {
    return (0, e.default)({ type: "SpreadElement", argument: t });
  }
  return Hi;
}
function Is() {
  if (Es) return Wi;
  (Es = 1),
    Object.defineProperty(Wi, "__esModule", { value: !0 }),
    (Wi.default = function (r) {
      for (var n = [], i = 0; i < r.children.length; i++) {
        var a = r.children[i];
        (0, e.isJSXText)(a)
          ? (0, t.default)(a, n)
          : ((0, e.isJSXExpressionContainer)(a) && (a = a.expression),
            (0, e.isJSXEmptyExpression)(a) || n.push(a));
      }
      return n;
    });
  var e = _i,
    t = (function () {
      if (xs) return qi;
      (xs = 1),
        Object.defineProperty(qi, "__esModule", { value: !0 }),
        (qi.default = function (r, n) {
          for (
            var i = r.value.split(/\r\n|\n|\r/), a = 0, s = 0;
            s < i.length;
            s++
          )
            i[s].match(/[^ \t]/) && (a = s);
          for (var o = "", l = 0; l < i.length; l++) {
            var u = i[l],
              c = 0 === l,
              p = l === i.length - 1,
              h = l === a,
              d = u.replace(/\t/g, " ");
            c || (d = d.replace(/^[ ]+/, "")),
              p || (d = d.replace(/[ ]+$/, "")),
              d && (h || (d += " "), (o += d));
          }
          o && n.push((0, t.inherits)((0, e.stringLiteral)(o), r));
        });
      var e = Cs(),
        t = mc();
      return qi;
    })();
  return Wi;
}
vs.DEPRECATED_ALIASES = { ModuleDeclaration: "ImportOrExportDeclaration" };
var Os = {},
  Ns = {};
Object.defineProperty(Ns, "__esModule", { value: !0 }),
  (Ns.default = function (e) {
    return !(!e || !_s.VISITOR_KEYS[e.type]);
  });
var _s = Ps();
Object.defineProperty(Os, "__esModule", { value: !0 }),
  (Os.default = function (e) {
    if (!(0, Ds.default)(e)) {
      var t,
        r = null != (t = null == e ? void 0 : e.type) ? t : JSON.stringify(e);
      throw new TypeError('Not a valid node of type "'.concat(r, '"'));
    }
  });
var Ds = Ns;
var Ls = {};
Object.defineProperty(Ls, "__esModule", { value: !0 }),
  (Ls.assertAccessor = function (e, t) {
    Fs("Accessor", e, t);
  }),
  (Ls.assertAnyTypeAnnotation = function (e, t) {
    Fs("AnyTypeAnnotation", e, t);
  }),
  (Ls.assertArgumentPlaceholder = function (e, t) {
    Fs("ArgumentPlaceholder", e, t);
  }),
  (Ls.assertArrayExpression = function (e, t) {
    Fs("ArrayExpression", e, t);
  }),
  (Ls.assertArrayPattern = function (e, t) {
    Fs("ArrayPattern", e, t);
  }),
  (Ls.assertArrayTypeAnnotation = function (e, t) {
    Fs("ArrayTypeAnnotation", e, t);
  }),
  (Ls.assertArrowFunctionExpression = function (e, t) {
    Fs("ArrowFunctionExpression", e, t);
  }),
  (Ls.assertAssignmentExpression = function (e, t) {
    Fs("AssignmentExpression", e, t);
  }),
  (Ls.assertAssignmentPattern = function (e, t) {
    Fs("AssignmentPattern", e, t);
  }),
  (Ls.assertAwaitExpression = function (e, t) {
    Fs("AwaitExpression", e, t);
  }),
  (Ls.assertBigIntLiteral = function (e, t) {
    Fs("BigIntLiteral", e, t);
  }),
  (Ls.assertBinary = function (e, t) {
    Fs("Binary", e, t);
  }),
  (Ls.assertBinaryExpression = function (e, t) {
    Fs("BinaryExpression", e, t);
  }),
  (Ls.assertBindExpression = function (e, t) {
    Fs("BindExpression", e, t);
  }),
  (Ls.assertBlock = function (e, t) {
    Fs("Block", e, t);
  }),
  (Ls.assertBlockParent = function (e, t) {
    Fs("BlockParent", e, t);
  }),
  (Ls.assertBlockStatement = function (e, t) {
    Fs("BlockStatement", e, t);
  }),
  (Ls.assertBooleanLiteral = function (e, t) {
    Fs("BooleanLiteral", e, t);
  }),
  (Ls.assertBooleanLiteralTypeAnnotation = function (e, t) {
    Fs("BooleanLiteralTypeAnnotation", e, t);
  }),
  (Ls.assertBooleanTypeAnnotation = function (e, t) {
    Fs("BooleanTypeAnnotation", e, t);
  }),
  (Ls.assertBreakStatement = function (e, t) {
    Fs("BreakStatement", e, t);
  }),
  (Ls.assertCallExpression = function (e, t) {
    Fs("CallExpression", e, t);
  }),
  (Ls.assertCatchClause = function (e, t) {
    Fs("CatchClause", e, t);
  }),
  (Ls.assertClass = function (e, t) {
    Fs("Class", e, t);
  }),
  (Ls.assertClassAccessorProperty = function (e, t) {
    Fs("ClassAccessorProperty", e, t);
  }),
  (Ls.assertClassBody = function (e, t) {
    Fs("ClassBody", e, t);
  }),
  (Ls.assertClassDeclaration = function (e, t) {
    Fs("ClassDeclaration", e, t);
  }),
  (Ls.assertClassExpression = function (e, t) {
    Fs("ClassExpression", e, t);
  }),
  (Ls.assertClassImplements = function (e, t) {
    Fs("ClassImplements", e, t);
  }),
  (Ls.assertClassMethod = function (e, t) {
    Fs("ClassMethod", e, t);
  }),
  (Ls.assertClassPrivateMethod = function (e, t) {
    Fs("ClassPrivateMethod", e, t);
  }),
  (Ls.assertClassPrivateProperty = function (e, t) {
    Fs("ClassPrivateProperty", e, t);
  }),
  (Ls.assertClassProperty = function (e, t) {
    Fs("ClassProperty", e, t);
  }),
  (Ls.assertCompletionStatement = function (e, t) {
    Fs("CompletionStatement", e, t);
  }),
  (Ls.assertConditional = function (e, t) {
    Fs("Conditional", e, t);
  }),
  (Ls.assertConditionalExpression = function (e, t) {
    Fs("ConditionalExpression", e, t);
  }),
  (Ls.assertContinueStatement = function (e, t) {
    Fs("ContinueStatement", e, t);
  }),
  (Ls.assertDebuggerStatement = function (e, t) {
    Fs("DebuggerStatement", e, t);
  }),
  (Ls.assertDecimalLiteral = function (e, t) {
    Fs("DecimalLiteral", e, t);
  }),
  (Ls.assertDeclaration = function (e, t) {
    Fs("Declaration", e, t);
  }),
  (Ls.assertDeclareClass = function (e, t) {
    Fs("DeclareClass", e, t);
  }),
  (Ls.assertDeclareExportAllDeclaration = function (e, t) {
    Fs("DeclareExportAllDeclaration", e, t);
  }),
  (Ls.assertDeclareExportDeclaration = function (e, t) {
    Fs("DeclareExportDeclaration", e, t);
  }),
  (Ls.assertDeclareFunction = function (e, t) {
    Fs("DeclareFunction", e, t);
  }),
  (Ls.assertDeclareInterface = function (e, t) {
    Fs("DeclareInterface", e, t);
  }),
  (Ls.assertDeclareModule = function (e, t) {
    Fs("DeclareModule", e, t);
  }),
  (Ls.assertDeclareModuleExports = function (e, t) {
    Fs("DeclareModuleExports", e, t);
  }),
  (Ls.assertDeclareOpaqueType = function (e, t) {
    Fs("DeclareOpaqueType", e, t);
  }),
  (Ls.assertDeclareTypeAlias = function (e, t) {
    Fs("DeclareTypeAlias", e, t);
  }),
  (Ls.assertDeclareVariable = function (e, t) {
    Fs("DeclareVariable", e, t);
  }),
  (Ls.assertDeclaredPredicate = function (e, t) {
    Fs("DeclaredPredicate", e, t);
  }),
  (Ls.assertDecorator = function (e, t) {
    Fs("Decorator", e, t);
  }),
  (Ls.assertDirective = function (e, t) {
    Fs("Directive", e, t);
  }),
  (Ls.assertDirectiveLiteral = function (e, t) {
    Fs("DirectiveLiteral", e, t);
  }),
  (Ls.assertDoExpression = function (e, t) {
    Fs("DoExpression", e, t);
  }),
  (Ls.assertDoWhileStatement = function (e, t) {
    Fs("DoWhileStatement", e, t);
  }),
  (Ls.assertEmptyStatement = function (e, t) {
    Fs("EmptyStatement", e, t);
  }),
  (Ls.assertEmptyTypeAnnotation = function (e, t) {
    Fs("EmptyTypeAnnotation", e, t);
  }),
  (Ls.assertEnumBody = function (e, t) {
    Fs("EnumBody", e, t);
  }),
  (Ls.assertEnumBooleanBody = function (e, t) {
    Fs("EnumBooleanBody", e, t);
  }),
  (Ls.assertEnumBooleanMember = function (e, t) {
    Fs("EnumBooleanMember", e, t);
  }),
  (Ls.assertEnumDeclaration = function (e, t) {
    Fs("EnumDeclaration", e, t);
  }),
  (Ls.assertEnumDefaultedMember = function (e, t) {
    Fs("EnumDefaultedMember", e, t);
  }),
  (Ls.assertEnumMember = function (e, t) {
    Fs("EnumMember", e, t);
  }),
  (Ls.assertEnumNumberBody = function (e, t) {
    Fs("EnumNumberBody", e, t);
  }),
  (Ls.assertEnumNumberMember = function (e, t) {
    Fs("EnumNumberMember", e, t);
  }),
  (Ls.assertEnumStringBody = function (e, t) {
    Fs("EnumStringBody", e, t);
  }),
  (Ls.assertEnumStringMember = function (e, t) {
    Fs("EnumStringMember", e, t);
  }),
  (Ls.assertEnumSymbolBody = function (e, t) {
    Fs("EnumSymbolBody", e, t);
  }),
  (Ls.assertExistsTypeAnnotation = function (e, t) {
    Fs("ExistsTypeAnnotation", e, t);
  }),
  (Ls.assertExportAllDeclaration = function (e, t) {
    Fs("ExportAllDeclaration", e, t);
  }),
  (Ls.assertExportDeclaration = function (e, t) {
    Fs("ExportDeclaration", e, t);
  }),
  (Ls.assertExportDefaultDeclaration = function (e, t) {
    Fs("ExportDefaultDeclaration", e, t);
  }),
  (Ls.assertExportDefaultSpecifier = function (e, t) {
    Fs("ExportDefaultSpecifier", e, t);
  }),
  (Ls.assertExportNamedDeclaration = function (e, t) {
    Fs("ExportNamedDeclaration", e, t);
  }),
  (Ls.assertExportNamespaceSpecifier = function (e, t) {
    Fs("ExportNamespaceSpecifier", e, t);
  }),
  (Ls.assertExportSpecifier = function (e, t) {
    Fs("ExportSpecifier", e, t);
  }),
  (Ls.assertExpression = function (e, t) {
    Fs("Expression", e, t);
  }),
  (Ls.assertExpressionStatement = function (e, t) {
    Fs("ExpressionStatement", e, t);
  }),
  (Ls.assertExpressionWrapper = function (e, t) {
    Fs("ExpressionWrapper", e, t);
  }),
  (Ls.assertFile = function (e, t) {
    Fs("File", e, t);
  }),
  (Ls.assertFlow = function (e, t) {
    Fs("Flow", e, t);
  }),
  (Ls.assertFlowBaseAnnotation = function (e, t) {
    Fs("FlowBaseAnnotation", e, t);
  }),
  (Ls.assertFlowDeclaration = function (e, t) {
    Fs("FlowDeclaration", e, t);
  }),
  (Ls.assertFlowPredicate = function (e, t) {
    Fs("FlowPredicate", e, t);
  }),
  (Ls.assertFlowType = function (e, t) {
    Fs("FlowType", e, t);
  }),
  (Ls.assertFor = function (e, t) {
    Fs("For", e, t);
  }),
  (Ls.assertForInStatement = function (e, t) {
    Fs("ForInStatement", e, t);
  }),
  (Ls.assertForOfStatement = function (e, t) {
    Fs("ForOfStatement", e, t);
  }),
  (Ls.assertForStatement = function (e, t) {
    Fs("ForStatement", e, t);
  }),
  (Ls.assertForXStatement = function (e, t) {
    Fs("ForXStatement", e, t);
  }),
  (Ls.assertFunction = function (e, t) {
    Fs("Function", e, t);
  }),
  (Ls.assertFunctionDeclaration = function (e, t) {
    Fs("FunctionDeclaration", e, t);
  }),
  (Ls.assertFunctionExpression = function (e, t) {
    Fs("FunctionExpression", e, t);
  }),
  (Ls.assertFunctionParent = function (e, t) {
    Fs("FunctionParent", e, t);
  }),
  (Ls.assertFunctionTypeAnnotation = function (e, t) {
    Fs("FunctionTypeAnnotation", e, t);
  }),
  (Ls.assertFunctionTypeParam = function (e, t) {
    Fs("FunctionTypeParam", e, t);
  }),
  (Ls.assertGenericTypeAnnotation = function (e, t) {
    Fs("GenericTypeAnnotation", e, t);
  }),
  (Ls.assertIdentifier = function (e, t) {
    Fs("Identifier", e, t);
  }),
  (Ls.assertIfStatement = function (e, t) {
    Fs("IfStatement", e, t);
  }),
  (Ls.assertImmutable = function (e, t) {
    Fs("Immutable", e, t);
  }),
  (Ls.assertImport = function (e, t) {
    Fs("Import", e, t);
  }),
  (Ls.assertImportAttribute = function (e, t) {
    Fs("ImportAttribute", e, t);
  }),
  (Ls.assertImportDeclaration = function (e, t) {
    Fs("ImportDeclaration", e, t);
  }),
  (Ls.assertImportDefaultSpecifier = function (e, t) {
    Fs("ImportDefaultSpecifier", e, t);
  }),
  (Ls.assertImportNamespaceSpecifier = function (e, t) {
    Fs("ImportNamespaceSpecifier", e, t);
  }),
  (Ls.assertImportOrExportDeclaration = function (e, t) {
    Fs("ImportOrExportDeclaration", e, t);
  }),
  (Ls.assertImportSpecifier = function (e, t) {
    Fs("ImportSpecifier", e, t);
  }),
  (Ls.assertIndexedAccessType = function (e, t) {
    Fs("IndexedAccessType", e, t);
  }),
  (Ls.assertInferredPredicate = function (e, t) {
    Fs("InferredPredicate", e, t);
  }),
  (Ls.assertInterfaceDeclaration = function (e, t) {
    Fs("InterfaceDeclaration", e, t);
  }),
  (Ls.assertInterfaceExtends = function (e, t) {
    Fs("InterfaceExtends", e, t);
  }),
  (Ls.assertInterfaceTypeAnnotation = function (e, t) {
    Fs("InterfaceTypeAnnotation", e, t);
  }),
  (Ls.assertInterpreterDirective = function (e, t) {
    Fs("InterpreterDirective", e, t);
  }),
  (Ls.assertIntersectionTypeAnnotation = function (e, t) {
    Fs("IntersectionTypeAnnotation", e, t);
  }),
  (Ls.assertJSX = function (e, t) {
    Fs("JSX", e, t);
  }),
  (Ls.assertJSXAttribute = function (e, t) {
    Fs("JSXAttribute", e, t);
  }),
  (Ls.assertJSXClosingElement = function (e, t) {
    Fs("JSXClosingElement", e, t);
  }),
  (Ls.assertJSXClosingFragment = function (e, t) {
    Fs("JSXClosingFragment", e, t);
  }),
  (Ls.assertJSXElement = function (e, t) {
    Fs("JSXElement", e, t);
  }),
  (Ls.assertJSXEmptyExpression = function (e, t) {
    Fs("JSXEmptyExpression", e, t);
  }),
  (Ls.assertJSXExpressionContainer = function (e, t) {
    Fs("JSXExpressionContainer", e, t);
  }),
  (Ls.assertJSXFragment = function (e, t) {
    Fs("JSXFragment", e, t);
  }),
  (Ls.assertJSXIdentifier = function (e, t) {
    Fs("JSXIdentifier", e, t);
  }),
  (Ls.assertJSXMemberExpression = function (e, t) {
    Fs("JSXMemberExpression", e, t);
  }),
  (Ls.assertJSXNamespacedName = function (e, t) {
    Fs("JSXNamespacedName", e, t);
  }),
  (Ls.assertJSXOpeningElement = function (e, t) {
    Fs("JSXOpeningElement", e, t);
  }),
  (Ls.assertJSXOpeningFragment = function (e, t) {
    Fs("JSXOpeningFragment", e, t);
  }),
  (Ls.assertJSXSpreadAttribute = function (e, t) {
    Fs("JSXSpreadAttribute", e, t);
  }),
  (Ls.assertJSXSpreadChild = function (e, t) {
    Fs("JSXSpreadChild", e, t);
  }),
  (Ls.assertJSXText = function (e, t) {
    Fs("JSXText", e, t);
  }),
  (Ls.assertLVal = function (e, t) {
    Fs("LVal", e, t);
  }),
  (Ls.assertLabeledStatement = function (e, t) {
    Fs("LabeledStatement", e, t);
  }),
  (Ls.assertLiteral = function (e, t) {
    Fs("Literal", e, t);
  }),
  (Ls.assertLogicalExpression = function (e, t) {
    Fs("LogicalExpression", e, t);
  }),
  (Ls.assertLoop = function (e, t) {
    Fs("Loop", e, t);
  }),
  (Ls.assertMemberExpression = function (e, t) {
    Fs("MemberExpression", e, t);
  }),
  (Ls.assertMetaProperty = function (e, t) {
    Fs("MetaProperty", e, t);
  }),
  (Ls.assertMethod = function (e, t) {
    Fs("Method", e, t);
  }),
  (Ls.assertMiscellaneous = function (e, t) {
    Fs("Miscellaneous", e, t);
  }),
  (Ls.assertMixedTypeAnnotation = function (e, t) {
    Fs("MixedTypeAnnotation", e, t);
  }),
  (Ls.assertModuleDeclaration = function (e, t) {
    (0, js.default)(
      "assertModuleDeclaration",
      "assertImportOrExportDeclaration"
    ),
      Fs("ModuleDeclaration", e, t);
  }),
  (Ls.assertModuleExpression = function (e, t) {
    Fs("ModuleExpression", e, t);
  }),
  (Ls.assertModuleSpecifier = function (e, t) {
    Fs("ModuleSpecifier", e, t);
  }),
  (Ls.assertNewExpression = function (e, t) {
    Fs("NewExpression", e, t);
  }),
  (Ls.assertNoop = function (e, t) {
    Fs("Noop", e, t);
  }),
  (Ls.assertNullLiteral = function (e, t) {
    Fs("NullLiteral", e, t);
  }),
  (Ls.assertNullLiteralTypeAnnotation = function (e, t) {
    Fs("NullLiteralTypeAnnotation", e, t);
  }),
  (Ls.assertNullableTypeAnnotation = function (e, t) {
    Fs("NullableTypeAnnotation", e, t);
  }),
  (Ls.assertNumberLiteral = function (e, t) {
    (0, js.default)("assertNumberLiteral", "assertNumericLiteral"),
      Fs("NumberLiteral", e, t);
  }),
  (Ls.assertNumberLiteralTypeAnnotation = function (e, t) {
    Fs("NumberLiteralTypeAnnotation", e, t);
  }),
  (Ls.assertNumberTypeAnnotation = function (e, t) {
    Fs("NumberTypeAnnotation", e, t);
  }),
  (Ls.assertNumericLiteral = function (e, t) {
    Fs("NumericLiteral", e, t);
  }),
  (Ls.assertObjectExpression = function (e, t) {
    Fs("ObjectExpression", e, t);
  }),
  (Ls.assertObjectMember = function (e, t) {
    Fs("ObjectMember", e, t);
  }),
  (Ls.assertObjectMethod = function (e, t) {
    Fs("ObjectMethod", e, t);
  }),
  (Ls.assertObjectPattern = function (e, t) {
    Fs("ObjectPattern", e, t);
  }),
  (Ls.assertObjectProperty = function (e, t) {
    Fs("ObjectProperty", e, t);
  }),
  (Ls.assertObjectTypeAnnotation = function (e, t) {
    Fs("ObjectTypeAnnotation", e, t);
  }),
  (Ls.assertObjectTypeCallProperty = function (e, t) {
    Fs("ObjectTypeCallProperty", e, t);
  }),
  (Ls.assertObjectTypeIndexer = function (e, t) {
    Fs("ObjectTypeIndexer", e, t);
  }),
  (Ls.assertObjectTypeInternalSlot = function (e, t) {
    Fs("ObjectTypeInternalSlot", e, t);
  }),
  (Ls.assertObjectTypeProperty = function (e, t) {
    Fs("ObjectTypeProperty", e, t);
  }),
  (Ls.assertObjectTypeSpreadProperty = function (e, t) {
    Fs("ObjectTypeSpreadProperty", e, t);
  }),
  (Ls.assertOpaqueType = function (e, t) {
    Fs("OpaqueType", e, t);
  }),
  (Ls.assertOptionalCallExpression = function (e, t) {
    Fs("OptionalCallExpression", e, t);
  }),
  (Ls.assertOptionalIndexedAccessType = function (e, t) {
    Fs("OptionalIndexedAccessType", e, t);
  }),
  (Ls.assertOptionalMemberExpression = function (e, t) {
    Fs("OptionalMemberExpression", e, t);
  }),
  (Ls.assertParenthesizedExpression = function (e, t) {
    Fs("ParenthesizedExpression", e, t);
  }),
  (Ls.assertPattern = function (e, t) {
    Fs("Pattern", e, t);
  }),
  (Ls.assertPatternLike = function (e, t) {
    Fs("PatternLike", e, t);
  }),
  (Ls.assertPipelineBareFunction = function (e, t) {
    Fs("PipelineBareFunction", e, t);
  }),
  (Ls.assertPipelinePrimaryTopicReference = function (e, t) {
    Fs("PipelinePrimaryTopicReference", e, t);
  }),
  (Ls.assertPipelineTopicExpression = function (e, t) {
    Fs("PipelineTopicExpression", e, t);
  }),
  (Ls.assertPlaceholder = function (e, t) {
    Fs("Placeholder", e, t);
  }),
  (Ls.assertPrivate = function (e, t) {
    Fs("Private", e, t);
  }),
  (Ls.assertPrivateName = function (e, t) {
    Fs("PrivateName", e, t);
  }),
  (Ls.assertProgram = function (e, t) {
    Fs("Program", e, t);
  }),
  (Ls.assertProperty = function (e, t) {
    Fs("Property", e, t);
  }),
  (Ls.assertPureish = function (e, t) {
    Fs("Pureish", e, t);
  }),
  (Ls.assertQualifiedTypeIdentifier = function (e, t) {
    Fs("QualifiedTypeIdentifier", e, t);
  }),
  (Ls.assertRecordExpression = function (e, t) {
    Fs("RecordExpression", e, t);
  }),
  (Ls.assertRegExpLiteral = function (e, t) {
    Fs("RegExpLiteral", e, t);
  }),
  (Ls.assertRegexLiteral = function (e, t) {
    (0, js.default)("assertRegexLiteral", "assertRegExpLiteral"),
      Fs("RegexLiteral", e, t);
  }),
  (Ls.assertRestElement = function (e, t) {
    Fs("RestElement", e, t);
  }),
  (Ls.assertRestProperty = function (e, t) {
    (0, js.default)("assertRestProperty", "assertRestElement"),
      Fs("RestProperty", e, t);
  }),
  (Ls.assertReturnStatement = function (e, t) {
    Fs("ReturnStatement", e, t);
  }),
  (Ls.assertScopable = function (e, t) {
    Fs("Scopable", e, t);
  }),
  (Ls.assertSequenceExpression = function (e, t) {
    Fs("SequenceExpression", e, t);
  }),
  (Ls.assertSpreadElement = function (e, t) {
    Fs("SpreadElement", e, t);
  }),
  (Ls.assertSpreadProperty = function (e, t) {
    (0, js.default)("assertSpreadProperty", "assertSpreadElement"),
      Fs("SpreadProperty", e, t);
  }),
  (Ls.assertStandardized = function (e, t) {
    Fs("Standardized", e, t);
  }),
  (Ls.assertStatement = function (e, t) {
    Fs("Statement", e, t);
  }),
  (Ls.assertStaticBlock = function (e, t) {
    Fs("StaticBlock", e, t);
  }),
  (Ls.assertStringLiteral = function (e, t) {
    Fs("StringLiteral", e, t);
  }),
  (Ls.assertStringLiteralTypeAnnotation = function (e, t) {
    Fs("StringLiteralTypeAnnotation", e, t);
  }),
  (Ls.assertStringTypeAnnotation = function (e, t) {
    Fs("StringTypeAnnotation", e, t);
  }),
  (Ls.assertSuper = function (e, t) {
    Fs("Super", e, t);
  }),
  (Ls.assertSwitchCase = function (e, t) {
    Fs("SwitchCase", e, t);
  }),
  (Ls.assertSwitchStatement = function (e, t) {
    Fs("SwitchStatement", e, t);
  }),
  (Ls.assertSymbolTypeAnnotation = function (e, t) {
    Fs("SymbolTypeAnnotation", e, t);
  }),
  (Ls.assertTSAnyKeyword = function (e, t) {
    Fs("TSAnyKeyword", e, t);
  }),
  (Ls.assertTSArrayType = function (e, t) {
    Fs("TSArrayType", e, t);
  }),
  (Ls.assertTSAsExpression = function (e, t) {
    Fs("TSAsExpression", e, t);
  }),
  (Ls.assertTSBaseType = function (e, t) {
    Fs("TSBaseType", e, t);
  }),
  (Ls.assertTSBigIntKeyword = function (e, t) {
    Fs("TSBigIntKeyword", e, t);
  }),
  (Ls.assertTSBooleanKeyword = function (e, t) {
    Fs("TSBooleanKeyword", e, t);
  }),
  (Ls.assertTSCallSignatureDeclaration = function (e, t) {
    Fs("TSCallSignatureDeclaration", e, t);
  }),
  (Ls.assertTSConditionalType = function (e, t) {
    Fs("TSConditionalType", e, t);
  }),
  (Ls.assertTSConstructSignatureDeclaration = function (e, t) {
    Fs("TSConstructSignatureDeclaration", e, t);
  }),
  (Ls.assertTSConstructorType = function (e, t) {
    Fs("TSConstructorType", e, t);
  }),
  (Ls.assertTSDeclareFunction = function (e, t) {
    Fs("TSDeclareFunction", e, t);
  }),
  (Ls.assertTSDeclareMethod = function (e, t) {
    Fs("TSDeclareMethod", e, t);
  }),
  (Ls.assertTSEntityName = function (e, t) {
    Fs("TSEntityName", e, t);
  }),
  (Ls.assertTSEnumDeclaration = function (e, t) {
    Fs("TSEnumDeclaration", e, t);
  }),
  (Ls.assertTSEnumMember = function (e, t) {
    Fs("TSEnumMember", e, t);
  }),
  (Ls.assertTSExportAssignment = function (e, t) {
    Fs("TSExportAssignment", e, t);
  }),
  (Ls.assertTSExpressionWithTypeArguments = function (e, t) {
    Fs("TSExpressionWithTypeArguments", e, t);
  }),
  (Ls.assertTSExternalModuleReference = function (e, t) {
    Fs("TSExternalModuleReference", e, t);
  }),
  (Ls.assertTSFunctionType = function (e, t) {
    Fs("TSFunctionType", e, t);
  }),
  (Ls.assertTSImportEqualsDeclaration = function (e, t) {
    Fs("TSImportEqualsDeclaration", e, t);
  }),
  (Ls.assertTSImportType = function (e, t) {
    Fs("TSImportType", e, t);
  }),
  (Ls.assertTSIndexSignature = function (e, t) {
    Fs("TSIndexSignature", e, t);
  }),
  (Ls.assertTSIndexedAccessType = function (e, t) {
    Fs("TSIndexedAccessType", e, t);
  }),
  (Ls.assertTSInferType = function (e, t) {
    Fs("TSInferType", e, t);
  }),
  (Ls.assertTSInstantiationExpression = function (e, t) {
    Fs("TSInstantiationExpression", e, t);
  }),
  (Ls.assertTSInterfaceBody = function (e, t) {
    Fs("TSInterfaceBody", e, t);
  }),
  (Ls.assertTSInterfaceDeclaration = function (e, t) {
    Fs("TSInterfaceDeclaration", e, t);
  }),
  (Ls.assertTSIntersectionType = function (e, t) {
    Fs("TSIntersectionType", e, t);
  }),
  (Ls.assertTSIntrinsicKeyword = function (e, t) {
    Fs("TSIntrinsicKeyword", e, t);
  }),
  (Ls.assertTSLiteralType = function (e, t) {
    Fs("TSLiteralType", e, t);
  }),
  (Ls.assertTSMappedType = function (e, t) {
    Fs("TSMappedType", e, t);
  }),
  (Ls.assertTSMethodSignature = function (e, t) {
    Fs("TSMethodSignature", e, t);
  }),
  (Ls.assertTSModuleBlock = function (e, t) {
    Fs("TSModuleBlock", e, t);
  }),
  (Ls.assertTSModuleDeclaration = function (e, t) {
    Fs("TSModuleDeclaration", e, t);
  }),
  (Ls.assertTSNamedTupleMember = function (e, t) {
    Fs("TSNamedTupleMember", e, t);
  }),
  (Ls.assertTSNamespaceExportDeclaration = function (e, t) {
    Fs("TSNamespaceExportDeclaration", e, t);
  }),
  (Ls.assertTSNeverKeyword = function (e, t) {
    Fs("TSNeverKeyword", e, t);
  }),
  (Ls.assertTSNonNullExpression = function (e, t) {
    Fs("TSNonNullExpression", e, t);
  }),
  (Ls.assertTSNullKeyword = function (e, t) {
    Fs("TSNullKeyword", e, t);
  }),
  (Ls.assertTSNumberKeyword = function (e, t) {
    Fs("TSNumberKeyword", e, t);
  }),
  (Ls.assertTSObjectKeyword = function (e, t) {
    Fs("TSObjectKeyword", e, t);
  }),
  (Ls.assertTSOptionalType = function (e, t) {
    Fs("TSOptionalType", e, t);
  }),
  (Ls.assertTSParameterProperty = function (e, t) {
    Fs("TSParameterProperty", e, t);
  }),
  (Ls.assertTSParenthesizedType = function (e, t) {
    Fs("TSParenthesizedType", e, t);
  }),
  (Ls.assertTSPropertySignature = function (e, t) {
    Fs("TSPropertySignature", e, t);
  }),
  (Ls.assertTSQualifiedName = function (e, t) {
    Fs("TSQualifiedName", e, t);
  }),
  (Ls.assertTSRestType = function (e, t) {
    Fs("TSRestType", e, t);
  }),
  (Ls.assertTSSatisfiesExpression = function (e, t) {
    Fs("TSSatisfiesExpression", e, t);
  }),
  (Ls.assertTSStringKeyword = function (e, t) {
    Fs("TSStringKeyword", e, t);
  }),
  (Ls.assertTSSymbolKeyword = function (e, t) {
    Fs("TSSymbolKeyword", e, t);
  }),
  (Ls.assertTSThisType = function (e, t) {
    Fs("TSThisType", e, t);
  }),
  (Ls.assertTSTupleType = function (e, t) {
    Fs("TSTupleType", e, t);
  }),
  (Ls.assertTSType = function (e, t) {
    Fs("TSType", e, t);
  }),
  (Ls.assertTSTypeAliasDeclaration = function (e, t) {
    Fs("TSTypeAliasDeclaration", e, t);
  }),
  (Ls.assertTSTypeAnnotation = function (e, t) {
    Fs("TSTypeAnnotation", e, t);
  }),
  (Ls.assertTSTypeAssertion = function (e, t) {
    Fs("TSTypeAssertion", e, t);
  }),
  (Ls.assertTSTypeElement = function (e, t) {
    Fs("TSTypeElement", e, t);
  }),
  (Ls.assertTSTypeLiteral = function (e, t) {
    Fs("TSTypeLiteral", e, t);
  }),
  (Ls.assertTSTypeOperator = function (e, t) {
    Fs("TSTypeOperator", e, t);
  }),
  (Ls.assertTSTypeParameter = function (e, t) {
    Fs("TSTypeParameter", e, t);
  }),
  (Ls.assertTSTypeParameterDeclaration = function (e, t) {
    Fs("TSTypeParameterDeclaration", e, t);
  }),
  (Ls.assertTSTypeParameterInstantiation = function (e, t) {
    Fs("TSTypeParameterInstantiation", e, t);
  }),
  (Ls.assertTSTypePredicate = function (e, t) {
    Fs("TSTypePredicate", e, t);
  }),
  (Ls.assertTSTypeQuery = function (e, t) {
    Fs("TSTypeQuery", e, t);
  }),
  (Ls.assertTSTypeReference = function (e, t) {
    Fs("TSTypeReference", e, t);
  }),
  (Ls.assertTSUndefinedKeyword = function (e, t) {
    Fs("TSUndefinedKeyword", e, t);
  }),
  (Ls.assertTSUnionType = function (e, t) {
    Fs("TSUnionType", e, t);
  }),
  (Ls.assertTSUnknownKeyword = function (e, t) {
    Fs("TSUnknownKeyword", e, t);
  }),
  (Ls.assertTSVoidKeyword = function (e, t) {
    Fs("TSVoidKeyword", e, t);
  }),
  (Ls.assertTaggedTemplateExpression = function (e, t) {
    Fs("TaggedTemplateExpression", e, t);
  }),
  (Ls.assertTemplateElement = function (e, t) {
    Fs("TemplateElement", e, t);
  }),
  (Ls.assertTemplateLiteral = function (e, t) {
    Fs("TemplateLiteral", e, t);
  }),
  (Ls.assertTerminatorless = function (e, t) {
    Fs("Terminatorless", e, t);
  }),
  (Ls.assertThisExpression = function (e, t) {
    Fs("ThisExpression", e, t);
  }),
  (Ls.assertThisTypeAnnotation = function (e, t) {
    Fs("ThisTypeAnnotation", e, t);
  }),
  (Ls.assertThrowStatement = function (e, t) {
    Fs("ThrowStatement", e, t);
  }),
  (Ls.assertTopicReference = function (e, t) {
    Fs("TopicReference", e, t);
  }),
  (Ls.assertTryStatement = function (e, t) {
    Fs("TryStatement", e, t);
  }),
  (Ls.assertTupleExpression = function (e, t) {
    Fs("TupleExpression", e, t);
  }),
  (Ls.assertTupleTypeAnnotation = function (e, t) {
    Fs("TupleTypeAnnotation", e, t);
  }),
  (Ls.assertTypeAlias = function (e, t) {
    Fs("TypeAlias", e, t);
  }),
  (Ls.assertTypeAnnotation = function (e, t) {
    Fs("TypeAnnotation", e, t);
  }),
  (Ls.assertTypeCastExpression = function (e, t) {
    Fs("TypeCastExpression", e, t);
  }),
  (Ls.assertTypeParameter = function (e, t) {
    Fs("TypeParameter", e, t);
  }),
  (Ls.assertTypeParameterDeclaration = function (e, t) {
    Fs("TypeParameterDeclaration", e, t);
  }),
  (Ls.assertTypeParameterInstantiation = function (e, t) {
    Fs("TypeParameterInstantiation", e, t);
  }),
  (Ls.assertTypeScript = function (e, t) {
    Fs("TypeScript", e, t);
  }),
  (Ls.assertTypeofTypeAnnotation = function (e, t) {
    Fs("TypeofTypeAnnotation", e, t);
  }),
  (Ls.assertUnaryExpression = function (e, t) {
    Fs("UnaryExpression", e, t);
  }),
  (Ls.assertUnaryLike = function (e, t) {
    Fs("UnaryLike", e, t);
  }),
  (Ls.assertUnionTypeAnnotation = function (e, t) {
    Fs("UnionTypeAnnotation", e, t);
  }),
  (Ls.assertUpdateExpression = function (e, t) {
    Fs("UpdateExpression", e, t);
  }),
  (Ls.assertUserWhitespacable = function (e, t) {
    Fs("UserWhitespacable", e, t);
  }),
  (Ls.assertV8IntrinsicIdentifier = function (e, t) {
    Fs("V8IntrinsicIdentifier", e, t);
  }),
  (Ls.assertVariableDeclaration = function (e, t) {
    Fs("VariableDeclaration", e, t);
  }),
  (Ls.assertVariableDeclarator = function (e, t) {
    Fs("VariableDeclarator", e, t);
  }),
  (Ls.assertVariance = function (e, t) {
    Fs("Variance", e, t);
  }),
  (Ls.assertVoidTypeAnnotation = function (e, t) {
    Fs("VoidTypeAnnotation", e, t);
  }),
  (Ls.assertWhile = function (e, t) {
    Fs("While", e, t);
  }),
  (Ls.assertWhileStatement = function (e, t) {
    Fs("WhileStatement", e, t);
  }),
  (Ls.assertWithStatement = function (e, t) {
    Fs("WithStatement", e, t);
  }),
  (Ls.assertYieldExpression = function (e, t) {
    Fs("YieldExpression", e, t);
  });
var Ms = pa(),
  js = Li;
function Fs(e, t, r) {
  if (!(0, Ms.default)(e, t, r))
    throw new Error(
      'Expected type "'
        .concat(e, '" with option ')
        .concat(JSON.stringify(r), ", ") +
        'but instead got "'.concat(t.type, '".')
    );
}
var Bs,
  Rs = {};
var Us = {},
  Vs = {};
function Ks(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Ws(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Ws(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Ws(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(Vs, "__esModule", { value: !0 }),
  (Vs.default = function e(t) {
    for (
      var r = Array.from(t),
        n = new Map(),
        i = new Map(),
        a = new Set(),
        s = [],
        o = 0;
      o < r.length;
      o++
    ) {
      var l = r[o];
      if (l && !(s.indexOf(l) >= 0)) {
        if ((0, Hs.isAnyTypeAnnotation)(l)) return [l];
        if ((0, Hs.isFlowBaseAnnotation)(l)) i.set(l.type, l);
        else if ((0, Hs.isUnionTypeAnnotation)(l))
          a.has(l.types) || (r.push.apply(r, K(l.types)), a.add(l.types));
        else if ((0, Hs.isGenericTypeAnnotation)(l)) {
          var u = Ys(l.id);
          if (n.has(u)) {
            var c,
              p = n.get(u);
            if (p.typeParameters) {
              if (l.typeParameters)
                (c = p.typeParameters.params).push.apply(
                  c,
                  K(l.typeParameters.params)
                ),
                  (p.typeParameters.params = e(p.typeParameters.params));
            } else p = l.typeParameters;
          } else n.set(u, l);
        } else s.push(l);
      }
    }
    var h,
      d = Ks(i);
    try {
      for (d.s(); !(h = d.n()).done; ) {
        var f = H(h.value, 2)[1];
        s.push(f);
      }
    } catch (e) {
      d.e(e);
    } finally {
      d.f();
    }
    var y,
      m = Ks(n);
    try {
      for (m.s(); !(y = m.n()).done; ) {
        var v = H(y.value, 2)[1];
        s.push(v);
      }
    } catch (e) {
      m.e(e);
    } finally {
      m.f();
    }
    return s;
  });
var qs,
  Hs = _i;
function Ys(e) {
  return (0, Hs.isIdentifier)(e)
    ? e.name
    : "".concat(e.id.name, ".").concat(Ys(e.qualification));
}
var Js = {},
  Xs = {};
function Gs(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return zs(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return zs(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function zs(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(Xs, "__esModule", { value: !0 }),
  (Xs.default = function e(t) {
    for (
      var r = Array.from(t),
        n = new Map(),
        i = new Map(),
        a = new Set(),
        s = [],
        o = 0;
      o < r.length;
      o++
    ) {
      var l = r[o];
      if (l && !(s.indexOf(l) >= 0)) {
        if ((0, Qs.isTSAnyKeyword)(l)) return [l];
        if ((0, Qs.isTSBaseType)(l)) i.set(l.type, l);
        else if ((0, Qs.isTSUnionType)(l))
          a.has(l.types) || (r.push.apply(r, K(l.types)), a.add(l.types));
        else if ((0, Qs.isTSTypeReference)(l) && l.typeParameters) {
          var u = Zs(l.typeName);
          if (n.has(u)) {
            var c,
              p = n.get(u);
            if (p.typeParameters) {
              if (l.typeParameters)
                (c = p.typeParameters.params).push.apply(
                  c,
                  K(l.typeParameters.params)
                ),
                  (p.typeParameters.params = e(p.typeParameters.params));
            } else p = l.typeParameters;
          } else n.set(u, l);
        } else s.push(l);
      }
    }
    var h,
      d = Gs(i);
    try {
      for (d.s(); !(h = d.n()).done; ) {
        var f = H(h.value, 2)[1];
        s.push(f);
      }
    } catch (e) {
      d.e(e);
    } finally {
      d.f();
    }
    var y,
      m = Gs(n);
    try {
      for (m.s(); !(y = m.n()).done; ) {
        var v = H(y.value, 2)[1];
        s.push(v);
      }
    } catch (e) {
      m.e(e);
    } finally {
      m.f();
    }
    return s;
  });
var $s,
  Qs = _i;
function Zs(e) {
  return (0, Qs.isIdentifier)(e)
    ? e.name
    : "".concat(e.right.name, ".").concat(Zs(e.left));
}
var eo,
  to = {};
var ro = {};
Object.defineProperty(ro, "__esModule", { value: !0 }),
  (ro.default = function (e) {
    var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
      r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    return lo(e, t, r, new Map());
  });
var no = Ps(),
  io = _i,
  ao = Function.call.bind(Object.prototype.hasOwnProperty);
function so(e, t, r, n) {
  return e && "string" == typeof e.type ? lo(e, t, r, n) : e;
}
function oo(e, t, r, n) {
  return Array.isArray(e)
    ? e.map(function (e) {
        return so(e, t, r, n);
      })
    : so(e, t, r, n);
}
function lo(e) {
  var t = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
    r = arguments.length > 2 && void 0 !== arguments[2] && arguments[2],
    n = arguments.length > 3 ? arguments[3] : void 0;
  if (!e) return e;
  var i = e.type,
    a = { type: e.type };
  if ((0, io.isIdentifier)(e))
    (a.name = e.name),
      ao(e, "optional") &&
        "boolean" == typeof e.optional &&
        (a.optional = e.optional),
      ao(e, "typeAnnotation") &&
        (a.typeAnnotation = t
          ? oo(e.typeAnnotation, !0, r, n)
          : e.typeAnnotation);
  else {
    if (!ao(no.NODE_FIELDS, i))
      throw new Error('Unknown node type: "'.concat(i, '"'));
    for (var s = 0, o = Object.keys(no.NODE_FIELDS[i]); s < o.length; s++) {
      var l = o[s];
      ao(e, l) &&
        (a[l] = t
          ? (0, io.isFile)(e) && "comments" === l
            ? uo(e.comments, t, r, n)
            : oo(e[l], !0, r, n)
          : e[l]);
    }
  }
  return (
    ao(e, "loc") && (a.loc = r ? null : e.loc),
    ao(e, "leadingComments") &&
      (a.leadingComments = uo(e.leadingComments, t, r, n)),
    ao(e, "innerComments") && (a.innerComments = uo(e.innerComments, t, r, n)),
    ao(e, "trailingComments") &&
      (a.trailingComments = uo(e.trailingComments, t, r, n)),
    ao(e, "extra") && (a.extra = Object.assign({}, e.extra)),
    a
  );
}
function uo(e, t, r, n) {
  return e && t
    ? e.map(function (e) {
        var t = n.get(e);
        if (t) return t;
        var i = { type: e.type, value: e.value, loc: e.loc };
        return r && (i.loc = null), n.set(e, i), i;
      })
    : e;
}
var co = {};
Object.defineProperty(co, "__esModule", { value: !0 }),
  (co.default = function (e) {
    return (0, po.default)(e, !1);
  });
var po = ro;
var ho = {};
Object.defineProperty(ho, "__esModule", { value: !0 }),
  (ho.default = function (e) {
    return (0, fo.default)(e);
  });
var fo = ro;
var yo = {};
Object.defineProperty(yo, "__esModule", { value: !0 }),
  (yo.default = function (e) {
    return (0, mo.default)(e, !0, !0);
  });
var mo = ro;
var vo = {};
Object.defineProperty(vo, "__esModule", { value: !0 }),
  (vo.default = function (e) {
    return (0, go.default)(e, !1, !0);
  });
var go = ro;
var bo = {},
  To = {};
Object.defineProperty(To, "__esModule", { value: !0 }),
  (To.default = function (e, t, r) {
    if (!r || !e) return e;
    var n = "".concat(t, "Comments");
    if (e[n]) {
      var i;
      if ("leading" === t) e[n] = r.concat(e[n]);
      else (i = e[n]).push.apply(i, K(r));
    } else e[n] = r;
    return e;
  }),
  Object.defineProperty(bo, "__esModule", { value: !0 }),
  (bo.default = function (e, t, r, n) {
    return (0, So.default)(e, t, [
      { type: n ? "CommentLine" : "CommentBlock", value: r },
    ]);
  });
var So = To;
var xo = {},
  Eo = {};
Object.defineProperty(Eo, "__esModule", { value: !0 }),
  (Eo.default = function (e, t, r) {
    t &&
      r &&
      (t[e] = Array.from(new Set([].concat(t[e], r[e]).filter(Boolean))));
  }),
  Object.defineProperty(xo, "__esModule", { value: !0 }),
  (xo.default = function (e, t) {
    (0, Po.default)("innerComments", e, t);
  });
var Po = Eo;
var Ao = {};
Object.defineProperty(Ao, "__esModule", { value: !0 }),
  (Ao.default = function (e, t) {
    (0, ko.default)("leadingComments", e, t);
  });
var ko = Eo;
var wo = {},
  Co = {};
Object.defineProperty(Co, "__esModule", { value: !0 }),
  (Co.default = function (e, t) {
    (0, Io.default)("trailingComments", e, t);
  });
var Io = Eo;
Object.defineProperty(wo, "__esModule", { value: !0 }),
  (wo.default = function (e, t) {
    return (
      (0, Oo.default)(e, t), (0, No.default)(e, t), (0, _o.default)(e, t), e
    );
  });
var Oo = Co,
  No = Ao,
  _o = xo;
var Do = {};
Object.defineProperty(Do, "__esModule", { value: !0 }),
  (Do.default = function (e) {
    return (
      Lo.COMMENT_KEYS.forEach(function (t) {
        e[t] = null;
      }),
      e
    );
  });
var Lo = ja;
var Mo = {};
Object.defineProperty(Mo, "__esModule", { value: !0 }),
  (Mo.WHILE_TYPES =
    Mo.USERWHITESPACABLE_TYPES =
    Mo.UNARYLIKE_TYPES =
    Mo.TYPESCRIPT_TYPES =
    Mo.TSTYPE_TYPES =
    Mo.TSTYPEELEMENT_TYPES =
    Mo.TSENTITYNAME_TYPES =
    Mo.TSBASETYPE_TYPES =
    Mo.TERMINATORLESS_TYPES =
    Mo.STATEMENT_TYPES =
    Mo.STANDARDIZED_TYPES =
    Mo.SCOPABLE_TYPES =
    Mo.PUREISH_TYPES =
    Mo.PROPERTY_TYPES =
    Mo.PRIVATE_TYPES =
    Mo.PATTERN_TYPES =
    Mo.PATTERNLIKE_TYPES =
    Mo.OBJECTMEMBER_TYPES =
    Mo.MODULESPECIFIER_TYPES =
    Mo.MODULEDECLARATION_TYPES =
    Mo.MISCELLANEOUS_TYPES =
    Mo.METHOD_TYPES =
    Mo.LVAL_TYPES =
    Mo.LOOP_TYPES =
    Mo.LITERAL_TYPES =
    Mo.JSX_TYPES =
    Mo.IMPORTOREXPORTDECLARATION_TYPES =
    Mo.IMMUTABLE_TYPES =
    Mo.FUNCTION_TYPES =
    Mo.FUNCTIONPARENT_TYPES =
    Mo.FOR_TYPES =
    Mo.FORXSTATEMENT_TYPES =
    Mo.FLOW_TYPES =
    Mo.FLOWTYPE_TYPES =
    Mo.FLOWPREDICATE_TYPES =
    Mo.FLOWDECLARATION_TYPES =
    Mo.FLOWBASEANNOTATION_TYPES =
    Mo.EXPRESSION_TYPES =
    Mo.EXPRESSIONWRAPPER_TYPES =
    Mo.EXPORTDECLARATION_TYPES =
    Mo.ENUMMEMBER_TYPES =
    Mo.ENUMBODY_TYPES =
    Mo.DECLARATION_TYPES =
    Mo.CONDITIONAL_TYPES =
    Mo.COMPLETIONSTATEMENT_TYPES =
    Mo.CLASS_TYPES =
    Mo.BLOCK_TYPES =
    Mo.BLOCKPARENT_TYPES =
    Mo.BINARY_TYPES =
    Mo.ACCESSOR_TYPES =
      void 0);
var jo = Ps(),
  Fo = jo.FLIPPED_ALIAS_KEYS.Standardized;
Mo.STANDARDIZED_TYPES = Fo;
var Bo = jo.FLIPPED_ALIAS_KEYS.Expression;
Mo.EXPRESSION_TYPES = Bo;
var Ro = jo.FLIPPED_ALIAS_KEYS.Binary;
Mo.BINARY_TYPES = Ro;
var Uo = jo.FLIPPED_ALIAS_KEYS.Scopable;
Mo.SCOPABLE_TYPES = Uo;
var Vo = jo.FLIPPED_ALIAS_KEYS.BlockParent;
Mo.BLOCKPARENT_TYPES = Vo;
var Ko = jo.FLIPPED_ALIAS_KEYS.Block;
Mo.BLOCK_TYPES = Ko;
var Wo = jo.FLIPPED_ALIAS_KEYS.Statement;
Mo.STATEMENT_TYPES = Wo;
var qo = jo.FLIPPED_ALIAS_KEYS.Terminatorless;
Mo.TERMINATORLESS_TYPES = qo;
var Ho = jo.FLIPPED_ALIAS_KEYS.CompletionStatement;
Mo.COMPLETIONSTATEMENT_TYPES = Ho;
var Yo = jo.FLIPPED_ALIAS_KEYS.Conditional;
Mo.CONDITIONAL_TYPES = Yo;
var Jo = jo.FLIPPED_ALIAS_KEYS.Loop;
Mo.LOOP_TYPES = Jo;
var Xo = jo.FLIPPED_ALIAS_KEYS.While;
Mo.WHILE_TYPES = Xo;
var Go = jo.FLIPPED_ALIAS_KEYS.ExpressionWrapper;
Mo.EXPRESSIONWRAPPER_TYPES = Go;
var zo = jo.FLIPPED_ALIAS_KEYS.For;
Mo.FOR_TYPES = zo;
var $o = jo.FLIPPED_ALIAS_KEYS.ForXStatement;
Mo.FORXSTATEMENT_TYPES = $o;
var Qo = jo.FLIPPED_ALIAS_KEYS.Function;
Mo.FUNCTION_TYPES = Qo;
var Zo = jo.FLIPPED_ALIAS_KEYS.FunctionParent;
Mo.FUNCTIONPARENT_TYPES = Zo;
var el = jo.FLIPPED_ALIAS_KEYS.Pureish;
Mo.PUREISH_TYPES = el;
var tl = jo.FLIPPED_ALIAS_KEYS.Declaration;
Mo.DECLARATION_TYPES = tl;
var rl = jo.FLIPPED_ALIAS_KEYS.PatternLike;
Mo.PATTERNLIKE_TYPES = rl;
var nl = jo.FLIPPED_ALIAS_KEYS.LVal;
Mo.LVAL_TYPES = nl;
var il = jo.FLIPPED_ALIAS_KEYS.TSEntityName;
Mo.TSENTITYNAME_TYPES = il;
var al = jo.FLIPPED_ALIAS_KEYS.Literal;
Mo.LITERAL_TYPES = al;
var sl = jo.FLIPPED_ALIAS_KEYS.Immutable;
Mo.IMMUTABLE_TYPES = sl;
var ol = jo.FLIPPED_ALIAS_KEYS.UserWhitespacable;
Mo.USERWHITESPACABLE_TYPES = ol;
var ll = jo.FLIPPED_ALIAS_KEYS.Method;
Mo.METHOD_TYPES = ll;
var ul = jo.FLIPPED_ALIAS_KEYS.ObjectMember;
Mo.OBJECTMEMBER_TYPES = ul;
var cl = jo.FLIPPED_ALIAS_KEYS.Property;
Mo.PROPERTY_TYPES = cl;
var pl = jo.FLIPPED_ALIAS_KEYS.UnaryLike;
Mo.UNARYLIKE_TYPES = pl;
var hl = jo.FLIPPED_ALIAS_KEYS.Pattern;
Mo.PATTERN_TYPES = hl;
var dl = jo.FLIPPED_ALIAS_KEYS.Class;
Mo.CLASS_TYPES = dl;
var fl = jo.FLIPPED_ALIAS_KEYS.ImportOrExportDeclaration;
Mo.IMPORTOREXPORTDECLARATION_TYPES = fl;
var yl = jo.FLIPPED_ALIAS_KEYS.ExportDeclaration;
Mo.EXPORTDECLARATION_TYPES = yl;
var ml = jo.FLIPPED_ALIAS_KEYS.ModuleSpecifier;
Mo.MODULESPECIFIER_TYPES = ml;
var vl = jo.FLIPPED_ALIAS_KEYS.Accessor;
Mo.ACCESSOR_TYPES = vl;
var gl = jo.FLIPPED_ALIAS_KEYS.Private;
Mo.PRIVATE_TYPES = gl;
var bl = jo.FLIPPED_ALIAS_KEYS.Flow;
Mo.FLOW_TYPES = bl;
var Tl = jo.FLIPPED_ALIAS_KEYS.FlowType;
Mo.FLOWTYPE_TYPES = Tl;
var Sl = jo.FLIPPED_ALIAS_KEYS.FlowBaseAnnotation;
Mo.FLOWBASEANNOTATION_TYPES = Sl;
var xl = jo.FLIPPED_ALIAS_KEYS.FlowDeclaration;
Mo.FLOWDECLARATION_TYPES = xl;
var El = jo.FLIPPED_ALIAS_KEYS.FlowPredicate;
Mo.FLOWPREDICATE_TYPES = El;
var Pl = jo.FLIPPED_ALIAS_KEYS.EnumBody;
Mo.ENUMBODY_TYPES = Pl;
var Al = jo.FLIPPED_ALIAS_KEYS.EnumMember;
Mo.ENUMMEMBER_TYPES = Al;
var kl = jo.FLIPPED_ALIAS_KEYS.JSX;
Mo.JSX_TYPES = kl;
var wl = jo.FLIPPED_ALIAS_KEYS.Miscellaneous;
Mo.MISCELLANEOUS_TYPES = wl;
var Cl = jo.FLIPPED_ALIAS_KEYS.TypeScript;
Mo.TYPESCRIPT_TYPES = Cl;
var Il = jo.FLIPPED_ALIAS_KEYS.TSTypeElement;
Mo.TSTYPEELEMENT_TYPES = Il;
var Ol = jo.FLIPPED_ALIAS_KEYS.TSType;
Mo.TSTYPE_TYPES = Ol;
var Nl = jo.FLIPPED_ALIAS_KEYS.TSBaseType;
Mo.TSBASETYPE_TYPES = Nl;
var _l = fl;
Mo.MODULEDECLARATION_TYPES = _l;
var Dl,
  Ll,
  Ml = {},
  jl = {};
function Fl() {
  if (Dl) return jl;
  (Dl = 1),
    Object.defineProperty(jl, "__esModule", { value: !0 }),
    (jl.default = function (r, n) {
      if ((0, e.isBlockStatement)(r)) return r;
      var i = [];
      (0, e.isEmptyStatement)(r)
        ? (i = [])
        : ((0, e.isStatement)(r) ||
            (r = (0, e.isFunction)(n)
              ? (0, t.returnStatement)(r)
              : (0, t.expressionStatement)(r)),
          (i = [r]));
      return (0, t.blockStatement)(i);
    });
  var e = _i,
    t = Cs();
  return jl;
}
var Bl = {},
  Rl = {};
function Ul(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Vl(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Vl(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Vl(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(Rl, "__esModule", { value: !0 }),
  (Rl.default = function (e) {
    var t,
      r = "",
      n = Ul((e += ""));
    try {
      for (n.s(); !(t = n.n()).done; ) {
        var i = t.value;
        r += (0, Wl.isIdentifierChar)(i.codePointAt(0)) ? i : "-";
      }
    } catch (e) {
      n.e(e);
    } finally {
      n.f();
    }
    (r = (r = r.replace(/^[-0-9]+/, "")).replace(
      /[-\s]+(.)?/g,
      function (e, t) {
        return t ? t.toUpperCase() : "";
      }
    )),
      (0, Kl.default)(r) || (r = "_".concat(r));
    return r || "_";
  });
var Kl = ha,
  Wl = da;
Object.defineProperty(Bl, "__esModule", { value: !0 }),
  (Bl.default = function (e) {
    ("eval" !== (e = (0, ql.default)(e)) && "arguments" !== e) || (e = "_" + e);
    return e;
  });
var ql = Rl;
var Hl,
  Yl = {};
var Jl = {};
Object.defineProperty(Jl, "__esModule", { value: !0 }), (Jl.default = void 0);
var Xl = _i,
  Gl = function (e) {
    (0, Xl.isExpressionStatement)(e) && (e = e.expression);
    if ((0, Xl.isExpression)(e)) return e;
    (0, Xl.isClass)(e)
      ? (e.type = "ClassExpression")
      : (0, Xl.isFunction)(e) && (e.type = "FunctionExpression");
    if (!(0, Xl.isExpression)(e))
      throw new Error("cannot turn ".concat(e.type, " to an expression"));
    return e;
  };
Jl.default = Gl;
var zl = {},
  $l = {},
  Ql = {};
function Zl(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return eu(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return eu(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function eu(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(Ql, "__esModule", { value: !0 }),
  (Ql.default = function e(t, r, n) {
    if (!t) return;
    var i = tu.VISITOR_KEYS[t.type];
    if (!i) return;
    r(t, (n = n || {}));
    var a,
      s = Zl(i);
    try {
      for (s.s(); !(a = s.n()).done; ) {
        var o = t[a.value];
        if (Array.isArray(o)) {
          var l,
            u = Zl(o);
          try {
            for (u.s(); !(l = u.n()).done; ) {
              var c = l.value;
              e(c, r, n);
            }
          } catch (e) {
            u.e(e);
          } finally {
            u.f();
          }
        } else e(o, r, n);
      }
    } catch (e) {
      s.e(e);
    } finally {
      s.f();
    }
  });
var tu = Ps();
var ru = {};
function nu(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return iu(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return iu(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function iu(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(ru, "__esModule", { value: !0 }),
  (ru.default = function (e) {
    var t,
      r = nu(
        (arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {})
          .preserveComments
          ? au
          : su
      );
    try {
      for (r.s(); !(t = r.n()).done; ) {
        var n = t.value;
        null != e[n] && (e[n] = void 0);
      }
    } catch (e) {
      r.e(e);
    } finally {
      r.f();
    }
    for (var i = 0, a = Object.keys(e); i < a.length; i++) {
      var s = a[i];
      "_" === s[0] && null != e[s] && (e[s] = void 0);
    }
    var o,
      l = Object.getOwnPropertySymbols(e),
      u = nu(l);
    try {
      for (u.s(); !(o = u.n()).done; ) {
        e[o.value] = null;
      }
    } catch (e) {
      u.e(e);
    } finally {
      u.f();
    }
  });
var au = ["tokens", "start", "end", "loc", "raw", "rawValue"],
  su = [].concat(K(ja.COMMENT_KEYS), ["comments"], au);
Object.defineProperty($l, "__esModule", { value: !0 }),
  ($l.default = function (e, t) {
    return (0, ou.default)(e, lu.default, t), e;
  });
var ou = Ql,
  lu = ru;
Object.defineProperty(zl, "__esModule", { value: !0 }), (zl.default = hu);
var uu = _i,
  cu = ro,
  pu = $l;
function hu(e) {
  var t,
    r = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : e.key;
  return "method" === e.kind
    ? hu.increment() + ""
    : ((t = (0, uu.isIdentifier)(r)
        ? r.name
        : (0, uu.isStringLiteral)(r)
        ? JSON.stringify(r.value)
        : JSON.stringify((0, pu.default)((0, cu.default)(r)))),
      e.computed && (t = "[".concat(t, "]")),
      e.static && (t = "static:".concat(t)),
      t);
}
(hu.uid = 0),
  (hu.increment = function () {
    return hu.uid >= Number.MAX_SAFE_INTEGER ? (hu.uid = 0) : hu.uid++;
  });
var du = {},
  fu = {},
  yu = {};
Object.defineProperty(yu, "__esModule", { value: !0 }), (yu.default = bu);
var mu,
  vu,
  gu = _i;
function bu(e, t, r) {
  for (var n = [].concat(e), i = Object.create(null); n.length; ) {
    var a = n.shift();
    if (a) {
      var s = bu.keys[a.type];
      if ((0, gu.isIdentifier)(a))
        t ? (i[a.name] = i[a.name] || []).push(a) : (i[a.name] = a);
      else if (
        !(0, gu.isExportDeclaration)(a) ||
        (0, gu.isExportAllDeclaration)(a)
      ) {
        if (r) {
          if ((0, gu.isFunctionDeclaration)(a)) {
            n.push(a.id);
            continue;
          }
          if ((0, gu.isFunctionExpression)(a)) continue;
        }
        if (s)
          for (var o = 0; o < s.length; o++) {
            var l = a[s[o]];
            l && (Array.isArray(l) ? n.push.apply(n, K(l)) : n.push(l));
          }
      } else (0, gu.isDeclaration)(a.declaration) && n.push(a.declaration);
    }
  }
  return i;
}
function Tu(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Su(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Su(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Su(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function xu() {
  if (vu) return du;
  (vu = 1),
    Object.defineProperty(du, "__esModule", { value: !0 }),
    (du.default = function (t, r) {
      if (null == t || !t.length) return;
      var n = [],
        i = (0, e.default)(t, r, n);
      if (!i) return;
      for (var a = 0, s = n; a < s.length; a++) {
        var o = s[a];
        r.push(o);
      }
      return i;
    });
  var e = (function () {
    if (mu) return fu;
    (mu = 1),
      Object.defineProperty(fu, "__esModule", { value: !0 }),
      (fu.default = function i(a, s, o) {
        var l,
          u = [],
          c = !0,
          p = Tu(a);
        try {
          for (p.s(); !(l = p.n()).done; ) {
            var h = l.value;
            if (
              ((0, t.isEmptyStatement)(h) || (c = !1), (0, t.isExpression)(h))
            )
              u.push(h);
            else if ((0, t.isExpressionStatement)(h)) u.push(h.expression);
            else if ((0, t.isVariableDeclaration)(h)) {
              if ("var" !== h.kind) return;
              var d,
                f = Tu(h.declarations);
              try {
                for (f.s(); !(d = f.n()).done; ) {
                  for (
                    var y = d.value,
                      m = (0, e.default)(y),
                      v = 0,
                      g = Object.keys(m);
                    v < g.length;
                    v++
                  ) {
                    var b = g[v];
                    o.push({ kind: h.kind, id: (0, n.default)(m[b]) });
                  }
                  y.init &&
                    u.push((0, r.assignmentExpression)("=", y.id, y.init));
                }
              } catch (e) {
                f.e(e);
              } finally {
                f.f();
              }
              c = !0;
            } else if ((0, t.isIfStatement)(h)) {
              var T = h.consequent
                  ? i([h.consequent], s, o)
                  : s.buildUndefinedNode(),
                S = h.alternate
                  ? i([h.alternate], s, o)
                  : s.buildUndefinedNode();
              if (!T || !S) return;
              u.push((0, r.conditionalExpression)(h.test, T, S));
            } else if ((0, t.isBlockStatement)(h)) {
              var x = i(h.body, s, o);
              if (!x) return;
              u.push(x);
            } else {
              if (!(0, t.isEmptyStatement)(h)) return;
              0 === a.indexOf(h) && (c = !0);
            }
          }
        } catch (e) {
          p.e(e);
        } finally {
          p.f();
        }
        return (
          c && u.push(s.buildUndefinedNode()),
          1 === u.length ? u[0] : (0, r.sequenceExpression)(u)
        );
      });
    var e = yu,
      t = _i,
      r = Cs(),
      n = ro;
    return fu;
  })();
  return du;
}
bu.keys = {
  DeclareClass: ["id"],
  DeclareFunction: ["id"],
  DeclareModule: ["id"],
  DeclareVariable: ["id"],
  DeclareInterface: ["id"],
  DeclareTypeAlias: ["id"],
  DeclareOpaqueType: ["id"],
  InterfaceDeclaration: ["id"],
  TypeAlias: ["id"],
  OpaqueType: ["id"],
  CatchClause: ["param"],
  LabeledStatement: ["label"],
  UnaryExpression: ["argument"],
  AssignmentExpression: ["left"],
  ImportSpecifier: ["local"],
  ImportNamespaceSpecifier: ["local"],
  ImportDefaultSpecifier: ["local"],
  ImportDeclaration: ["specifiers"],
  ExportSpecifier: ["exported"],
  ExportNamespaceSpecifier: ["exported"],
  ExportDefaultSpecifier: ["exported"],
  FunctionDeclaration: ["id", "params"],
  FunctionExpression: ["id", "params"],
  ArrowFunctionExpression: ["params"],
  ObjectMethod: ["params"],
  ClassMethod: ["params"],
  ClassPrivateMethod: ["params"],
  ForInStatement: ["left"],
  ForOfStatement: ["left"],
  ClassDeclaration: ["id"],
  ClassExpression: ["id"],
  RestElement: ["argument"],
  UpdateExpression: ["argument"],
  ObjectProperty: ["value"],
  AssignmentPattern: ["left"],
  ArrayPattern: ["elements"],
  ObjectPattern: ["properties"],
  VariableDeclaration: ["declarations"],
  VariableDeclarator: ["id"],
};
var Eu,
  Pu = {};
var Au,
  ku = {};
function wu() {
  if (Au) return ku;
  (Au = 1),
    Object.defineProperty(ku, "__esModule", { value: !0 }),
    (ku.default = void 0);
  var e = ha,
    t = Cs(),
    r = function r(i) {
      if (void 0 === i) return (0, t.identifier)("undefined");
      if (!0 === i || !1 === i) return (0, t.booleanLiteral)(i);
      if (null === i) return (0, t.nullLiteral)();
      if ("string" == typeof i) return (0, t.stringLiteral)(i);
      if ("number" == typeof i) {
        var a, s;
        if (Number.isFinite(i)) a = (0, t.numericLiteral)(Math.abs(i));
        else
          (s = Number.isNaN(i)
            ? (0, t.numericLiteral)(0)
            : (0, t.numericLiteral)(1)),
            (a = (0, t.binaryExpression)("/", s, (0, t.numericLiteral)(0)));
        return (
          (i < 0 || Object.is(i, -0)) && (a = (0, t.unaryExpression)("-", a)), a
        );
      }
      if (
        (function (e) {
          return "[object RegExp]" === n(e);
        })(i)
      ) {
        var o = i.source,
          l = i.toString().match(/\/([a-z]+|)$/)[1];
        return (0, t.regExpLiteral)(o, l);
      }
      if (Array.isArray(i)) return (0, t.arrayExpression)(i.map(r));
      if (
        (function (e) {
          if (
            "object" !== g(e) ||
            null === e ||
            "[object Object]" !== Object.prototype.toString.call(e)
          )
            return !1;
          var t = Object.getPrototypeOf(e);
          return null === t || null === Object.getPrototypeOf(t);
        })(i)
      ) {
        for (var u = [], c = 0, p = Object.keys(i); c < p.length; c++) {
          var h = p[c],
            d = void 0;
          (d = (0, e.default)(h)
            ? (0, t.identifier)(h)
            : (0, t.stringLiteral)(h)),
            u.push((0, t.objectProperty)(d, r(i[h])));
        }
        return (0, t.objectExpression)(u);
      }
      throw new Error("don't know how to turn this value into a node");
    };
  ku.default = r;
  var n = Function.call.bind(Object.prototype.toString);
  return ku;
}
var Cu,
  Iu = {};
var Ou = {};
function Nu(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return _u(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return _u(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function _u(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(Ou, "__esModule", { value: !0 }),
  (Ou.default = function (e, t) {
    if (!e || !t) return e;
    var r,
      n = Nu(Du.INHERIT_KEYS.optional);
    try {
      for (n.s(); !(r = n.n()).done; ) {
        var i = r.value;
        null == e[i] && (e[i] = t[i]);
      }
    } catch (e) {
      n.e(e);
    } finally {
      n.f();
    }
    for (var a = 0, s = Object.keys(t); a < s.length; a++) {
      var o = s[a];
      "_" === o[0] && "__clone" !== o && (e[o] = t[o]);
    }
    var l,
      u = Nu(Du.INHERIT_KEYS.force);
    try {
      for (u.s(); !(l = u.n()).done; ) {
        var c = l.value;
        e[c] = t[c];
      }
    } catch (e) {
      u.e(e);
    } finally {
      u.f();
    }
    return (0, Lu.default)(e, t), e;
  });
var Du = ja,
  Lu = wo;
var Mu,
  ju = {};
var Fu = {};
Object.defineProperty(Fu, "__esModule", { value: !0 }), (Fu.default = void 0);
var Bu = yu,
  Ru = function (e, t) {
    return (0, Bu.default)(e, t, !0);
  };
Fu.default = Ru;
var Uu = {};
function Vu(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Ku(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Ku(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Ku(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(Uu, "__esModule", { value: !0 }),
  (Uu.default = function (e, t, r) {
    "function" == typeof t && (t = { enter: t });
    var n = t,
      i = n.enter,
      a = n.exit;
    qu(e, i, a, r, []);
  });
var Wu = Ps();
function qu(e, t, r, n, i) {
  var a = Wu.VISITOR_KEYS[e.type];
  if (a) {
    t && t(e, i, n);
    var s,
      o = Vu(a);
    try {
      for (o.s(); !(s = o.n()).done; ) {
        var l = s.value,
          u = e[l];
        if (Array.isArray(u))
          for (var c = 0; c < u.length; c++) {
            var p = u[c];
            p &&
              (i.push({ node: e, key: l, index: c }),
              qu(p, t, r, n, i),
              i.pop());
          }
        else u && (i.push({ node: e, key: l }), qu(u, t, r, n, i), i.pop());
      }
    } catch (e) {
      o.e(e);
    } finally {
      o.f();
    }
    r && r(e, i, n);
  }
}
var Hu = {};
Object.defineProperty(Hu, "__esModule", { value: !0 }),
  (Hu.default = function (e, t, r) {
    if (
      r &&
      "Identifier" === e.type &&
      "ObjectProperty" === t.type &&
      "ObjectExpression" === r.type
    )
      return !1;
    var n = Yu.default.keys[t.type];
    if (n)
      for (var i = 0; i < n.length; i++) {
        var a = t[n[i]];
        if (Array.isArray(a)) {
          if (a.indexOf(e) >= 0) return !0;
        } else if (a === e) return !0;
      }
    return !1;
  });
var Yu = yu;
var Ju = {},
  Xu = {};
Object.defineProperty(Xu, "__esModule", { value: !0 }),
  (Xu.default = function (e) {
    return (
      (0, Gu.isVariableDeclaration)(e) &&
      ("var" !== e.kind || e[zu.BLOCK_SCOPED_SYMBOL])
    );
  });
var Gu = _i,
  zu = ja;
Object.defineProperty(Ju, "__esModule", { value: !0 }),
  (Ju.default = function (e) {
    return (
      (0, $u.isFunctionDeclaration)(e) ||
      (0, $u.isClassDeclaration)(e) ||
      (0, Qu.default)(e)
    );
  });
var $u = _i,
  Qu = Xu;
var Zu = {};
Object.defineProperty(Zu, "__esModule", { value: !0 }),
  (Zu.default = function (e) {
    if ((0, ec.default)(e.type, "Immutable")) return !0;
    if ((0, tc.isIdentifier)(e)) return "undefined" === e.name;
    return !1;
  });
var ec = ia(),
  tc = _i;
var rc = {};
Object.defineProperty(rc, "__esModule", { value: !0 }),
  (rc.default = function e(t, r) {
    if ("object" !== g(t) || "object" !== g(r) || null == t || null == r)
      return t === r;
    if (t.type !== r.type) return !1;
    for (
      var n = Object.keys(nc.NODE_FIELDS[t.type] || t.type),
        i = nc.VISITOR_KEYS[t.type],
        a = 0,
        s = n;
      a < s.length;
      a++
    ) {
      var o = s[a],
        l = t[o],
        u = r[o];
      if (g(l) !== g(u)) return !1;
      if (null != l || null != u) {
        if (null == l || null == u) return !1;
        if (Array.isArray(l)) {
          if (!Array.isArray(u)) return !1;
          if (l.length !== u.length) return !1;
          for (var c = 0; c < l.length; c++) if (!e(l[c], u[c])) return !1;
        } else if ("object" !== g(l) || (null != i && i.includes(o))) {
          if (!e(l, u)) return !1;
        } else
          for (var p = 0, h = Object.keys(l); p < h.length; p++) {
            var d = h[p];
            if (l[d] !== u[d]) return !1;
          }
      }
    }
    return !0;
  });
var nc = Ps();
var ic = {};
Object.defineProperty(ic, "__esModule", { value: !0 }),
  (ic.default = function (e, t, r) {
    switch (t.type) {
      case "MemberExpression":
      case "OptionalMemberExpression":
        return t.property === e ? !!t.computed : t.object === e;
      case "JSXMemberExpression":
        return t.object === e;
      case "VariableDeclarator":
        return t.init === e;
      case "ArrowFunctionExpression":
        return t.body === e;
      case "PrivateName":
      case "LabeledStatement":
      case "CatchClause":
      case "RestElement":
      case "BreakStatement":
      case "ContinueStatement":
      case "FunctionDeclaration":
      case "FunctionExpression":
      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
      case "ImportDefaultSpecifier":
      case "ImportNamespaceSpecifier":
      case "ImportSpecifier":
      case "ImportAttribute":
      case "JSXAttribute":
      case "ObjectPattern":
      case "ArrayPattern":
      case "MetaProperty":
        return !1;
      case "ClassMethod":
      case "ClassPrivateMethod":
      case "ObjectMethod":
        return t.key === e && !!t.computed;
      case "ObjectProperty":
        return t.key === e ? !!t.computed : !r || "ObjectPattern" !== r.type;
      case "ClassProperty":
      case "ClassAccessorProperty":
      case "TSPropertySignature":
        return t.key !== e || !!t.computed;
      case "ClassPrivateProperty":
      case "ObjectTypeProperty":
        return t.key !== e;
      case "ClassDeclaration":
      case "ClassExpression":
        return t.superClass === e;
      case "AssignmentExpression":
      case "AssignmentPattern":
        return t.right === e;
      case "ExportSpecifier":
        return (null == r || !r.source) && t.local === e;
      case "TSEnumMember":
        return t.id !== e;
    }
    return !0;
  });
var ac = {};
Object.defineProperty(ac, "__esModule", { value: !0 }),
  (ac.default = function (e, t) {
    if (
      (0, sc.isBlockStatement)(e) &&
      ((0, sc.isFunction)(t) || (0, sc.isCatchClause)(t))
    )
      return !1;
    if (
      (0, sc.isPattern)(e) &&
      ((0, sc.isFunction)(t) || (0, sc.isCatchClause)(t))
    )
      return !0;
    return (0, sc.isScopable)(e);
  });
var sc = _i;
var oc = {};
Object.defineProperty(oc, "__esModule", { value: !0 }),
  (oc.default = function (e) {
    return (
      (0, lc.isImportDefaultSpecifier)(e) ||
      (0, lc.isIdentifier)(e.imported || e.exported, { name: "default" })
    );
  });
var lc = _i;
var uc = {};
Object.defineProperty(uc, "__esModule", { value: !0 }),
  (uc.default = function (e) {
    return (0, cc.default)(e) && !pc.has(e);
  });
var cc = ha,
  pc = new Set([
    "abstract",
    "boolean",
    "byte",
    "char",
    "double",
    "enum",
    "final",
    "float",
    "goto",
    "implements",
    "int",
    "interface",
    "long",
    "native",
    "package",
    "private",
    "protected",
    "public",
    "short",
    "static",
    "synchronized",
    "throws",
    "transient",
    "volatile",
  ]);
var hc = {};
Object.defineProperty(hc, "__esModule", { value: !0 }),
  (hc.default = function (e) {
    return (
      (0, fc.isVariableDeclaration)(e, { kind: "var" }) &&
      !e[yc.BLOCK_SCOPED_SYMBOL]
    );
  });
var dc,
  fc = _i,
  yc = ja;
function mc() {
  return (
    dc ||
      ((dc = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 });
        var t = {
          react: !0,
          assertNode: !0,
          createTypeAnnotationBasedOnTypeof: !0,
          createUnionTypeAnnotation: !0,
          createFlowUnionType: !0,
          createTSUnionType: !0,
          cloneNode: !0,
          clone: !0,
          cloneDeep: !0,
          cloneDeepWithoutLoc: !0,
          cloneWithoutLoc: !0,
          addComment: !0,
          addComments: !0,
          inheritInnerComments: !0,
          inheritLeadingComments: !0,
          inheritsComments: !0,
          inheritTrailingComments: !0,
          removeComments: !0,
          ensureBlock: !0,
          toBindingIdentifierName: !0,
          toBlock: !0,
          toComputedKey: !0,
          toExpression: !0,
          toIdentifier: !0,
          toKeyAlias: !0,
          toSequenceExpression: !0,
          toStatement: !0,
          valueToNode: !0,
          appendToMemberExpression: !0,
          inherits: !0,
          prependToMemberExpression: !0,
          removeProperties: !0,
          removePropertiesDeep: !0,
          removeTypeDuplicates: !0,
          getBindingIdentifiers: !0,
          getOuterBindingIdentifiers: !0,
          traverse: !0,
          traverseFast: !0,
          shallowEqual: !0,
          is: !0,
          isBinding: !0,
          isBlockScoped: !0,
          isImmutable: !0,
          isLet: !0,
          isNode: !0,
          isNodesEquivalent: !0,
          isPlaceholderType: !0,
          isReferenced: !0,
          isScope: !0,
          isSpecifierDefault: !0,
          isType: !0,
          isValidES3Identifier: !0,
          isValidIdentifier: !0,
          isVar: !0,
          matchesPattern: !0,
          validate: !0,
          buildMatchMemberExpression: !0,
          __internal__deprecationWarning: !0,
        };
        Object.defineProperty(e, "__internal__deprecationWarning", {
          enumerable: !0,
          get: function () {
            return de.default;
          },
        }),
          Object.defineProperty(e, "addComment", {
            enumerable: !0,
            get: function () {
              return v.default;
            },
          }),
          Object.defineProperty(e, "addComments", {
            enumerable: !0,
            get: function () {
              return g.default;
            },
          }),
          Object.defineProperty(e, "appendToMemberExpression", {
            enumerable: !0,
            get: function () {
              return F.default;
            },
          }),
          Object.defineProperty(e, "assertNode", {
            enumerable: !0,
            get: function () {
              return a.default;
            },
          }),
          Object.defineProperty(e, "buildMatchMemberExpression", {
            enumerable: !0,
            get: function () {
              return pe.default;
            },
          }),
          Object.defineProperty(e, "clone", {
            enumerable: !0,
            get: function () {
              return d.default;
            },
          }),
          Object.defineProperty(e, "cloneDeep", {
            enumerable: !0,
            get: function () {
              return f.default;
            },
          }),
          Object.defineProperty(e, "cloneDeepWithoutLoc", {
            enumerable: !0,
            get: function () {
              return y.default;
            },
          }),
          Object.defineProperty(e, "cloneNode", {
            enumerable: !0,
            get: function () {
              return h.default;
            },
          }),
          Object.defineProperty(e, "cloneWithoutLoc", {
            enumerable: !0,
            get: function () {
              return m.default;
            },
          }),
          Object.defineProperty(e, "createFlowUnionType", {
            enumerable: !0,
            get: function () {
              return l.default;
            },
          }),
          Object.defineProperty(e, "createTSUnionType", {
            enumerable: !0,
            get: function () {
              return u.default;
            },
          }),
          Object.defineProperty(e, "createTypeAnnotationBasedOnTypeof", {
            enumerable: !0,
            get: function () {
              return o.default;
            },
          }),
          Object.defineProperty(e, "createUnionTypeAnnotation", {
            enumerable: !0,
            get: function () {
              return l.default;
            },
          }),
          Object.defineProperty(e, "ensureBlock", {
            enumerable: !0,
            get: function () {
              return k.default;
            },
          }),
          Object.defineProperty(e, "getBindingIdentifiers", {
            enumerable: !0,
            get: function () {
              return W.default;
            },
          }),
          Object.defineProperty(e, "getOuterBindingIdentifiers", {
            enumerable: !0,
            get: function () {
              return q.default;
            },
          }),
          Object.defineProperty(e, "inheritInnerComments", {
            enumerable: !0,
            get: function () {
              return b.default;
            },
          }),
          Object.defineProperty(e, "inheritLeadingComments", {
            enumerable: !0,
            get: function () {
              return T.default;
            },
          }),
          Object.defineProperty(e, "inheritTrailingComments", {
            enumerable: !0,
            get: function () {
              return x.default;
            },
          }),
          Object.defineProperty(e, "inherits", {
            enumerable: !0,
            get: function () {
              return B.default;
            },
          }),
          Object.defineProperty(e, "inheritsComments", {
            enumerable: !0,
            get: function () {
              return S.default;
            },
          }),
          Object.defineProperty(e, "is", {
            enumerable: !0,
            get: function () {
              return X.default;
            },
          }),
          Object.defineProperty(e, "isBinding", {
            enumerable: !0,
            get: function () {
              return G.default;
            },
          }),
          Object.defineProperty(e, "isBlockScoped", {
            enumerable: !0,
            get: function () {
              return z.default;
            },
          }),
          Object.defineProperty(e, "isImmutable", {
            enumerable: !0,
            get: function () {
              return $.default;
            },
          }),
          Object.defineProperty(e, "isLet", {
            enumerable: !0,
            get: function () {
              return Q.default;
            },
          }),
          Object.defineProperty(e, "isNode", {
            enumerable: !0,
            get: function () {
              return Z.default;
            },
          }),
          Object.defineProperty(e, "isNodesEquivalent", {
            enumerable: !0,
            get: function () {
              return ee.default;
            },
          }),
          Object.defineProperty(e, "isPlaceholderType", {
            enumerable: !0,
            get: function () {
              return te.default;
            },
          }),
          Object.defineProperty(e, "isReferenced", {
            enumerable: !0,
            get: function () {
              return re.default;
            },
          }),
          Object.defineProperty(e, "isScope", {
            enumerable: !0,
            get: function () {
              return ne.default;
            },
          }),
          Object.defineProperty(e, "isSpecifierDefault", {
            enumerable: !0,
            get: function () {
              return ie.default;
            },
          }),
          Object.defineProperty(e, "isType", {
            enumerable: !0,
            get: function () {
              return ae.default;
            },
          }),
          Object.defineProperty(e, "isValidES3Identifier", {
            enumerable: !0,
            get: function () {
              return se.default;
            },
          }),
          Object.defineProperty(e, "isValidIdentifier", {
            enumerable: !0,
            get: function () {
              return oe.default;
            },
          }),
          Object.defineProperty(e, "isVar", {
            enumerable: !0,
            get: function () {
              return le.default;
            },
          }),
          Object.defineProperty(e, "matchesPattern", {
            enumerable: !0,
            get: function () {
              return ue.default;
            },
          }),
          Object.defineProperty(e, "prependToMemberExpression", {
            enumerable: !0,
            get: function () {
              return R.default;
            },
          }),
          (e.react = void 0),
          Object.defineProperty(e, "removeComments", {
            enumerable: !0,
            get: function () {
              return E.default;
            },
          }),
          Object.defineProperty(e, "removeProperties", {
            enumerable: !0,
            get: function () {
              return U.default;
            },
          }),
          Object.defineProperty(e, "removePropertiesDeep", {
            enumerable: !0,
            get: function () {
              return V.default;
            },
          }),
          Object.defineProperty(e, "removeTypeDuplicates", {
            enumerable: !0,
            get: function () {
              return K.default;
            },
          }),
          Object.defineProperty(e, "shallowEqual", {
            enumerable: !0,
            get: function () {
              return J.default;
            },
          }),
          Object.defineProperty(e, "toBindingIdentifierName", {
            enumerable: !0,
            get: function () {
              return w.default;
            },
          }),
          Object.defineProperty(e, "toBlock", {
            enumerable: !0,
            get: function () {
              return C.default;
            },
          }),
          Object.defineProperty(e, "toComputedKey", {
            enumerable: !0,
            get: function () {
              return I.default;
            },
          }),
          Object.defineProperty(e, "toExpression", {
            enumerable: !0,
            get: function () {
              return O.default;
            },
          }),
          Object.defineProperty(e, "toIdentifier", {
            enumerable: !0,
            get: function () {
              return N.default;
            },
          }),
          Object.defineProperty(e, "toKeyAlias", {
            enumerable: !0,
            get: function () {
              return _.default;
            },
          }),
          Object.defineProperty(e, "toSequenceExpression", {
            enumerable: !0,
            get: function () {
              return D.default;
            },
          }),
          Object.defineProperty(e, "toStatement", {
            enumerable: !0,
            get: function () {
              return L.default;
            },
          }),
          Object.defineProperty(e, "traverse", {
            enumerable: !0,
            get: function () {
              return H.default;
            },
          }),
          Object.defineProperty(e, "traverseFast", {
            enumerable: !0,
            get: function () {
              return Y.default;
            },
          }),
          Object.defineProperty(e, "validate", {
            enumerable: !0,
            get: function () {
              return ce.default;
            },
          }),
          Object.defineProperty(e, "valueToNode", {
            enumerable: !0,
            get: function () {
              return M.default;
            },
          });
        var r = Ii,
          n = Ki,
          i = Is(),
          a = Os,
          s = Ls;
        Object.keys(s).forEach(function (r) {
          "default" !== r &&
            "__esModule" !== r &&
            (Object.prototype.hasOwnProperty.call(t, r) ||
              (r in e && e[r] === s[r]) ||
              Object.defineProperty(e, r, {
                enumerable: !0,
                get: function () {
                  return s[r];
                },
              }));
        });
        var o = (function () {
            if (Bs) return Rs;
            (Bs = 1),
              Object.defineProperty(Rs, "__esModule", { value: !0 }),
              (Rs.default = void 0);
            var e = Cs(),
              t = function (t) {
                switch (t) {
                  case "string":
                    return (0, e.stringTypeAnnotation)();
                  case "number":
                    return (0, e.numberTypeAnnotation)();
                  case "undefined":
                    return (0, e.voidTypeAnnotation)();
                  case "boolean":
                    return (0, e.booleanTypeAnnotation)();
                  case "function":
                    return (0, e.genericTypeAnnotation)(
                      (0, e.identifier)("Function")
                    );
                  case "object":
                    return (0, e.genericTypeAnnotation)(
                      (0, e.identifier)("Object")
                    );
                  case "symbol":
                    return (0, e.genericTypeAnnotation)(
                      (0, e.identifier)("Symbol")
                    );
                  case "bigint":
                    return (0, e.anyTypeAnnotation)();
                }
                throw new Error("Invalid typeof value: " + t);
              };
            return (Rs.default = t), Rs;
          })(),
          l = (function () {
            if (qs) return Us;
            (qs = 1),
              Object.defineProperty(Us, "__esModule", { value: !0 }),
              (Us.default = function (r) {
                var n = (0, t.default)(r);
                return 1 === n.length ? n[0] : (0, e.unionTypeAnnotation)(n);
              });
            var e = Cs(),
              t = Vs;
            return Us;
          })(),
          u = (function () {
            if ($s) return Js;
            ($s = 1),
              Object.defineProperty(Js, "__esModule", { value: !0 }),
              (Js.default = function (n) {
                var i = n.map(function (e) {
                    return (0, r.isTSTypeAnnotation)(e) ? e.typeAnnotation : e;
                  }),
                  a = (0, t.default)(i);
                return 1 === a.length ? a[0] : (0, e.tsUnionType)(a);
              });
            var e = Cs(),
              t = Xs,
              r = _i;
            return Js;
          })(),
          c = Cs();
        Object.keys(c).forEach(function (r) {
          "default" !== r &&
            "__esModule" !== r &&
            (Object.prototype.hasOwnProperty.call(t, r) ||
              (r in e && e[r] === c[r]) ||
              Object.defineProperty(e, r, {
                enumerable: !0,
                get: function () {
                  return c[r];
                },
              }));
        });
        var p =
          (eo ||
            ((eo = 1),
            (function (e) {
              Object.defineProperty(e, "__esModule", { value: !0 }),
                Object.defineProperty(e, "AnyTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.anyTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "ArgumentPlaceholder", {
                  enumerable: !0,
                  get: function () {
                    return t.argumentPlaceholder;
                  },
                }),
                Object.defineProperty(e, "ArrayExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.arrayExpression;
                  },
                }),
                Object.defineProperty(e, "ArrayPattern", {
                  enumerable: !0,
                  get: function () {
                    return t.arrayPattern;
                  },
                }),
                Object.defineProperty(e, "ArrayTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.arrayTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "ArrowFunctionExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.arrowFunctionExpression;
                  },
                }),
                Object.defineProperty(e, "AssignmentExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.assignmentExpression;
                  },
                }),
                Object.defineProperty(e, "AssignmentPattern", {
                  enumerable: !0,
                  get: function () {
                    return t.assignmentPattern;
                  },
                }),
                Object.defineProperty(e, "AwaitExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.awaitExpression;
                  },
                }),
                Object.defineProperty(e, "BigIntLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.bigIntLiteral;
                  },
                }),
                Object.defineProperty(e, "BinaryExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.binaryExpression;
                  },
                }),
                Object.defineProperty(e, "BindExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.bindExpression;
                  },
                }),
                Object.defineProperty(e, "BlockStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.blockStatement;
                  },
                }),
                Object.defineProperty(e, "BooleanLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.booleanLiteral;
                  },
                }),
                Object.defineProperty(e, "BooleanLiteralTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.booleanLiteralTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "BooleanTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.booleanTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "BreakStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.breakStatement;
                  },
                }),
                Object.defineProperty(e, "CallExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.callExpression;
                  },
                }),
                Object.defineProperty(e, "CatchClause", {
                  enumerable: !0,
                  get: function () {
                    return t.catchClause;
                  },
                }),
                Object.defineProperty(e, "ClassAccessorProperty", {
                  enumerable: !0,
                  get: function () {
                    return t.classAccessorProperty;
                  },
                }),
                Object.defineProperty(e, "ClassBody", {
                  enumerable: !0,
                  get: function () {
                    return t.classBody;
                  },
                }),
                Object.defineProperty(e, "ClassDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.classDeclaration;
                  },
                }),
                Object.defineProperty(e, "ClassExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.classExpression;
                  },
                }),
                Object.defineProperty(e, "ClassImplements", {
                  enumerable: !0,
                  get: function () {
                    return t.classImplements;
                  },
                }),
                Object.defineProperty(e, "ClassMethod", {
                  enumerable: !0,
                  get: function () {
                    return t.classMethod;
                  },
                }),
                Object.defineProperty(e, "ClassPrivateMethod", {
                  enumerable: !0,
                  get: function () {
                    return t.classPrivateMethod;
                  },
                }),
                Object.defineProperty(e, "ClassPrivateProperty", {
                  enumerable: !0,
                  get: function () {
                    return t.classPrivateProperty;
                  },
                }),
                Object.defineProperty(e, "ClassProperty", {
                  enumerable: !0,
                  get: function () {
                    return t.classProperty;
                  },
                }),
                Object.defineProperty(e, "ConditionalExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.conditionalExpression;
                  },
                }),
                Object.defineProperty(e, "ContinueStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.continueStatement;
                  },
                }),
                Object.defineProperty(e, "DebuggerStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.debuggerStatement;
                  },
                }),
                Object.defineProperty(e, "DecimalLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.decimalLiteral;
                  },
                }),
                Object.defineProperty(e, "DeclareClass", {
                  enumerable: !0,
                  get: function () {
                    return t.declareClass;
                  },
                }),
                Object.defineProperty(e, "DeclareExportAllDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.declareExportAllDeclaration;
                  },
                }),
                Object.defineProperty(e, "DeclareExportDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.declareExportDeclaration;
                  },
                }),
                Object.defineProperty(e, "DeclareFunction", {
                  enumerable: !0,
                  get: function () {
                    return t.declareFunction;
                  },
                }),
                Object.defineProperty(e, "DeclareInterface", {
                  enumerable: !0,
                  get: function () {
                    return t.declareInterface;
                  },
                }),
                Object.defineProperty(e, "DeclareModule", {
                  enumerable: !0,
                  get: function () {
                    return t.declareModule;
                  },
                }),
                Object.defineProperty(e, "DeclareModuleExports", {
                  enumerable: !0,
                  get: function () {
                    return t.declareModuleExports;
                  },
                }),
                Object.defineProperty(e, "DeclareOpaqueType", {
                  enumerable: !0,
                  get: function () {
                    return t.declareOpaqueType;
                  },
                }),
                Object.defineProperty(e, "DeclareTypeAlias", {
                  enumerable: !0,
                  get: function () {
                    return t.declareTypeAlias;
                  },
                }),
                Object.defineProperty(e, "DeclareVariable", {
                  enumerable: !0,
                  get: function () {
                    return t.declareVariable;
                  },
                }),
                Object.defineProperty(e, "DeclaredPredicate", {
                  enumerable: !0,
                  get: function () {
                    return t.declaredPredicate;
                  },
                }),
                Object.defineProperty(e, "Decorator", {
                  enumerable: !0,
                  get: function () {
                    return t.decorator;
                  },
                }),
                Object.defineProperty(e, "Directive", {
                  enumerable: !0,
                  get: function () {
                    return t.directive;
                  },
                }),
                Object.defineProperty(e, "DirectiveLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.directiveLiteral;
                  },
                }),
                Object.defineProperty(e, "DoExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.doExpression;
                  },
                }),
                Object.defineProperty(e, "DoWhileStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.doWhileStatement;
                  },
                }),
                Object.defineProperty(e, "EmptyStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.emptyStatement;
                  },
                }),
                Object.defineProperty(e, "EmptyTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.emptyTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "EnumBooleanBody", {
                  enumerable: !0,
                  get: function () {
                    return t.enumBooleanBody;
                  },
                }),
                Object.defineProperty(e, "EnumBooleanMember", {
                  enumerable: !0,
                  get: function () {
                    return t.enumBooleanMember;
                  },
                }),
                Object.defineProperty(e, "EnumDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.enumDeclaration;
                  },
                }),
                Object.defineProperty(e, "EnumDefaultedMember", {
                  enumerable: !0,
                  get: function () {
                    return t.enumDefaultedMember;
                  },
                }),
                Object.defineProperty(e, "EnumNumberBody", {
                  enumerable: !0,
                  get: function () {
                    return t.enumNumberBody;
                  },
                }),
                Object.defineProperty(e, "EnumNumberMember", {
                  enumerable: !0,
                  get: function () {
                    return t.enumNumberMember;
                  },
                }),
                Object.defineProperty(e, "EnumStringBody", {
                  enumerable: !0,
                  get: function () {
                    return t.enumStringBody;
                  },
                }),
                Object.defineProperty(e, "EnumStringMember", {
                  enumerable: !0,
                  get: function () {
                    return t.enumStringMember;
                  },
                }),
                Object.defineProperty(e, "EnumSymbolBody", {
                  enumerable: !0,
                  get: function () {
                    return t.enumSymbolBody;
                  },
                }),
                Object.defineProperty(e, "ExistsTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.existsTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "ExportAllDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.exportAllDeclaration;
                  },
                }),
                Object.defineProperty(e, "ExportDefaultDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.exportDefaultDeclaration;
                  },
                }),
                Object.defineProperty(e, "ExportDefaultSpecifier", {
                  enumerable: !0,
                  get: function () {
                    return t.exportDefaultSpecifier;
                  },
                }),
                Object.defineProperty(e, "ExportNamedDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.exportNamedDeclaration;
                  },
                }),
                Object.defineProperty(e, "ExportNamespaceSpecifier", {
                  enumerable: !0,
                  get: function () {
                    return t.exportNamespaceSpecifier;
                  },
                }),
                Object.defineProperty(e, "ExportSpecifier", {
                  enumerable: !0,
                  get: function () {
                    return t.exportSpecifier;
                  },
                }),
                Object.defineProperty(e, "ExpressionStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.expressionStatement;
                  },
                }),
                Object.defineProperty(e, "File", {
                  enumerable: !0,
                  get: function () {
                    return t.file;
                  },
                }),
                Object.defineProperty(e, "ForInStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.forInStatement;
                  },
                }),
                Object.defineProperty(e, "ForOfStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.forOfStatement;
                  },
                }),
                Object.defineProperty(e, "ForStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.forStatement;
                  },
                }),
                Object.defineProperty(e, "FunctionDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.functionDeclaration;
                  },
                }),
                Object.defineProperty(e, "FunctionExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.functionExpression;
                  },
                }),
                Object.defineProperty(e, "FunctionTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.functionTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "FunctionTypeParam", {
                  enumerable: !0,
                  get: function () {
                    return t.functionTypeParam;
                  },
                }),
                Object.defineProperty(e, "GenericTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.genericTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "Identifier", {
                  enumerable: !0,
                  get: function () {
                    return t.identifier;
                  },
                }),
                Object.defineProperty(e, "IfStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.ifStatement;
                  },
                }),
                Object.defineProperty(e, "Import", {
                  enumerable: !0,
                  get: function () {
                    return t.import;
                  },
                }),
                Object.defineProperty(e, "ImportAttribute", {
                  enumerable: !0,
                  get: function () {
                    return t.importAttribute;
                  },
                }),
                Object.defineProperty(e, "ImportDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.importDeclaration;
                  },
                }),
                Object.defineProperty(e, "ImportDefaultSpecifier", {
                  enumerable: !0,
                  get: function () {
                    return t.importDefaultSpecifier;
                  },
                }),
                Object.defineProperty(e, "ImportNamespaceSpecifier", {
                  enumerable: !0,
                  get: function () {
                    return t.importNamespaceSpecifier;
                  },
                }),
                Object.defineProperty(e, "ImportSpecifier", {
                  enumerable: !0,
                  get: function () {
                    return t.importSpecifier;
                  },
                }),
                Object.defineProperty(e, "IndexedAccessType", {
                  enumerable: !0,
                  get: function () {
                    return t.indexedAccessType;
                  },
                }),
                Object.defineProperty(e, "InferredPredicate", {
                  enumerable: !0,
                  get: function () {
                    return t.inferredPredicate;
                  },
                }),
                Object.defineProperty(e, "InterfaceDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.interfaceDeclaration;
                  },
                }),
                Object.defineProperty(e, "InterfaceExtends", {
                  enumerable: !0,
                  get: function () {
                    return t.interfaceExtends;
                  },
                }),
                Object.defineProperty(e, "InterfaceTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.interfaceTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "InterpreterDirective", {
                  enumerable: !0,
                  get: function () {
                    return t.interpreterDirective;
                  },
                }),
                Object.defineProperty(e, "IntersectionTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.intersectionTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "JSXAttribute", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxAttribute;
                  },
                }),
                Object.defineProperty(e, "JSXClosingElement", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxClosingElement;
                  },
                }),
                Object.defineProperty(e, "JSXClosingFragment", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxClosingFragment;
                  },
                }),
                Object.defineProperty(e, "JSXElement", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxElement;
                  },
                }),
                Object.defineProperty(e, "JSXEmptyExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxEmptyExpression;
                  },
                }),
                Object.defineProperty(e, "JSXExpressionContainer", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxExpressionContainer;
                  },
                }),
                Object.defineProperty(e, "JSXFragment", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxFragment;
                  },
                }),
                Object.defineProperty(e, "JSXIdentifier", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxIdentifier;
                  },
                }),
                Object.defineProperty(e, "JSXMemberExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxMemberExpression;
                  },
                }),
                Object.defineProperty(e, "JSXNamespacedName", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxNamespacedName;
                  },
                }),
                Object.defineProperty(e, "JSXOpeningElement", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxOpeningElement;
                  },
                }),
                Object.defineProperty(e, "JSXOpeningFragment", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxOpeningFragment;
                  },
                }),
                Object.defineProperty(e, "JSXSpreadAttribute", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxSpreadAttribute;
                  },
                }),
                Object.defineProperty(e, "JSXSpreadChild", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxSpreadChild;
                  },
                }),
                Object.defineProperty(e, "JSXText", {
                  enumerable: !0,
                  get: function () {
                    return t.jsxText;
                  },
                }),
                Object.defineProperty(e, "LabeledStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.labeledStatement;
                  },
                }),
                Object.defineProperty(e, "LogicalExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.logicalExpression;
                  },
                }),
                Object.defineProperty(e, "MemberExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.memberExpression;
                  },
                }),
                Object.defineProperty(e, "MetaProperty", {
                  enumerable: !0,
                  get: function () {
                    return t.metaProperty;
                  },
                }),
                Object.defineProperty(e, "MixedTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.mixedTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "ModuleExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.moduleExpression;
                  },
                }),
                Object.defineProperty(e, "NewExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.newExpression;
                  },
                }),
                Object.defineProperty(e, "Noop", {
                  enumerable: !0,
                  get: function () {
                    return t.noop;
                  },
                }),
                Object.defineProperty(e, "NullLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.nullLiteral;
                  },
                }),
                Object.defineProperty(e, "NullLiteralTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.nullLiteralTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "NullableTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.nullableTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "NumberLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.numberLiteral;
                  },
                }),
                Object.defineProperty(e, "NumberLiteralTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.numberLiteralTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "NumberTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.numberTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "NumericLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.numericLiteral;
                  },
                }),
                Object.defineProperty(e, "ObjectExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.objectExpression;
                  },
                }),
                Object.defineProperty(e, "ObjectMethod", {
                  enumerable: !0,
                  get: function () {
                    return t.objectMethod;
                  },
                }),
                Object.defineProperty(e, "ObjectPattern", {
                  enumerable: !0,
                  get: function () {
                    return t.objectPattern;
                  },
                }),
                Object.defineProperty(e, "ObjectProperty", {
                  enumerable: !0,
                  get: function () {
                    return t.objectProperty;
                  },
                }),
                Object.defineProperty(e, "ObjectTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.objectTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "ObjectTypeCallProperty", {
                  enumerable: !0,
                  get: function () {
                    return t.objectTypeCallProperty;
                  },
                }),
                Object.defineProperty(e, "ObjectTypeIndexer", {
                  enumerable: !0,
                  get: function () {
                    return t.objectTypeIndexer;
                  },
                }),
                Object.defineProperty(e, "ObjectTypeInternalSlot", {
                  enumerable: !0,
                  get: function () {
                    return t.objectTypeInternalSlot;
                  },
                }),
                Object.defineProperty(e, "ObjectTypeProperty", {
                  enumerable: !0,
                  get: function () {
                    return t.objectTypeProperty;
                  },
                }),
                Object.defineProperty(e, "ObjectTypeSpreadProperty", {
                  enumerable: !0,
                  get: function () {
                    return t.objectTypeSpreadProperty;
                  },
                }),
                Object.defineProperty(e, "OpaqueType", {
                  enumerable: !0,
                  get: function () {
                    return t.opaqueType;
                  },
                }),
                Object.defineProperty(e, "OptionalCallExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.optionalCallExpression;
                  },
                }),
                Object.defineProperty(e, "OptionalIndexedAccessType", {
                  enumerable: !0,
                  get: function () {
                    return t.optionalIndexedAccessType;
                  },
                }),
                Object.defineProperty(e, "OptionalMemberExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.optionalMemberExpression;
                  },
                }),
                Object.defineProperty(e, "ParenthesizedExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.parenthesizedExpression;
                  },
                }),
                Object.defineProperty(e, "PipelineBareFunction", {
                  enumerable: !0,
                  get: function () {
                    return t.pipelineBareFunction;
                  },
                }),
                Object.defineProperty(e, "PipelinePrimaryTopicReference", {
                  enumerable: !0,
                  get: function () {
                    return t.pipelinePrimaryTopicReference;
                  },
                }),
                Object.defineProperty(e, "PipelineTopicExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.pipelineTopicExpression;
                  },
                }),
                Object.defineProperty(e, "Placeholder", {
                  enumerable: !0,
                  get: function () {
                    return t.placeholder;
                  },
                }),
                Object.defineProperty(e, "PrivateName", {
                  enumerable: !0,
                  get: function () {
                    return t.privateName;
                  },
                }),
                Object.defineProperty(e, "Program", {
                  enumerable: !0,
                  get: function () {
                    return t.program;
                  },
                }),
                Object.defineProperty(e, "QualifiedTypeIdentifier", {
                  enumerable: !0,
                  get: function () {
                    return t.qualifiedTypeIdentifier;
                  },
                }),
                Object.defineProperty(e, "RecordExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.recordExpression;
                  },
                }),
                Object.defineProperty(e, "RegExpLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.regExpLiteral;
                  },
                }),
                Object.defineProperty(e, "RegexLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.regexLiteral;
                  },
                }),
                Object.defineProperty(e, "RestElement", {
                  enumerable: !0,
                  get: function () {
                    return t.restElement;
                  },
                }),
                Object.defineProperty(e, "RestProperty", {
                  enumerable: !0,
                  get: function () {
                    return t.restProperty;
                  },
                }),
                Object.defineProperty(e, "ReturnStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.returnStatement;
                  },
                }),
                Object.defineProperty(e, "SequenceExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.sequenceExpression;
                  },
                }),
                Object.defineProperty(e, "SpreadElement", {
                  enumerable: !0,
                  get: function () {
                    return t.spreadElement;
                  },
                }),
                Object.defineProperty(e, "SpreadProperty", {
                  enumerable: !0,
                  get: function () {
                    return t.spreadProperty;
                  },
                }),
                Object.defineProperty(e, "StaticBlock", {
                  enumerable: !0,
                  get: function () {
                    return t.staticBlock;
                  },
                }),
                Object.defineProperty(e, "StringLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.stringLiteral;
                  },
                }),
                Object.defineProperty(e, "StringLiteralTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.stringLiteralTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "StringTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.stringTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "Super", {
                  enumerable: !0,
                  get: function () {
                    return t.super;
                  },
                }),
                Object.defineProperty(e, "SwitchCase", {
                  enumerable: !0,
                  get: function () {
                    return t.switchCase;
                  },
                }),
                Object.defineProperty(e, "SwitchStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.switchStatement;
                  },
                }),
                Object.defineProperty(e, "SymbolTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.symbolTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "TSAnyKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsAnyKeyword;
                  },
                }),
                Object.defineProperty(e, "TSArrayType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsArrayType;
                  },
                }),
                Object.defineProperty(e, "TSAsExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.tsAsExpression;
                  },
                }),
                Object.defineProperty(e, "TSBigIntKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsBigIntKeyword;
                  },
                }),
                Object.defineProperty(e, "TSBooleanKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsBooleanKeyword;
                  },
                }),
                Object.defineProperty(e, "TSCallSignatureDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.tsCallSignatureDeclaration;
                  },
                }),
                Object.defineProperty(e, "TSConditionalType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsConditionalType;
                  },
                }),
                Object.defineProperty(e, "TSConstructSignatureDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.tsConstructSignatureDeclaration;
                  },
                }),
                Object.defineProperty(e, "TSConstructorType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsConstructorType;
                  },
                }),
                Object.defineProperty(e, "TSDeclareFunction", {
                  enumerable: !0,
                  get: function () {
                    return t.tsDeclareFunction;
                  },
                }),
                Object.defineProperty(e, "TSDeclareMethod", {
                  enumerable: !0,
                  get: function () {
                    return t.tsDeclareMethod;
                  },
                }),
                Object.defineProperty(e, "TSEnumDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.tsEnumDeclaration;
                  },
                }),
                Object.defineProperty(e, "TSEnumMember", {
                  enumerable: !0,
                  get: function () {
                    return t.tsEnumMember;
                  },
                }),
                Object.defineProperty(e, "TSExportAssignment", {
                  enumerable: !0,
                  get: function () {
                    return t.tsExportAssignment;
                  },
                }),
                Object.defineProperty(e, "TSExpressionWithTypeArguments", {
                  enumerable: !0,
                  get: function () {
                    return t.tsExpressionWithTypeArguments;
                  },
                }),
                Object.defineProperty(e, "TSExternalModuleReference", {
                  enumerable: !0,
                  get: function () {
                    return t.tsExternalModuleReference;
                  },
                }),
                Object.defineProperty(e, "TSFunctionType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsFunctionType;
                  },
                }),
                Object.defineProperty(e, "TSImportEqualsDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.tsImportEqualsDeclaration;
                  },
                }),
                Object.defineProperty(e, "TSImportType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsImportType;
                  },
                }),
                Object.defineProperty(e, "TSIndexSignature", {
                  enumerable: !0,
                  get: function () {
                    return t.tsIndexSignature;
                  },
                }),
                Object.defineProperty(e, "TSIndexedAccessType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsIndexedAccessType;
                  },
                }),
                Object.defineProperty(e, "TSInferType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsInferType;
                  },
                }),
                Object.defineProperty(e, "TSInstantiationExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.tsInstantiationExpression;
                  },
                }),
                Object.defineProperty(e, "TSInterfaceBody", {
                  enumerable: !0,
                  get: function () {
                    return t.tsInterfaceBody;
                  },
                }),
                Object.defineProperty(e, "TSInterfaceDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.tsInterfaceDeclaration;
                  },
                }),
                Object.defineProperty(e, "TSIntersectionType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsIntersectionType;
                  },
                }),
                Object.defineProperty(e, "TSIntrinsicKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsIntrinsicKeyword;
                  },
                }),
                Object.defineProperty(e, "TSLiteralType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsLiteralType;
                  },
                }),
                Object.defineProperty(e, "TSMappedType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsMappedType;
                  },
                }),
                Object.defineProperty(e, "TSMethodSignature", {
                  enumerable: !0,
                  get: function () {
                    return t.tsMethodSignature;
                  },
                }),
                Object.defineProperty(e, "TSModuleBlock", {
                  enumerable: !0,
                  get: function () {
                    return t.tsModuleBlock;
                  },
                }),
                Object.defineProperty(e, "TSModuleDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.tsModuleDeclaration;
                  },
                }),
                Object.defineProperty(e, "TSNamedTupleMember", {
                  enumerable: !0,
                  get: function () {
                    return t.tsNamedTupleMember;
                  },
                }),
                Object.defineProperty(e, "TSNamespaceExportDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.tsNamespaceExportDeclaration;
                  },
                }),
                Object.defineProperty(e, "TSNeverKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsNeverKeyword;
                  },
                }),
                Object.defineProperty(e, "TSNonNullExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.tsNonNullExpression;
                  },
                }),
                Object.defineProperty(e, "TSNullKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsNullKeyword;
                  },
                }),
                Object.defineProperty(e, "TSNumberKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsNumberKeyword;
                  },
                }),
                Object.defineProperty(e, "TSObjectKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsObjectKeyword;
                  },
                }),
                Object.defineProperty(e, "TSOptionalType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsOptionalType;
                  },
                }),
                Object.defineProperty(e, "TSParameterProperty", {
                  enumerable: !0,
                  get: function () {
                    return t.tsParameterProperty;
                  },
                }),
                Object.defineProperty(e, "TSParenthesizedType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsParenthesizedType;
                  },
                }),
                Object.defineProperty(e, "TSPropertySignature", {
                  enumerable: !0,
                  get: function () {
                    return t.tsPropertySignature;
                  },
                }),
                Object.defineProperty(e, "TSQualifiedName", {
                  enumerable: !0,
                  get: function () {
                    return t.tsQualifiedName;
                  },
                }),
                Object.defineProperty(e, "TSRestType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsRestType;
                  },
                }),
                Object.defineProperty(e, "TSSatisfiesExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.tsSatisfiesExpression;
                  },
                }),
                Object.defineProperty(e, "TSStringKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsStringKeyword;
                  },
                }),
                Object.defineProperty(e, "TSSymbolKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsSymbolKeyword;
                  },
                }),
                Object.defineProperty(e, "TSThisType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsThisType;
                  },
                }),
                Object.defineProperty(e, "TSTupleType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTupleType;
                  },
                }),
                Object.defineProperty(e, "TSTypeAliasDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTypeAliasDeclaration;
                  },
                }),
                Object.defineProperty(e, "TSTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "TSTypeAssertion", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTypeAssertion;
                  },
                }),
                Object.defineProperty(e, "TSTypeLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTypeLiteral;
                  },
                }),
                Object.defineProperty(e, "TSTypeOperator", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTypeOperator;
                  },
                }),
                Object.defineProperty(e, "TSTypeParameter", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTypeParameter;
                  },
                }),
                Object.defineProperty(e, "TSTypeParameterDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTypeParameterDeclaration;
                  },
                }),
                Object.defineProperty(e, "TSTypeParameterInstantiation", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTypeParameterInstantiation;
                  },
                }),
                Object.defineProperty(e, "TSTypePredicate", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTypePredicate;
                  },
                }),
                Object.defineProperty(e, "TSTypeQuery", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTypeQuery;
                  },
                }),
                Object.defineProperty(e, "TSTypeReference", {
                  enumerable: !0,
                  get: function () {
                    return t.tsTypeReference;
                  },
                }),
                Object.defineProperty(e, "TSUndefinedKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsUndefinedKeyword;
                  },
                }),
                Object.defineProperty(e, "TSUnionType", {
                  enumerable: !0,
                  get: function () {
                    return t.tsUnionType;
                  },
                }),
                Object.defineProperty(e, "TSUnknownKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsUnknownKeyword;
                  },
                }),
                Object.defineProperty(e, "TSVoidKeyword", {
                  enumerable: !0,
                  get: function () {
                    return t.tsVoidKeyword;
                  },
                }),
                Object.defineProperty(e, "TaggedTemplateExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.taggedTemplateExpression;
                  },
                }),
                Object.defineProperty(e, "TemplateElement", {
                  enumerable: !0,
                  get: function () {
                    return t.templateElement;
                  },
                }),
                Object.defineProperty(e, "TemplateLiteral", {
                  enumerable: !0,
                  get: function () {
                    return t.templateLiteral;
                  },
                }),
                Object.defineProperty(e, "ThisExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.thisExpression;
                  },
                }),
                Object.defineProperty(e, "ThisTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.thisTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "ThrowStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.throwStatement;
                  },
                }),
                Object.defineProperty(e, "TopicReference", {
                  enumerable: !0,
                  get: function () {
                    return t.topicReference;
                  },
                }),
                Object.defineProperty(e, "TryStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.tryStatement;
                  },
                }),
                Object.defineProperty(e, "TupleExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.tupleExpression;
                  },
                }),
                Object.defineProperty(e, "TupleTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.tupleTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "TypeAlias", {
                  enumerable: !0,
                  get: function () {
                    return t.typeAlias;
                  },
                }),
                Object.defineProperty(e, "TypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.typeAnnotation;
                  },
                }),
                Object.defineProperty(e, "TypeCastExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.typeCastExpression;
                  },
                }),
                Object.defineProperty(e, "TypeParameter", {
                  enumerable: !0,
                  get: function () {
                    return t.typeParameter;
                  },
                }),
                Object.defineProperty(e, "TypeParameterDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.typeParameterDeclaration;
                  },
                }),
                Object.defineProperty(e, "TypeParameterInstantiation", {
                  enumerable: !0,
                  get: function () {
                    return t.typeParameterInstantiation;
                  },
                }),
                Object.defineProperty(e, "TypeofTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.typeofTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "UnaryExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.unaryExpression;
                  },
                }),
                Object.defineProperty(e, "UnionTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.unionTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "UpdateExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.updateExpression;
                  },
                }),
                Object.defineProperty(e, "V8IntrinsicIdentifier", {
                  enumerable: !0,
                  get: function () {
                    return t.v8IntrinsicIdentifier;
                  },
                }),
                Object.defineProperty(e, "VariableDeclaration", {
                  enumerable: !0,
                  get: function () {
                    return t.variableDeclaration;
                  },
                }),
                Object.defineProperty(e, "VariableDeclarator", {
                  enumerable: !0,
                  get: function () {
                    return t.variableDeclarator;
                  },
                }),
                Object.defineProperty(e, "Variance", {
                  enumerable: !0,
                  get: function () {
                    return t.variance;
                  },
                }),
                Object.defineProperty(e, "VoidTypeAnnotation", {
                  enumerable: !0,
                  get: function () {
                    return t.voidTypeAnnotation;
                  },
                }),
                Object.defineProperty(e, "WhileStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.whileStatement;
                  },
                }),
                Object.defineProperty(e, "WithStatement", {
                  enumerable: !0,
                  get: function () {
                    return t.withStatement;
                  },
                }),
                Object.defineProperty(e, "YieldExpression", {
                  enumerable: !0,
                  get: function () {
                    return t.yieldExpression;
                  },
                });
              var t = Cs();
            })(to)),
          to);
        Object.keys(p).forEach(function (r) {
          "default" !== r &&
            "__esModule" !== r &&
            (Object.prototype.hasOwnProperty.call(t, r) ||
              (r in e && e[r] === p[r]) ||
              Object.defineProperty(e, r, {
                enumerable: !0,
                get: function () {
                  return p[r];
                },
              }));
        });
        var h = ro,
          d = co,
          f = ho,
          y = yo,
          m = vo,
          v = bo,
          g = To,
          b = xo,
          T = Ao,
          S = wo,
          x = Co,
          E = Do,
          P = Mo;
        Object.keys(P).forEach(function (r) {
          "default" !== r &&
            "__esModule" !== r &&
            (Object.prototype.hasOwnProperty.call(t, r) ||
              (r in e && e[r] === P[r]) ||
              Object.defineProperty(e, r, {
                enumerable: !0,
                get: function () {
                  return P[r];
                },
              }));
        });
        var A = ja;
        Object.keys(A).forEach(function (r) {
          "default" !== r &&
            "__esModule" !== r &&
            (Object.prototype.hasOwnProperty.call(t, r) ||
              (r in e && e[r] === A[r]) ||
              Object.defineProperty(e, r, {
                enumerable: !0,
                get: function () {
                  return A[r];
                },
              }));
        });
        var k = (function () {
            if (Ll) return Ml;
            (Ll = 1),
              Object.defineProperty(Ml, "__esModule", { value: !0 }),
              (Ml.default = function (t) {
                var r =
                    arguments.length > 1 && void 0 !== arguments[1]
                      ? arguments[1]
                      : "body",
                  n = (0, e.default)(t[r], t);
                return (t[r] = n), n;
              });
            var e = Fl();
            return Ml;
          })(),
          w = Bl,
          C = Fl(),
          I = (function () {
            if (Hl) return Yl;
            (Hl = 1),
              Object.defineProperty(Yl, "__esModule", { value: !0 }),
              (Yl.default = function (r) {
                var n =
                  arguments.length > 1 && void 0 !== arguments[1]
                    ? arguments[1]
                    : r.key || r.property;
                return (
                  !r.computed &&
                    (0, e.isIdentifier)(n) &&
                    (n = (0, t.stringLiteral)(n.name)),
                  n
                );
              });
            var e = _i,
              t = Cs();
            return Yl;
          })(),
          O = Jl,
          N = Rl,
          _ = zl,
          D = xu(),
          L = (function () {
            if (Eu) return Pu;
            (Eu = 1),
              Object.defineProperty(Pu, "__esModule", { value: !0 }),
              (Pu.default = void 0);
            var e = _i,
              t = Cs(),
              r = function (r, n) {
                if ((0, e.isStatement)(r)) return r;
                var i,
                  a = !1;
                if ((0, e.isClass)(r)) (a = !0), (i = "ClassDeclaration");
                else if ((0, e.isFunction)(r))
                  (a = !0), (i = "FunctionDeclaration");
                else if ((0, e.isAssignmentExpression)(r))
                  return (0, t.expressionStatement)(r);
                if ((a && !r.id && (i = !1), !i)) {
                  if (n) return !1;
                  throw new Error(
                    "cannot turn ".concat(r.type, " to a statement")
                  );
                }
                return (r.type = i), r;
              };
            return (Pu.default = r), Pu;
          })(),
          M = wu(),
          j = Ps();
        Object.keys(j).forEach(function (r) {
          "default" !== r &&
            "__esModule" !== r &&
            (Object.prototype.hasOwnProperty.call(t, r) ||
              (r in e && e[r] === j[r]) ||
              Object.defineProperty(e, r, {
                enumerable: !0,
                get: function () {
                  return j[r];
                },
              }));
        });
        var F = (function () {
            if (Cu) return Iu;
            (Cu = 1),
              Object.defineProperty(Iu, "__esModule", { value: !0 }),
              (Iu.default = function (t, r) {
                var n =
                  arguments.length > 2 &&
                  void 0 !== arguments[2] &&
                  arguments[2];
                return (
                  (t.object = (0, e.memberExpression)(
                    t.object,
                    t.property,
                    t.computed
                  )),
                  (t.property = r),
                  (t.computed = !!n),
                  t
                );
              });
            var e = Cs();
            return Iu;
          })(),
          B = Ou,
          R = (function () {
            if (Mu) return ju;
            (Mu = 1),
              Object.defineProperty(ju, "__esModule", { value: !0 }),
              (ju.default = function (r, n) {
                if ((0, t.isSuper)(r.object))
                  throw new Error(
                    "Cannot prepend node to super property access (`super.foo`)."
                  );
                return (r.object = (0, e.memberExpression)(n, r.object)), r;
              });
            var e = Cs(),
              t = mc();
            return ju;
          })(),
          U = ru,
          V = $l,
          K = Vs,
          W = yu,
          q = Fu,
          H = Uu;
        Object.keys(H).forEach(function (r) {
          "default" !== r &&
            "__esModule" !== r &&
            (Object.prototype.hasOwnProperty.call(t, r) ||
              (r in e && e[r] === H[r]) ||
              Object.defineProperty(e, r, {
                enumerable: !0,
                get: function () {
                  return H[r];
                },
              }));
        });
        var Y = Ql,
          J = Di,
          X = pa(),
          G = Hu,
          z = Ju,
          $ = Zu,
          Q = Xu,
          Z = Ns,
          ee = rc,
          te = ca(),
          re = ic,
          ne = ac,
          ie = oc,
          ae = ia(),
          se = uc,
          oe = ha,
          le = hc,
          ue = Ni,
          ce = As(),
          pe = Oi,
          he = _i;
        Object.keys(he).forEach(function (r) {
          "default" !== r &&
            "__esModule" !== r &&
            (Object.prototype.hasOwnProperty.call(t, r) ||
              (r in e && e[r] === he[r]) ||
              Object.defineProperty(e, r, {
                enumerable: !0,
                get: function () {
                  return he[r];
                },
              }));
        });
        var de = Li,
          fe = {
            isReactComponent: r.default,
            isCompatTag: n.default,
            buildChildren: i.default,
          };
        e.react = fe;
      })(Ci)),
    Ci
  );
}
Object.defineProperty(wi, "__esModule", { value: !0 }), (wi.nodes = void 0);
var vc = mc(),
  gc = vc.FLIPPED_ALIAS_KEYS,
  bc = vc.isArrayExpression,
  Tc = vc.isAssignmentExpression,
  Sc = vc.isBinary,
  xc = vc.isBlockStatement,
  Ec = vc.isCallExpression,
  Pc = vc.isFunction,
  Ac = vc.isIdentifier,
  kc = vc.isLiteral,
  wc = vc.isMemberExpression,
  Cc = vc.isObjectExpression,
  Ic = vc.isOptionalCallExpression,
  Oc = vc.isOptionalMemberExpression,
  Nc = vc.isStringLiteral;
function _c(e, t) {
  return e
    ? (wc(e) || Oc(e)
        ? (_c(e.object, t), e.computed && _c(e.property, t))
        : Sc(e) || Tc(e)
        ? (_c(e.left, t), _c(e.right, t))
        : Ec(e) || Ic(e)
        ? ((t.hasCall = !0), _c(e.callee, t))
        : Pc(e)
        ? (t.hasFunction = !0)
        : Ac(e) && (t.hasHelper = t.hasHelper || (e.callee && Lc(e.callee))),
      t)
    : t;
}
function Dc(e) {
  return _c(e, { hasCall: !1, hasFunction: !1, hasHelper: !1 });
}
function Lc(e) {
  return (
    !!e &&
    (wc(e)
      ? Lc(e.object) || Lc(e.property)
      : Ac(e)
      ? "require" === e.name || 95 === e.name.charCodeAt(0)
      : Ec(e)
      ? Lc(e.callee)
      : !(!Sc(e) && !Tc(e)) && ((Ac(e.left) && Lc(e.left)) || Lc(e.right)))
  );
}
function Mc(e) {
  return kc(e) || Cc(e) || bc(e) || Ac(e) || wc(e);
}
var jc = {
  AssignmentExpression: function (e) {
    var t = Dc(e.right);
    if ((t.hasCall && t.hasHelper) || t.hasFunction)
      return t.hasFunction ? 3 : 2;
  },
  SwitchCase: function (e, t) {
    return (
      (e.consequent.length || t.cases[0] === e ? 1 : 0) |
      (e.consequent.length || t.cases[t.cases.length - 1] !== e ? 0 : 2)
    );
  },
  LogicalExpression: function (e) {
    if (Pc(e.left) || Pc(e.right)) return 2;
  },
  Literal: function (e) {
    if (Nc(e) && "use strict" === e.value) return 2;
  },
  CallExpression: function (e) {
    if (Pc(e.callee) || Lc(e)) return 3;
  },
  OptionalCallExpression: function (e) {
    if (Pc(e.callee)) return 3;
  },
  VariableDeclaration: function (e) {
    for (var t = 0; t < e.declarations.length; t++) {
      var r = e.declarations[t],
        n = Lc(r.id) && !Mc(r.init);
      if (!n && r.init) {
        var i = Dc(r.init);
        n = (Lc(r.init) && i.hasCall) || i.hasFunction;
      }
      if (n) return 3;
    }
  },
  IfStatement: function (e) {
    if (xc(e.consequent)) return 3;
  },
};
(wi.nodes = jc),
  (jc.ObjectProperty =
    jc.ObjectTypeProperty =
    jc.ObjectMethod =
      function (e, t) {
        if (t.properties[0] === e) return 1;
      }),
  (jc.ObjectTypeCallProperty = function (e, t) {
    var r;
    if (t.callProperties[0] === e && (null == (r = t.properties) || !r.length))
      return 1;
  }),
  (jc.ObjectTypeIndexer = function (e, t) {
    var r, n;
    if (
      !(
        t.indexers[0] !== e ||
        (null != (r = t.properties) && r.length) ||
        (null != (n = t.callProperties) && n.length)
      )
    )
      return 1;
  }),
  (jc.ObjectTypeInternalSlot = function (e, t) {
    var r, n, i;
    if (
      !(
        t.internalSlots[0] !== e ||
        (null != (r = t.properties) && r.length) ||
        (null != (n = t.callProperties) && n.length) ||
        (null != (i = t.indexers) && i.length)
      )
    )
      return 1;
  }),
  [
    ["Function", !0],
    ["Class", !0],
    ["Loop", !0],
    ["LabeledStatement", !0],
    ["SwitchStatement", !0],
    ["TryStatement", !0],
  ].forEach(function (e) {
    var t = H(e, 2),
      r = t[0],
      n = t[1];
    [r].concat(gc[r] || []).forEach(function (e) {
      var t = n ? 3 : 0;
      jc[e] = function () {
        return t;
      };
    });
  });
var Fc = {};
Object.defineProperty(Fc, "__esModule", { value: !0 }),
  (Fc.ArrowFunctionExpression = function (e, t) {
    return $c(t) || Vp(e, t);
  }),
  (Fc.AssignmentExpression = function (e, t) {
    return !!hp(e.left) || Vp(e, t);
  }),
  (Fc.Binary = function (e, t) {
    if ("**" === e.operator && qc(t, { operator: "**" })) return t.left === e;
    if (Bp(e, t)) return !0;
    if (Rp(e, t) || Op(t) || Kc(t)) return !0;
    if (Wc(t)) {
      var r = t.operator,
        n = jp[r],
        i = e.operator,
        a = jp[i];
      if ((n === a && t.right === e && !lp(t)) || n > a) return !0;
    }
  }),
  (Fc.BinaryExpression = function (e, t) {
    return "in" === e.operator && (_p(t) || ep(t));
  }),
  (Fc.ClassExpression = function (e, t, r) {
    return Kp(r, 5);
  }),
  (Fc.ConditionalExpression = Vp),
  (Fc.DoExpression = function (e, t, r) {
    return !e.async && Kp(r, 1);
  }),
  (Fc.FunctionExpression = function (e, t, r) {
    return Kp(r, 5);
  }),
  (Fc.FunctionTypeAnnotation = function (e, t, r) {
    if (r.length < 3) return;
    return Np(t) || op(t) || Rc(t) || (Ip(t) && Uc(r[r.length - 3]));
  }),
  (Fc.Identifier = function (e, t, r) {
    var n;
    if (
      null != (n = e.extra) &&
      n.parenthesized &&
      Vc(t, { left: e }) &&
      (ip(t.right) || Xc(t.right)) &&
      null == t.right.id
    )
      return !0;
    if ("let" === e.name) {
      return Kp(
        r,
        up(t, { object: e, computed: !0 }) ||
          fp(t, { object: e, computed: !0, optional: !1 })
          ? 57
          : 32
      );
    }
    return "async" === e.name && rp(t) && e === t.left;
  }),
  (Fc.LogicalExpression = function (e, t) {
    if (Fp(t)) return !0;
    switch (e.operator) {
      case "||":
        return !!lp(t) && ("??" === t.operator || "&&" === t.operator);
      case "&&":
        return lp(t, { operator: "??" });
      case "??":
        return lp(t) && "??" !== t.operator;
    }
  }),
  (Fc.NullableTypeAnnotation = function (e, t) {
    return Rc(t);
  }),
  (Fc.ObjectExpression = function (e, t, r) {
    return Kp(r, 3);
  }),
  (Fc.OptionalIndexedAccessType = function (e, t) {
    return sp(t, { objectType: e });
  }),
  (Fc.OptionalCallExpression = Fc.OptionalMemberExpression =
    function (e, t) {
      return Yc(t, { callee: e }) || up(t, { object: e });
    }),
  (Fc.SequenceExpression = function (e, t) {
    if (
      np(t) ||
      Cp(t) ||
      yp(t) ||
      (ap(t) && t.test === e) ||
      (Dp(t) && t.test === e) ||
      (tp(t) && t.right === e) ||
      (vp(t) && t.discriminant === e) ||
      (Zc(t) && t.expression === e)
    )
      return !1;
    return !0;
  }),
  (Fc.TSTypeAssertion =
    Fc.TSSatisfiesExpression =
    Fc.TSAsExpression =
      function () {
        return !0;
      }),
  (Fc.TSInferType = function (e, t) {
    return gp(t) || Ep(t);
  }),
  (Fc.TSInstantiationExpression = function (e, t) {
    return (Yc(t) || dp(t) || cp(t) || Tp(t)) && !!t.typeParameters;
  }),
  (Fc.TSIntersectionType = Fc.TSUnionType =
    function (e, t) {
      return gp(t) || Ep(t) || Sp(t) || kp(t) || Pp(t);
    }),
  (Fc.UnaryLike = Up),
  (Fc.IntersectionTypeAnnotation = Fc.UnionTypeAnnotation =
    function (e, t) {
      return Rc(t) || pp(t) || op(t) || Np(t);
    }),
  (Fc.UpdateExpression = function (e, t) {
    return Rp(e, t) || Bp(e, t);
  }),
  (Fc.AwaitExpression = Fc.YieldExpression =
    function (e, t) {
      return (
        Wc(t) ||
        Op(t) ||
        Rp(e, t) ||
        (Kc(t) && Lp(e)) ||
        (zc(t) && e === t.test) ||
        Bp(e, t)
      );
    });
var Bc = mc(),
  Rc = Bc.isArrayTypeAnnotation,
  Uc = Bc.isArrowFunctionExpression,
  Vc = Bc.isAssignmentExpression,
  Kc = Bc.isAwaitExpression,
  Wc = Bc.isBinary,
  qc = Bc.isBinaryExpression,
  Hc = Bc.isUpdateExpression,
  Yc = Bc.isCallExpression,
  Jc = Bc.isClass,
  Xc = Bc.isClassExpression,
  Gc = Bc.isConditional,
  zc = Bc.isConditionalExpression,
  $c = Bc.isExportDeclaration,
  Qc = Bc.isExportDefaultDeclaration,
  Zc = Bc.isExpressionStatement,
  ep = Bc.isFor,
  tp = Bc.isForInStatement,
  rp = Bc.isForOfStatement,
  np = Bc.isForStatement,
  ip = Bc.isFunctionExpression,
  ap = Bc.isIfStatement,
  sp = Bc.isIndexedAccessType,
  op = Bc.isIntersectionTypeAnnotation,
  lp = Bc.isLogicalExpression,
  up = Bc.isMemberExpression,
  cp = Bc.isNewExpression,
  pp = Bc.isNullableTypeAnnotation,
  hp = Bc.isObjectPattern,
  dp = Bc.isOptionalCallExpression,
  fp = Bc.isOptionalMemberExpression,
  yp = Bc.isReturnStatement,
  mp = Bc.isSequenceExpression,
  vp = Bc.isSwitchStatement,
  gp = Bc.isTSArrayType,
  bp = Bc.isTSAsExpression,
  Tp = Bc.isTSInstantiationExpression,
  Sp = Bc.isTSIntersectionType,
  xp = Bc.isTSNonNullExpression,
  Ep = Bc.isTSOptionalType,
  Pp = Bc.isTSRestType,
  Ap = Bc.isTSTypeAssertion,
  kp = Bc.isTSUnionType,
  wp = Bc.isTaggedTemplateExpression,
  Cp = Bc.isThrowStatement,
  Ip = Bc.isTypeAnnotation,
  Op = Bc.isUnaryLike,
  Np = Bc.isUnionTypeAnnotation,
  _p = Bc.isVariableDeclarator,
  Dp = Bc.isWhileStatement,
  Lp = Bc.isYieldExpression,
  Mp = Bc.isTSSatisfiesExpression,
  jp = {
    "||": 0,
    "??": 0,
    "|>": 0,
    "&&": 1,
    "|": 2,
    "^": 3,
    "&": 4,
    "==": 5,
    "===": 5,
    "!=": 5,
    "!==": 5,
    "<": 6,
    ">": 6,
    "<=": 6,
    ">=": 6,
    in: 6,
    instanceof: 6,
    ">>": 7,
    "<<": 7,
    ">>>": 7,
    "+": 8,
    "-": 8,
    "*": 9,
    "/": 9,
    "%": 9,
    "**": 10,
  };
function Fp(e) {
  return bp(e) || Mp(e) || Ap(e);
}
var Bp = function (e, t) {
    return Jc(t, { superClass: e });
  },
  Rp = function (e, t) {
    return (
      ((up(t) || fp(t)) && t.object === e) ||
      ((Yc(t) || dp(t) || cp(t)) && t.callee === e) ||
      (wp(t) && t.tag === e) ||
      xp(t)
    );
  };
function Up(e, t) {
  return Rp(e, t) || qc(t, { operator: "**", left: e }) || Bp(e, t);
}
function Vp(e, t) {
  return !!(Op(t) || Wc(t) || zc(t, { test: e }) || Kc(t) || Fp(t)) || Up(e, t);
}
function Kp(e, t) {
  var r = 1 & t,
    n = 2 & t,
    i = 4 & t,
    a = 8 & t,
    s = 16 & t,
    o = 32 & t,
    l = e.length - 1;
  if (!(l <= 0)) {
    for (var u = e[l], c = e[--l]; l >= 0; ) {
      if (
        (r && Zc(c, { expression: u })) ||
        (i && Qc(c, { declaration: u })) ||
        (n && Uc(c, { body: u })) ||
        (a && np(c, { init: u })) ||
        (s && tp(c, { left: u })) ||
        (o && rp(c, { left: u }))
      )
        return !0;
      if (
        !(
          l > 0 &&
          ((Rp(u, c) && !cp(c)) ||
            (mp(c) && c.expressions[0] === u) ||
            (Hc(c) && !c.prefix) ||
            Gc(c, { test: u }) ||
            Wc(c, { left: u }) ||
            Vc(c, { left: u }))
        )
      )
        return !1;
      (u = c), (c = e[--l]);
    }
    return !1;
  }
}
function Wp(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return qp(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return qp(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function qp(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(ki, "__esModule", { value: !0 }),
  (ki.needsParens = function (e, t, r) {
    if (!t) return !1;
    if (Qp(t) && t.callee === e && nh(e)) return !0;
    return rh(eh, e, t, r);
  }),
  (ki.needsWhitespace = ih),
  (ki.needsWhitespaceAfter = function (e, t) {
    return ih(e, t, 2);
  }),
  (ki.needsWhitespaceBefore = function (e, t) {
    return ih(e, t, 1);
  });
var Hp = wi,
  Yp = Fc,
  Jp = mc(),
  Xp = Jp.FLIPPED_ALIAS_KEYS,
  Gp = Jp.isCallExpression,
  zp = Jp.isExpressionStatement,
  $p = Jp.isMemberExpression,
  Qp = Jp.isNewExpression;
function Zp(e) {
  var t = {};
  function r(e, r) {
    var n = t[e];
    t[e] = n
      ? function (e, t, i) {
          var a = n(e, t, i);
          return null == a ? r(e, t, i) : a;
        }
      : r;
  }
  for (var n = 0, i = Object.keys(e); n < i.length; n++) {
    var a = i[n],
      s = Xp[a];
    if (s) {
      var o,
        l = Wp(s);
      try {
        for (l.s(); !(o = l.n()).done; ) {
          r(o.value, e[a]);
        }
      } catch (e) {
        l.e(e);
      } finally {
        l.f();
      }
    } else r(a, e[a]);
  }
  return t;
}
var eh = Zp(Yp),
  th = Zp(Hp.nodes);
function rh(e, t, r, n) {
  var i = e[t.type];
  return i ? i(t, r, n) : null;
}
function nh(e) {
  return !!Gp(e) || ($p(e) && nh(e.object));
}
function ih(e, t, r) {
  if (!e) return !1;
  zp(e) && (e = e.expression);
  var n = rh(th, e, t);
  return "number" == typeof n && 0 != (n & r);
}
var ah = {},
  sh = {};
Object.defineProperty(sh, "__esModule", { value: !0 }),
  (sh.TaggedTemplateExpression = function (e) {
    this.print(e.tag, e),
      this.print(e.typeParameters, e),
      this.print(e.quasi, e);
  }),
  (sh.TemplateElement = function (e, t) {
    var r = t.quasis[0] === e,
      n = t.quasis[t.quasis.length - 1] === e,
      i = (r ? "`" : "}") + e.value.raw + (n ? "`" : "${");
    this.token(i, !0);
  }),
  (sh.TemplateLiteral = function (e) {
    for (var t = e.quasis, r = 0; r < t.length; r++)
      this.print(t[r], e), r + 1 < t.length && this.print(e.expressions[r], e);
  });
var oh = {};
Object.defineProperty(oh, "__esModule", { value: !0 }),
  (oh.LogicalExpression =
    oh.BinaryExpression =
    oh.AssignmentExpression =
      function (e, t) {
        var r =
          this.inForStatementInitCounter &&
          "in" === e.operator &&
          !uh.needsParens(e, t);
        r && this.tokenChar(40);
        this.print(e.left, e),
          this.space(),
          "in" === e.operator || "instanceof" === e.operator
            ? this.word(e.operator)
            : this.token(e.operator);
        this.space(), this.print(e.right, e), r && this.tokenChar(41);
      }),
  (oh.AssignmentPattern = function (e) {
    this.print(e.left, e), e.left.optional && this.tokenChar(63);
    this.print(e.left.typeAnnotation, e),
      this.space(),
      this.tokenChar(61),
      this.space(),
      this.print(e.right, e);
  }),
  (oh.AwaitExpression = function (e) {
    this.word("await"),
      e.argument && (this.space(), this.printTerminatorless(e.argument, e, !1));
  }),
  (oh.BindExpression = function (e) {
    this.print(e.object, e), this.token("::"), this.print(e.callee, e);
  }),
  (oh.CallExpression = function (e) {
    this.print(e.callee, e),
      this.print(e.typeArguments, e),
      this.print(e.typeParameters, e),
      this.tokenChar(40),
      this.printList(e.arguments, e),
      this.rightParens(e);
  }),
  (oh.ConditionalExpression = function (e) {
    this.print(e.test, e),
      this.space(),
      this.tokenChar(63),
      this.space(),
      this.print(e.consequent, e),
      this.space(),
      this.tokenChar(58),
      this.space(),
      this.print(e.alternate, e);
  }),
  (oh.Decorator = function (e) {
    this.tokenChar(64);
    var t = e.expression;
    !(function (e) {
      if ("ParenthesizedExpression" === e.type) return !1;
      return !fh("CallExpression" === e.type ? e.callee : e);
    })(t)
      ? this.print(t, e)
      : (this.tokenChar(40), this.print(t, e), this.tokenChar(41));
    this.newline();
  }),
  (oh.DoExpression = function (e) {
    e.async && (this.word("async", !0), this.space());
    this.word("do"), this.space(), this.print(e.body, e);
  }),
  (oh.EmptyStatement = function () {
    this.semicolon(!0);
  }),
  (oh.ExpressionStatement = function (e) {
    this.print(e.expression, e), this.semicolon();
  }),
  (oh.Import = function () {
    this.word("import");
  }),
  (oh.MemberExpression = function (e) {
    if ((this.print(e.object, e), !e.computed && hh(e.property)))
      throw new TypeError(
        "Got a MemberExpression for MemberExpression property"
      );
    var t = e.computed;
    ph(e.property) && "number" == typeof e.property.value && (t = !0);
    t
      ? (this.tokenChar(91), this.print(e.property, e), this.tokenChar(93))
      : (this.tokenChar(46), this.print(e.property, e));
  }),
  (oh.MetaProperty = function (e) {
    this.print(e.meta, e), this.tokenChar(46), this.print(e.property, e);
  }),
  (oh.ModuleExpression = function (e) {
    this.word("module", !0), this.space(), this.tokenChar(123), this.indent();
    var t = e.body;
    (t.body.length || t.directives.length) && this.newline();
    this.print(t, e), this.dedent(), this.rightBrace(e);
  }),
  (oh.NewExpression = function (e, t) {
    if (
      (this.word("new"),
      this.space(),
      this.print(e.callee, e),
      this.format.minified &&
        0 === e.arguments.length &&
        !e.optional &&
        !ch(t, { callee: e }) &&
        !hh(t) &&
        !dh(t))
    )
      return;
    this.print(e.typeArguments, e),
      this.print(e.typeParameters, e),
      e.optional && this.token("?.");
    this.tokenChar(40), this.printList(e.arguments, e), this.rightParens(e);
  }),
  (oh.OptionalCallExpression = function (e) {
    this.print(e.callee, e),
      this.print(e.typeParameters, e),
      e.optional && this.token("?.");
    this.print(e.typeArguments, e),
      this.tokenChar(40),
      this.printList(e.arguments, e),
      this.rightParens(e);
  }),
  (oh.OptionalMemberExpression = function (e) {
    var t = e.computed,
      r = e.optional,
      n = e.property;
    if ((this.print(e.object, e), !t && hh(n)))
      throw new TypeError(
        "Got a MemberExpression for MemberExpression property"
      );
    ph(n) && "number" == typeof n.value && (t = !0);
    r && this.token("?.");
    t
      ? (this.tokenChar(91), this.print(n, e), this.tokenChar(93))
      : (r || this.tokenChar(46), this.print(n, e));
  }),
  (oh.ParenthesizedExpression = function (e) {
    this.tokenChar(40), this.print(e.expression, e), this.rightParens(e);
  }),
  (oh.PrivateName = function (e) {
    this.tokenChar(35), this.print(e.id, e);
  }),
  (oh.SequenceExpression = function (e) {
    this.printList(e.expressions, e);
  }),
  (oh.Super = function () {
    this.word("super");
  }),
  (oh.ThisExpression = function () {
    this.word("this");
  }),
  (oh.UnaryExpression = function (e) {
    var t = e.operator;
    "void" === t || "delete" === t || "typeof" === t || "throw" === t
      ? (this.word(t), this.space())
      : this.token(t);
    this.print(e.argument, e);
  }),
  (oh.UpdateExpression = function (e) {
    e.prefix
      ? (this.token(e.operator), this.print(e.argument, e))
      : (this.printTerminatorless(e.argument, e, !0), this.token(e.operator));
  }),
  (oh.V8IntrinsicIdentifier = function (e) {
    this.tokenChar(37), this.word(e.name);
  }),
  (oh.YieldExpression = function (e) {
    this.word("yield", !0),
      e.delegate
        ? (this.tokenChar(42),
          e.argument && (this.space(), this.print(e.argument, e)))
        : e.argument &&
          (this.space(), this.printTerminatorless(e.argument, e, !1));
  }),
  (oh._shouldPrintDecoratorsBeforeExport = function (e) {
    if ("boolean" == typeof this.format.decoratorsBeforeExport)
      return this.format.decoratorsBeforeExport;
    return "number" == typeof e.start && e.start === e.declaration.start;
  });
var lh = mc(),
  uh = ki,
  ch = lh.isCallExpression,
  ph = lh.isLiteral,
  hh = lh.isMemberExpression,
  dh = lh.isNewExpression;
function fh(e) {
  switch (e.type) {
    case "Identifier":
      return !0;
    case "MemberExpression":
      return !e.computed && "Identifier" === e.property.type && fh(e.object);
    default:
      return !1;
  }
}
var yh = {};
function mh(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return vh(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return vh(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function vh(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(yh, "__esModule", { value: !0 }),
  (yh.BreakStatement = function (e) {
    this.word("break"), wh(this, e.label, e, !0);
  }),
  (yh.CatchClause = function (e) {
    this.word("catch"),
      this.space(),
      e.param &&
        (this.tokenChar(40),
        this.print(e.param, e),
        this.print(e.param.typeAnnotation, e),
        this.tokenChar(41),
        this.space());
    this.print(e.body, e);
  }),
  (yh.ContinueStatement = function (e) {
    this.word("continue"), wh(this, e.label, e, !0);
  }),
  (yh.DebuggerStatement = function () {
    this.word("debugger"), this.semicolon();
  }),
  (yh.DoWhileStatement = function (e) {
    this.word("do"),
      this.space(),
      this.print(e.body, e),
      this.space(),
      this.word("while"),
      this.space(),
      this.tokenChar(40),
      this.print(e.test, e),
      this.tokenChar(41),
      this.semicolon();
  }),
  (yh.ForOfStatement = yh.ForInStatement = void 0),
  (yh.ForStatement = function (e) {
    this.word("for"),
      this.space(),
      this.tokenChar(40),
      this.inForStatementInitCounter++,
      this.print(e.init, e),
      this.inForStatementInitCounter--,
      this.tokenChar(59),
      e.test && (this.space(), this.print(e.test, e));
    this.tokenChar(59), e.update && (this.space(), this.print(e.update, e));
    this.tokenChar(41), this.printBlock(e);
  }),
  (yh.IfStatement = function (e) {
    this.word("if"),
      this.space(),
      this.tokenChar(40),
      this.print(e.test, e),
      this.tokenChar(41),
      this.space();
    var t = e.alternate && Sh(Eh(e.consequent));
    t && (this.tokenChar(123), this.newline(), this.indent());
    this.printAndIndentOnComments(e.consequent, e),
      t && (this.dedent(), this.newline(), this.tokenChar(125));
    e.alternate &&
      (this.endsWith(125) && this.space(),
      this.word("else"),
      this.space(),
      this.printAndIndentOnComments(e.alternate, e));
  }),
  (yh.LabeledStatement = function (e) {
    this.print(e.label, e),
      this.tokenChar(58),
      this.space(),
      this.print(e.body, e);
  }),
  (yh.ReturnStatement = function (e) {
    this.word("return"), wh(this, e.argument, e, !1);
  }),
  (yh.SwitchCase = function (e) {
    e.test
      ? (this.word("case"),
        this.space(),
        this.print(e.test, e),
        this.tokenChar(58))
      : (this.word("default"), this.tokenChar(58));
    e.consequent.length &&
      (this.newline(), this.printSequence(e.consequent, e, { indent: !0 }));
  }),
  (yh.SwitchStatement = function (e) {
    this.word("switch"),
      this.space(),
      this.tokenChar(40),
      this.print(e.discriminant, e),
      this.tokenChar(41),
      this.space(),
      this.tokenChar(123),
      this.printSequence(e.cases, e, {
        indent: !0,
        addNewlines: function (t, r) {
          if (!t && e.cases[e.cases.length - 1] === r) return -1;
        },
      }),
      this.rightBrace(e);
  }),
  (yh.ThrowStatement = function (e) {
    this.word("throw"), wh(this, e.argument, e, !1);
  }),
  (yh.TryStatement = function (e) {
    this.word("try"),
      this.space(),
      this.print(e.block, e),
      this.space(),
      e.handlers ? this.print(e.handlers[0], e) : this.print(e.handler, e);
    e.finalizer &&
      (this.space(),
      this.word("finally"),
      this.space(),
      this.print(e.finalizer, e));
  }),
  (yh.VariableDeclaration = function (e, t) {
    e.declare && (this.word("declare"), this.space());
    var r = e.kind;
    this.word(r, "using" === r), this.space();
    var n = !1;
    if (!bh(t)) {
      var i,
        a = mh(e.declarations);
      try {
        for (a.s(); !(i = a.n()).done; ) {
          i.value.init && (n = !0);
        }
      } catch (e) {
        a.e(e);
      } finally {
        a.f();
      }
    }
    if (
      (this.printList(e.declarations, e, {
        separator: n
          ? function () {
              this.tokenChar(44), this.newline();
            }
          : void 0,
        indent: e.declarations.length > 1,
      }),
      bh(t))
    )
      if (Th(t)) {
        if (t.init === e) return;
      } else if (t.left === e) return;
    this.semicolon();
  }),
  (yh.VariableDeclarator = function (e) {
    this.print(e.id, e), e.definite && this.tokenChar(33);
    this.print(e.id.typeAnnotation, e),
      e.init &&
        (this.space(), this.tokenChar(61), this.space(), this.print(e.init, e));
  }),
  (yh.WhileStatement = function (e) {
    this.word("while"),
      this.space(),
      this.tokenChar(40),
      this.print(e.test, e),
      this.tokenChar(41),
      this.printBlock(e);
  }),
  (yh.WithStatement = function (e) {
    this.word("with"),
      this.space(),
      this.tokenChar(40),
      this.print(e.object, e),
      this.tokenChar(41),
      this.printBlock(e);
  });
var gh = mc(),
  bh = gh.isFor,
  Th = gh.isForStatement,
  Sh = gh.isIfStatement,
  xh = gh.isStatement;
function Eh(e) {
  var t = e.body;
  return !1 === xh(t) ? e : Eh(t);
}
function Ph(e) {
  this.word("for"), this.space();
  var t = "ForOfStatement" === e.type;
  t && e.await && (this.word("await"), this.space()),
    this.noIndentInnerCommentsHere(),
    this.tokenChar(40),
    this.print(e.left, e),
    this.space(),
    this.word(t ? "of" : "in"),
    this.space(),
    this.print(e.right, e),
    this.tokenChar(41),
    this.printBlock(e);
}
var Ah = Ph;
yh.ForInStatement = Ah;
var kh = Ph;
function wh(e, t, r, n) {
  t && (e.space(), e.printTerminatorless(t, r, n)), e.semicolon();
}
yh.ForOfStatement = kh;
var Ch = {};
Object.defineProperty(Ch, "__esModule", { value: !0 }),
  (Ch.ClassAccessorProperty = function (e) {
    var t, r;
    this.printJoin(e.decorators, e);
    var n = null == (t = e.key.loc) || null == (r = t.end) ? void 0 : r.line;
    n && this.catchUp(n);
    this.tsPrintClassMemberModifiers(e),
      this.word("accessor", !0),
      this.space(),
      e.computed
        ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93))
        : (this._variance(e), this.print(e.key, e));
    e.optional && this.tokenChar(63);
    e.definite && this.tokenChar(33);
    this.print(e.typeAnnotation, e),
      e.value &&
        (this.space(),
        this.tokenChar(61),
        this.space(),
        this.print(e.value, e));
    this.semicolon();
  }),
  (Ch.ClassBody = function (e) {
    this.tokenChar(123),
      0 === e.body.length
        ? this.tokenChar(125)
        : (this.newline(),
          this.printSequence(e.body, e, { indent: !0 }),
          this.endsWith(10) || this.newline(),
          this.rightBrace(e));
  }),
  (Ch.ClassExpression = Ch.ClassDeclaration =
    function (e, t) {
      ((Oh(t) || Nh(t)) && this._shouldPrintDecoratorsBeforeExport(t)) ||
        this.printJoin(e.decorators, e);
      e.declare && (this.word("declare"), this.space());
      e.abstract && (this.word("abstract"), this.space());
      this.word("class"), e.id && (this.space(), this.print(e.id, e));
      this.print(e.typeParameters, e),
        e.superClass &&
          (this.space(),
          this.word("extends"),
          this.space(),
          this.print(e.superClass, e),
          this.print(e.superTypeParameters, e));
      e.implements &&
        (this.space(),
        this.word("implements"),
        this.space(),
        this.printList(e.implements, e));
      this.space(), this.print(e.body, e);
    }),
  (Ch.ClassMethod = function (e) {
    this._classMethodHead(e), this.space(), this.print(e.body, e);
  }),
  (Ch.ClassPrivateMethod = function (e) {
    this._classMethodHead(e), this.space(), this.print(e.body, e);
  }),
  (Ch.ClassPrivateProperty = function (e) {
    this.printJoin(e.decorators, e),
      e.static && (this.word("static"), this.space());
    this.print(e.key, e),
      this.print(e.typeAnnotation, e),
      e.value &&
        (this.space(),
        this.tokenChar(61),
        this.space(),
        this.print(e.value, e));
    this.semicolon();
  }),
  (Ch.ClassProperty = function (e) {
    var t, r;
    this.printJoin(e.decorators, e);
    var n = null == (t = e.key.loc) || null == (r = t.end) ? void 0 : r.line;
    n && this.catchUp(n);
    this.tsPrintClassMemberModifiers(e),
      e.computed
        ? (this.tokenChar(91), this.print(e.key, e), this.tokenChar(93))
        : (this._variance(e), this.print(e.key, e));
    e.optional && this.tokenChar(63);
    e.definite && this.tokenChar(33);
    this.print(e.typeAnnotation, e),
      e.value &&
        (this.space(),
        this.tokenChar(61),
        this.space(),
        this.print(e.value, e));
    this.semicolon();
  }),
  (Ch.StaticBlock = function (e) {
    this.word("static"),
      this.space(),
      this.tokenChar(123),
      0 === e.body.length
        ? this.tokenChar(125)
        : (this.newline(),
          this.printSequence(e.body, e, { indent: !0 }),
          this.rightBrace(e));
  }),
  (Ch._classMethodHead = function (e) {
    var t, r;
    this.printJoin(e.decorators, e);
    var n = null == (t = e.key.loc) || null == (r = t.end) ? void 0 : r.line;
    n && this.catchUp(n);
    this.tsPrintClassMemberModifiers(e), this._methodHead(e);
  });
var Ih = mc(),
  Oh = Ih.isExportDefaultDeclaration,
  Nh = Ih.isExportNamedDeclaration;
var _h = {};
Object.defineProperty(_h, "__esModule", { value: !0 }),
  (_h.ArrowFunctionExpression = function (e, t) {
    e.async && (this.word("async", !0), this.space());
    var r;
    this.format.retainLines ||
    1 !== e.params.length ||
    !Dh((r = e.params[0])) ||
    (function (e, t) {
      var r, n;
      return !!(
        e.typeParameters ||
        e.returnType ||
        e.predicate ||
        t.typeAnnotation ||
        t.optional ||
        (null != (r = t.leadingComments) && r.length) ||
        (null != (n = t.trailingComments) && n.length)
      );
    })(e, r)
      ? this._params(e, void 0, t)
      : this.print(r, e, !0);
    this._predicate(e, !0),
      this.space(),
      this.printInnerComments(),
      this.token("=>"),
      this.space(),
      this.print(e.body, e);
  }),
  (_h.FunctionDeclaration = _h.FunctionExpression =
    function (e, t) {
      this._functionHead(e, t), this.space(), this.print(e.body, e);
    }),
  (_h._functionHead = function (e, t) {
    e.async &&
      (this.word("async"), (this._endsWithInnerRaw = !1), this.space());
    this.word("function"),
      e.generator && ((this._endsWithInnerRaw = !1), this.tokenChar(42));
    this.space(), e.id && this.print(e.id, e);
    this._params(e, e.id, t),
      "TSDeclareFunction" !== e.type && this._predicate(e);
  }),
  (_h._methodHead = function (e) {
    var t = e.kind,
      r = e.key;
    ("get" !== t && "set" !== t) || (this.word(t), this.space());
    e.async && (this.word("async", !0), this.space());
    ("method" !== t && "init" !== t) || (e.generator && this.tokenChar(42));
    e.computed
      ? (this.tokenChar(91), this.print(r, e), this.tokenChar(93))
      : this.print(r, e);
    e.optional && this.tokenChar(63);
    this._params(
      e,
      e.computed && "StringLiteral" !== e.key.type ? void 0 : e.key,
      void 0
    );
  }),
  (_h._param = function (e, t) {
    this.printJoin(e.decorators, e),
      this.print(e, t),
      e.optional && this.tokenChar(63);
    this.print(e.typeAnnotation, e);
  }),
  (_h._parameters = function (e, t) {
    for (var r = e.length, n = 0; n < r; n++)
      this._param(e[n], t),
        n < e.length - 1 && (this.tokenChar(44), this.space());
  }),
  (_h._params = function (e, t, r) {
    this.print(e.typeParameters, e);
    var n = Lh.call(this, t, r);
    n && this.sourceIdentifierName(n.name, n.pos);
    this.tokenChar(40), this._parameters(e.params, e), this.tokenChar(41);
    var i = "ArrowFunctionExpression" === e.type;
    this.print(e.returnType, e, i), (this._noLineTerminator = i);
  }),
  (_h._predicate = function (e, t) {
    e.predicate &&
      (e.returnType || this.tokenChar(58),
      this.space(),
      this.print(e.predicate, e, t));
  });
var Dh = mc().isIdentifier;
function Lh(e, t) {
  var r = e;
  if (!r && t) {
    var n = t.type;
    "VariableDeclarator" === n
      ? (r = t.id)
      : "AssignmentExpression" === n || "AssignmentPattern" === n
      ? (r = t.left)
      : "ObjectProperty" === n || "ClassProperty" === n
      ? (t.computed && "StringLiteral" !== t.key.type) || (r = t.key)
      : ("ClassPrivateProperty" !== n && "ClassAccessorProperty" !== n) ||
        (r = t.key);
  }
  if (r) {
    var i, a, s;
    if ("Identifier" === r.type)
      i = {
        pos: null == (a = r.loc) ? void 0 : a.start,
        name: (null == (s = r.loc) ? void 0 : s.identifierName) || r.name,
      };
    else if ("PrivateName" === r.type) {
      var o;
      i = {
        pos: null == (o = r.loc) ? void 0 : o.start,
        name: "#" + r.id.name,
      };
    } else if ("StringLiteral" === r.type) {
      var l;
      i = { pos: null == (l = r.loc) ? void 0 : l.start, name: r.value };
    }
    return i;
  }
}
var Mh = {};
Object.defineProperty(Mh, "__esModule", { value: !0 }),
  (Mh.ExportAllDeclaration = function (e) {
    var t;
    this.word("export"),
      this.space(),
      "type" === e.exportKind && (this.word("type"), this.space());
    this.tokenChar(42),
      this.space(),
      this.word("from"),
      this.space(),
      null != (t = e.assertions) && t.length
        ? (this.print(e.source, e, !0), this.space(), this._printAssertions(e))
        : this.print(e.source, e);
    this.semicolon();
  }),
  (Mh.ExportDefaultDeclaration = function (e) {
    Wh(this, e),
      this.word("export"),
      this.noIndentInnerCommentsHere(),
      this.space(),
      this.word("default"),
      this.space();
    var t = e.declaration;
    this.print(t, e), Kh(t) || this.semicolon();
  }),
  (Mh.ExportDefaultSpecifier = function (e) {
    this.print(e.exported, e);
  }),
  (Mh.ExportNamedDeclaration = function (e) {
    if ((Wh(this, e), this.word("export"), this.space(), e.declaration)) {
      var t = e.declaration;
      this.print(t, e), Kh(t) || this.semicolon();
    } else {
      "type" === e.exportKind && (this.word("type"), this.space());
      for (var r, n = e.specifiers.slice(0), i = !1; ; ) {
        var a = n[0];
        if (!Bh(a) && !Rh(a)) break;
        (i = !0),
          this.print(n.shift(), e),
          n.length && (this.tokenChar(44), this.space());
      }
      if (
        ((n.length || (!n.length && !i)) &&
          (this.tokenChar(123),
          n.length && (this.space(), this.printList(n, e), this.space()),
          this.tokenChar(125)),
        e.source)
      )
        this.space(),
          this.word("from"),
          this.space(),
          null != (r = e.assertions) && r.length
            ? (this.print(e.source, e, !0),
              this.space(),
              this._printAssertions(e))
            : this.print(e.source, e);
      this.semicolon();
    }
  }),
  (Mh.ExportNamespaceSpecifier = function (e) {
    this.tokenChar(42),
      this.space(),
      this.word("as"),
      this.space(),
      this.print(e.exported, e);
  }),
  (Mh.ExportSpecifier = function (e) {
    "type" === e.exportKind && (this.word("type"), this.space());
    this.print(e.local, e),
      e.exported &&
        e.local.name !== e.exported.name &&
        (this.space(),
        this.word("as"),
        this.space(),
        this.print(e.exported, e));
  }),
  (Mh.ImportAttribute = function (e) {
    this.print(e.key), this.tokenChar(58), this.space(), this.print(e.value);
  }),
  (Mh.ImportDeclaration = function (e) {
    var t;
    this.word("import"), this.space();
    var r = "type" === e.importKind || "typeof" === e.importKind;
    r
      ? (this.noIndentInnerCommentsHere(),
        this.word(e.importKind),
        this.space())
      : e.module &&
        (this.noIndentInnerCommentsHere(), this.word("module"), this.space());
    var n,
      i = e.specifiers.slice(0),
      a = !!i.length;
    for (; a; ) {
      var s = i[0];
      if (!Uh(s) && !Vh(s)) break;
      this.print(i.shift(), e), i.length && (this.tokenChar(44), this.space());
    }
    i.length
      ? (this.tokenChar(123),
        this.space(),
        this.printList(i, e),
        this.space(),
        this.tokenChar(125))
      : r && !a && (this.tokenChar(123), this.tokenChar(125));
    (a || r) && (this.space(), this.word("from"), this.space());
    null != (t = e.assertions) && t.length
      ? (this.print(e.source, e, !0), this.space(), this._printAssertions(e))
      : this.print(e.source, e);
    null != (n = e.attributes) &&
      n.length &&
      (this.space(),
      this.word("with"),
      this.space(),
      this.printList(e.attributes, e));
    this.semicolon();
  }),
  (Mh.ImportDefaultSpecifier = function (e) {
    this.print(e.local, e);
  }),
  (Mh.ImportNamespaceSpecifier = function (e) {
    this.tokenChar(42),
      this.space(),
      this.word("as"),
      this.space(),
      this.print(e.local, e);
  }),
  (Mh.ImportSpecifier = function (e) {
    ("type" !== e.importKind && "typeof" !== e.importKind) ||
      (this.word(e.importKind), this.space());
    this.print(e.imported, e),
      e.local &&
        e.local.name !== e.imported.name &&
        (this.space(), this.word("as"), this.space(), this.print(e.local, e));
  }),
  (Mh._printAssertions = function (e) {
    this.word("assert"),
      this.space(),
      this.tokenChar(123),
      this.space(),
      this.printList(e.assertions, e),
      this.space(),
      this.tokenChar(125);
  });
var jh = mc(),
  Fh = jh.isClassDeclaration,
  Bh = jh.isExportDefaultSpecifier,
  Rh = jh.isExportNamespaceSpecifier,
  Uh = jh.isImportDefaultSpecifier,
  Vh = jh.isImportNamespaceSpecifier,
  Kh = jh.isStatement;
function Wh(e, t) {
  Fh(t.declaration) &&
    e._shouldPrintDecoratorsBeforeExport(t) &&
    e.printJoin(t.declaration.decorators, t);
}
var qh = {},
  Hh = {},
  Yh = Hh.hasOwnProperty,
  Jh = function (e, t) {
    for (var r in e) Yh.call(e, r) && t(r, e[r]);
  },
  Xh = Hh.toString,
  Gh = Array.isArray,
  zh = Buffer.isBuffer,
  $h = {
    '"': '\\"',
    "'": "\\'",
    "\\": "\\\\",
    "\b": "\\b",
    "\f": "\\f",
    "\n": "\\n",
    "\r": "\\r",
    "\t": "\\t",
  },
  Qh = /["'\\\b\f\n\r\t]/,
  Zh = /[0-9]/,
  ed = /[ !#-&\(-\[\]-_a-~]/,
  td = function e(t, r) {
    var n,
      i,
      a = function () {
        (d = h), ++r.indentLevel, (h = r.indent.repeat(r.indentLevel));
      },
      s = {
        escapeEverything: !1,
        minimal: !1,
        isScriptContext: !1,
        quotes: "single",
        wrap: !1,
        es6: !1,
        json: !1,
        compact: !0,
        lowercaseHex: !1,
        numbers: "decimal",
        indent: "\t",
        indentLevel: 0,
        __inline1__: !1,
        __inline2__: !1,
      },
      o = r && r.json;
    o && ((s.quotes = "double"), (s.wrap = !0)),
      (n = s),
      (r = (i = r)
        ? (Jh(i, function (e, t) {
            n[e] = t;
          }),
          n)
        : n),
      "single" != r.quotes &&
        "double" != r.quotes &&
        "backtick" != r.quotes &&
        (r.quotes = "single");
    var l,
      u = "double" == r.quotes ? '"' : "backtick" == r.quotes ? "`" : "'",
      c = r.compact,
      p = r.lowercaseHex,
      h = r.indent.repeat(r.indentLevel),
      d = "",
      f = r.__inline1__,
      y = r.__inline2__,
      m = c ? "" : "\n",
      v = !0,
      g = "binary" == r.numbers,
      b = "octal" == r.numbers,
      T = "decimal" == r.numbers,
      S = "hexadecimal" == r.numbers;
    if (
      (o && t && "function" == typeof t.toJSON && (t = t.toJSON()),
      !(function (e) {
        return "string" == typeof e || "[object String]" == Xh.call(e);
      })(t))
    ) {
      if (
        (function (e) {
          return "[object Map]" == Xh.call(e);
        })(t)
      )
        return 0 == t.size
          ? "new Map()"
          : (c || ((r.__inline1__ = !0), (r.__inline2__ = !1)),
            "new Map(" + e(Array.from(t), r) + ")");
      if (
        (function (e) {
          return "[object Set]" == Xh.call(e);
        })(t)
      )
        return 0 == t.size
          ? "new Set()"
          : "new Set(" + e(Array.from(t), r) + ")";
      if (zh(t))
        return 0 == t.length
          ? "Buffer.from([])"
          : "Buffer.from(" + e(Array.from(t), r) + ")";
      if (Gh(t))
        return (
          (l = []),
          (r.wrap = !0),
          f && ((r.__inline1__ = !1), (r.__inline2__ = !0)),
          y || a(),
          (function (e, t) {
            for (var r = e.length, n = -1; ++n < r; ) t(e[n]);
          })(t, function (t) {
            (v = !1),
              y && (r.__inline2__ = !1),
              l.push((c || y ? "" : h) + e(t, r));
          }),
          v
            ? "[]"
            : y
            ? "[" + l.join(", ") + "]"
            : "[" + m + l.join("," + m) + m + (c ? "" : d) + "]"
        );
      if (
        !(function (e) {
          return "number" == typeof e || "[object Number]" == Xh.call(e);
        })(t)
      )
        return (function (e) {
          return "[object Object]" == Xh.call(e);
        })(t)
          ? ((l = []),
            (r.wrap = !0),
            a(),
            Jh(t, function (t, n) {
              (v = !1),
                l.push((c ? "" : h) + e(t, r) + ":" + (c ? "" : " ") + e(n, r));
            }),
            v ? "{}" : "{" + m + l.join("," + m) + m + (c ? "" : d) + "}")
          : o
          ? JSON.stringify(t) || "null"
          : String(t);
      if (o) return JSON.stringify(t);
      if (T) return String(t);
      if (S) {
        var x = t.toString(16);
        return p || (x = x.toUpperCase()), "0x" + x;
      }
      if (g) return "0b" + t.toString(2);
      if (b) return "0o" + t.toString(8);
    }
    var E = t,
      P = -1,
      A = E.length;
    for (l = ""; ++P < A; ) {
      var k = E.charAt(P);
      if (r.es6) {
        var w = E.charCodeAt(P);
        if (w >= 55296 && w <= 56319 && A > P + 1) {
          var C = E.charCodeAt(P + 1);
          if (C >= 56320 && C <= 57343) {
            var I = (1024 * (w - 55296) + C - 56320 + 65536).toString(16);
            p || (I = I.toUpperCase()), (l += "\\u{" + I + "}"), ++P;
            continue;
          }
        }
      }
      if (!r.escapeEverything) {
        if (ed.test(k)) {
          l += k;
          continue;
        }
        if ('"' == k) {
          l += u == k ? '\\"' : k;
          continue;
        }
        if ("`" == k) {
          l += u == k ? "\\`" : k;
          continue;
        }
        if ("'" == k) {
          l += u == k ? "\\'" : k;
          continue;
        }
      }
      if ("\0" != k || o || Zh.test(E.charAt(P + 1)))
        if (Qh.test(k)) l += $h[k];
        else {
          var O = k.charCodeAt(0);
          if (r.minimal && 8232 != O && 8233 != O) l += k;
          else {
            var N = O.toString(16);
            p || (N = N.toUpperCase());
            var _ = N.length > 2 || o,
              D = "\\" + (_ ? "u" : "x") + ("0000" + N).slice(_ ? -4 : -2);
            l += D;
          }
        }
      else l += "\\0";
    }
    return (
      r.wrap && (l = u + l + u),
      "`" == u && (l = l.replace(/\$\{/g, "\\${")),
      r.isScriptContext
        ? l
            .replace(/<\/(script|style)/gi, "<\\/$1")
            .replace(/<!--/g, o ? "\\u003C!--" : "\\x3C!--")
        : l
    );
  };
td.version = "2.5.2";
var rd = td;
Object.defineProperty(qh, "__esModule", { value: !0 }),
  (qh.ArgumentPlaceholder = function () {
    this.tokenChar(63);
  }),
  (qh.ArrayPattern = qh.ArrayExpression =
    function (e) {
      var t = e.elements,
        r = t.length;
      this.tokenChar(91);
      for (var n = 0; n < t.length; n++) {
        var i = t[n];
        i
          ? (n > 0 && this.space(),
            this.print(i, e),
            n < r - 1 && this.tokenChar(44))
          : this.tokenChar(44);
      }
      this.tokenChar(93);
    }),
  (qh.BigIntLiteral = function (e) {
    var t = this.getPossibleRaw(e);
    if (!this.format.minified && void 0 !== t) return void this.word(t);
    this.word(e.value + "n");
  }),
  (qh.BooleanLiteral = function (e) {
    this.word(e.value ? "true" : "false");
  }),
  (qh.DecimalLiteral = function (e) {
    var t = this.getPossibleRaw(e);
    if (!this.format.minified && void 0 !== t) return void this.word(t);
    this.word(e.value + "m");
  }),
  (qh.Identifier = function (e) {
    var t;
    this.sourceIdentifierName(
      (null == (t = e.loc) ? void 0 : t.identifierName) || e.name
    ),
      this.word(e.name);
  }),
  (qh.NullLiteral = function () {
    this.word("null");
  }),
  (qh.NumericLiteral = function (e) {
    var t = this.getPossibleRaw(e),
      r = this.format.jsescOption,
      n = e.value + "";
    r.numbers
      ? this.number(id(e.value, r))
      : null == t
      ? this.number(n)
      : this.format.minified
      ? this.number(t.length < n.length ? t : n)
      : this.number(t);
  }),
  (qh.ObjectPattern = qh.ObjectExpression =
    function (e) {
      var t = e.properties;
      this.tokenChar(123),
        t.length &&
          (this.space(),
          this.printList(t, e, { indent: !0, statement: !0 }),
          this.space());
      this.sourceWithOffset("end", e.loc, 0, -1), this.tokenChar(125);
    }),
  (qh.ObjectMethod = function (e) {
    this.printJoin(e.decorators, e),
      this._methodHead(e),
      this.space(),
      this.print(e.body, e);
  }),
  (qh.ObjectProperty = function (e) {
    if ((this.printJoin(e.decorators, e), e.computed))
      this.tokenChar(91), this.print(e.key, e), this.tokenChar(93);
    else {
      if (ad(e.value) && sd(e.key) && e.key.name === e.value.left.name)
        return void this.print(e.value, e);
      if (
        (this.print(e.key, e),
        e.shorthand && sd(e.key) && sd(e.value) && e.key.name === e.value.name)
      )
        return;
    }
    this.tokenChar(58), this.space(), this.print(e.value, e);
  }),
  (qh.PipelineBareFunction = function (e) {
    this.print(e.callee, e);
  }),
  (qh.PipelinePrimaryTopicReference = function () {
    this.tokenChar(35);
  }),
  (qh.PipelineTopicExpression = function (e) {
    this.print(e.expression, e);
  }),
  (qh.RecordExpression = function (e) {
    var t,
      r,
      n = e.properties;
    if ("bar" === this.format.recordAndTupleSyntaxType) (t = "{|"), (r = "|}");
    else {
      if (
        "hash" !== this.format.recordAndTupleSyntaxType &&
        null != this.format.recordAndTupleSyntaxType
      )
        throw new Error(
          'The "recordAndTupleSyntaxType" generator option must be "bar" or "hash" ('.concat(
            JSON.stringify(this.format.recordAndTupleSyntaxType),
            " received)."
          )
        );
      (t = "#{"), (r = "}");
    }
    this.token(t),
      n.length &&
        (this.space(),
        this.printList(n, e, { indent: !0, statement: !0 }),
        this.space());
    this.token(r);
  }),
  (qh.RegExpLiteral = function (e) {
    this.word("/".concat(e.pattern, "/").concat(e.flags));
  }),
  (qh.SpreadElement = qh.RestElement =
    function (e) {
      this.token("..."), this.print(e.argument, e);
    }),
  (qh.StringLiteral = function (e) {
    var t = this.getPossibleRaw(e);
    if (!this.format.minified && void 0 !== t) return void this.token(t);
    var r = id(e.value, this.format.jsescOption);
    this.token(r);
  }),
  (qh.TopicReference = function () {
    var e = this.format.topicToken;
    if (!od.has(e)) {
      var t = JSON.stringify(e),
        r = Array.from(od, function (e) {
          return JSON.stringify(e);
        });
      throw new Error(
        'The "topicToken" generator option must be one of ' +
          "".concat(r.join(", "), " (").concat(t, " received instead).")
      );
    }
    this.token(e);
  }),
  (qh.TupleExpression = function (e) {
    var t,
      r,
      n = e.elements,
      i = n.length;
    if ("bar" === this.format.recordAndTupleSyntaxType) (t = "[|"), (r = "|]");
    else {
      if ("hash" !== this.format.recordAndTupleSyntaxType)
        throw new Error(
          "".concat(
            this.format.recordAndTupleSyntaxType,
            " is not a valid recordAndTuple syntax type"
          )
        );
      (t = "#["), (r = "]");
    }
    this.token(t);
    for (var a = 0; a < n.length; a++) {
      var s = n[a];
      s &&
        (a > 0 && this.space(),
        this.print(s, e),
        a < i - 1 && this.tokenChar(44));
    }
    this.token(r);
  });
var nd = mc(),
  id = rd,
  ad = nd.isAssignmentPattern,
  sd = nd.isIdentifier;
var od = new Set(["^^", "@@", "^", "%", "#"]);
var ld = {};
function ud(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return cd(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return cd(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function cd(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
!(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }),
    (e.AnyTypeAnnotation = function () {
      this.word("any");
    }),
    (e.ArrayTypeAnnotation = function (e) {
      this.print(e.elementType, e, !0), this.tokenChar(91), this.tokenChar(93);
    }),
    (e.BooleanLiteralTypeAnnotation = function (e) {
      this.word(e.value ? "true" : "false");
    }),
    (e.BooleanTypeAnnotation = function () {
      this.word("boolean");
    }),
    (e.DeclareClass = function (e, t) {
      i(t) || (this.word("declare"), this.space());
      this.word("class"), this.space(), this._interfaceish(e);
    }),
    (e.DeclareExportAllDeclaration = function (e) {
      this.word("declare"), this.space(), r.ExportAllDeclaration.call(this, e);
    }),
    (e.DeclareExportDeclaration = function (e) {
      this.word("declare"),
        this.space(),
        this.word("export"),
        this.space(),
        e.default && (this.word("default"), this.space());
      u.call(this, e);
    }),
    (e.DeclareFunction = function (e, t) {
      i(t) || (this.word("declare"), this.space());
      this.word("function"),
        this.space(),
        this.print(e.id, e),
        this.print(e.id.typeAnnotation.typeAnnotation, e),
        e.predicate && (this.space(), this.print(e.predicate, e));
      this.semicolon();
    }),
    (e.DeclareInterface = function (e) {
      this.word("declare"), this.space(), this.InterfaceDeclaration(e);
    }),
    (e.DeclareModule = function (e) {
      this.word("declare"),
        this.space(),
        this.word("module"),
        this.space(),
        this.print(e.id, e),
        this.space(),
        this.print(e.body, e);
    }),
    (e.DeclareModuleExports = function (e) {
      this.word("declare"),
        this.space(),
        this.word("module"),
        this.tokenChar(46),
        this.word("exports"),
        this.print(e.typeAnnotation, e);
    }),
    (e.DeclareOpaqueType = function (e, t) {
      i(t) || (this.word("declare"), this.space());
      this.OpaqueType(e);
    }),
    (e.DeclareTypeAlias = function (e) {
      this.word("declare"), this.space(), this.TypeAlias(e);
    }),
    (e.DeclareVariable = function (e, t) {
      i(t) || (this.word("declare"), this.space());
      this.word("var"),
        this.space(),
        this.print(e.id, e),
        this.print(e.id.typeAnnotation, e),
        this.semicolon();
    }),
    (e.DeclaredPredicate = function (e) {
      this.tokenChar(37),
        this.word("checks"),
        this.tokenChar(40),
        this.print(e.value, e),
        this.tokenChar(41);
    }),
    (e.EmptyTypeAnnotation = function () {
      this.word("empty");
    }),
    (e.EnumBooleanBody = function (e) {
      var t = e.explicitType;
      s(this, "boolean", t), o(this, e);
    }),
    (e.EnumBooleanMember = function (e) {
      l(this, e);
    }),
    (e.EnumDeclaration = function (e) {
      var t = e.id,
        r = e.body;
      this.word("enum"), this.space(), this.print(t, e), this.print(r, e);
    }),
    (e.EnumDefaultedMember = function (e) {
      var t = e.id;
      this.print(t, e), this.tokenChar(44);
    }),
    (e.EnumNumberBody = function (e) {
      var t = e.explicitType;
      s(this, "number", t), o(this, e);
    }),
    (e.EnumNumberMember = function (e) {
      l(this, e);
    }),
    (e.EnumStringBody = function (e) {
      var t = e.explicitType;
      s(this, "string", t), o(this, e);
    }),
    (e.EnumStringMember = function (e) {
      l(this, e);
    }),
    (e.EnumSymbolBody = function (e) {
      s(this, "symbol", !0), o(this, e);
    }),
    (e.ExistsTypeAnnotation = function () {
      this.tokenChar(42);
    }),
    (e.FunctionTypeAnnotation = function (e, t) {
      this.print(e.typeParameters, e),
        this.tokenChar(40),
        e.this &&
          (this.word("this"),
          this.tokenChar(58),
          this.space(),
          this.print(e.this.typeAnnotation, e),
          (e.params.length || e.rest) && (this.tokenChar(44), this.space()));
      this.printList(e.params, e),
        e.rest &&
          (e.params.length && (this.tokenChar(44), this.space()),
          this.token("..."),
          this.print(e.rest, e));
      this.tokenChar(41);
      var r = null == t ? void 0 : t.type;
      null != r &&
      ("ObjectTypeCallProperty" === r ||
        "ObjectTypeInternalSlot" === r ||
        "DeclareFunction" === r ||
        ("ObjectTypeProperty" === r && t.method))
        ? this.tokenChar(58)
        : (this.space(), this.token("=>"));
      this.space(), this.print(e.returnType, e);
    }),
    (e.FunctionTypeParam = function (e) {
      this.print(e.name, e), e.optional && this.tokenChar(63);
      e.name && (this.tokenChar(58), this.space());
      this.print(e.typeAnnotation, e);
    }),
    (e.IndexedAccessType = function (e) {
      this.print(e.objectType, e, !0),
        this.tokenChar(91),
        this.print(e.indexType, e),
        this.tokenChar(93);
    }),
    (e.InferredPredicate = function () {
      this.tokenChar(37), this.word("checks");
    }),
    (e.InterfaceDeclaration = function (e) {
      this.word("interface"), this.space(), this._interfaceish(e);
    }),
    (e.GenericTypeAnnotation =
      e.ClassImplements =
      e.InterfaceExtends =
        function (e) {
          this.print(e.id, e), this.print(e.typeParameters, e, !0);
        }),
    (e.InterfaceTypeAnnotation = function (e) {
      var t;
      this.word("interface"),
        null != (t = e.extends) &&
          t.length &&
          (this.space(),
          this.word("extends"),
          this.space(),
          this.printList(e.extends, e));
      this.space(), this.print(e.body, e);
    }),
    (e.IntersectionTypeAnnotation = function (e) {
      this.printJoin(e.types, e, { separator: c });
    }),
    (e.MixedTypeAnnotation = function () {
      this.word("mixed");
    }),
    (e.NullLiteralTypeAnnotation = function () {
      this.word("null");
    }),
    (e.NullableTypeAnnotation = function (e) {
      this.tokenChar(63), this.print(e.typeAnnotation, e);
    }),
    Object.defineProperty(e, "NumberLiteralTypeAnnotation", {
      enumerable: !0,
      get: function () {
        return n.NumericLiteral;
      },
    }),
    (e.NumberTypeAnnotation = function () {
      this.word("number");
    }),
    (e.ObjectTypeAnnotation = function (e) {
      var t = this;
      e.exact ? this.token("{|") : this.tokenChar(123);
      var r = [].concat(
        K(e.properties),
        K(e.callProperties || []),
        K(e.indexers || []),
        K(e.internalSlots || [])
      );
      r.length &&
        (this.newline(),
        this.space(),
        this.printJoin(r, e, {
          addNewlines: function (e) {
            if (e && !r[0]) return 1;
          },
          indent: !0,
          statement: !0,
          iterator: function () {
            (1 !== r.length || e.inexact) && (t.tokenChar(44), t.space());
          },
        }),
        this.space());
      e.inexact &&
        (this.indent(),
        this.token("..."),
        r.length && this.newline(),
        this.dedent());
      e.exact ? this.token("|}") : this.tokenChar(125);
    }),
    (e.ObjectTypeCallProperty = function (e) {
      e.static && (this.word("static"), this.space());
      this.print(e.value, e);
    }),
    (e.ObjectTypeIndexer = function (e) {
      e.static && (this.word("static"), this.space());
      this._variance(e),
        this.tokenChar(91),
        e.id && (this.print(e.id, e), this.tokenChar(58), this.space());
      this.print(e.key, e),
        this.tokenChar(93),
        this.tokenChar(58),
        this.space(),
        this.print(e.value, e);
    }),
    (e.ObjectTypeInternalSlot = function (e) {
      e.static && (this.word("static"), this.space());
      this.tokenChar(91),
        this.tokenChar(91),
        this.print(e.id, e),
        this.tokenChar(93),
        this.tokenChar(93),
        e.optional && this.tokenChar(63);
      e.method || (this.tokenChar(58), this.space());
      this.print(e.value, e);
    }),
    (e.ObjectTypeProperty = function (e) {
      e.proto && (this.word("proto"), this.space());
      e.static && (this.word("static"), this.space());
      ("get" !== e.kind && "set" !== e.kind) ||
        (this.word(e.kind), this.space());
      this._variance(e), this.print(e.key, e), e.optional && this.tokenChar(63);
      e.method || (this.tokenChar(58), this.space());
      this.print(e.value, e);
    }),
    (e.ObjectTypeSpreadProperty = function (e) {
      this.token("..."), this.print(e.argument, e);
    }),
    (e.OpaqueType = function (e) {
      this.word("opaque"),
        this.space(),
        this.word("type"),
        this.space(),
        this.print(e.id, e),
        this.print(e.typeParameters, e),
        e.supertype &&
          (this.tokenChar(58), this.space(), this.print(e.supertype, e));
      e.impltype &&
        (this.space(),
        this.tokenChar(61),
        this.space(),
        this.print(e.impltype, e));
      this.semicolon();
    }),
    (e.OptionalIndexedAccessType = function (e) {
      this.print(e.objectType, e), e.optional && this.token("?.");
      this.tokenChar(91), this.print(e.indexType, e), this.tokenChar(93);
    }),
    (e.QualifiedTypeIdentifier = function (e) {
      this.print(e.qualification, e), this.tokenChar(46), this.print(e.id, e);
    }),
    Object.defineProperty(e, "StringLiteralTypeAnnotation", {
      enumerable: !0,
      get: function () {
        return n.StringLiteral;
      },
    }),
    (e.StringTypeAnnotation = function () {
      this.word("string");
    }),
    (e.SymbolTypeAnnotation = function () {
      this.word("symbol");
    }),
    (e.ThisTypeAnnotation = function () {
      this.word("this");
    }),
    (e.TupleTypeAnnotation = function (e) {
      this.tokenChar(91), this.printList(e.types, e), this.tokenChar(93);
    }),
    (e.TypeAlias = function (e) {
      this.word("type"),
        this.space(),
        this.print(e.id, e),
        this.print(e.typeParameters, e),
        this.space(),
        this.tokenChar(61),
        this.space(),
        this.print(e.right, e),
        this.semicolon();
    }),
    (e.TypeAnnotation = function (e) {
      this.tokenChar(58), this.space(), e.optional && this.tokenChar(63);
      this.print(e.typeAnnotation, e);
    }),
    (e.TypeCastExpression = function (e) {
      this.tokenChar(40),
        this.print(e.expression, e),
        this.print(e.typeAnnotation, e),
        this.tokenChar(41);
    }),
    (e.TypeParameter = function (e) {
      this._variance(e), this.word(e.name), e.bound && this.print(e.bound, e);
      e.default &&
        (this.space(),
        this.tokenChar(61),
        this.space(),
        this.print(e.default, e));
    }),
    (e.TypeParameterDeclaration = e.TypeParameterInstantiation =
      function (e) {
        this.tokenChar(60), this.printList(e.params, e, {}), this.tokenChar(62);
      }),
    (e.TypeofTypeAnnotation = function (e) {
      this.word("typeof"), this.space(), this.print(e.argument, e);
    }),
    (e.UnionTypeAnnotation = function (e) {
      this.printJoin(e.types, e, { separator: p });
    }),
    (e.Variance = function (e) {
      "plus" === e.kind ? this.tokenChar(43) : this.tokenChar(45);
    }),
    (e.VoidTypeAnnotation = function () {
      this.word("void");
    }),
    (e._interfaceish = function (e) {
      var t;
      this.print(e.id, e),
        this.print(e.typeParameters, e),
        null != (t = e.extends) &&
          t.length &&
          (this.space(),
          this.word("extends"),
          this.space(),
          this.printList(e.extends, e));
      if ("DeclareClass" === e.type) {
        var r, n;
        null != (r = e.mixins) &&
          r.length &&
          (this.space(),
          this.word("mixins"),
          this.space(),
          this.printList(e.mixins, e)),
          null != (n = e.implements) &&
            n.length &&
            (this.space(),
            this.word("implements"),
            this.space(),
            this.printList(e.implements, e));
      }
      this.space(), this.print(e.body, e);
    }),
    (e._variance = function (e) {
      var t,
        r = null == (t = e.variance) ? void 0 : t.kind;
      null != r &&
        ("plus" === r
          ? this.tokenChar(43)
          : "minus" === r && this.tokenChar(45));
    });
  var t = mc(),
    r = Mh,
    n = qh,
    i = t.isDeclareExportDeclaration,
    a = t.isStatement;
  function s(e, t, r) {
    r && (e.space(), e.word("of"), e.space(), e.word(t)), e.space();
  }
  function o(e, t) {
    var r = t.members;
    e.token("{"), e.indent(), e.newline();
    var n,
      i = ud(r);
    try {
      for (i.s(); !(n = i.n()).done; ) {
        var a = n.value;
        e.print(a, t), e.newline();
      }
    } catch (e) {
      i.e(e);
    } finally {
      i.f();
    }
    t.hasUnknownMembers && (e.token("..."), e.newline()),
      e.dedent(),
      e.token("}");
  }
  function l(e, t) {
    var r = t.id,
      n = t.init;
    e.print(r, t),
      e.space(),
      e.token("="),
      e.space(),
      e.print(n, t),
      e.token(",");
  }
  function u(e) {
    if (e.declaration) {
      var t = e.declaration;
      this.print(t, e), a(t) || this.semicolon();
    } else
      this.tokenChar(123),
        e.specifiers.length &&
          (this.space(), this.printList(e.specifiers, e), this.space()),
        this.tokenChar(125),
        e.source &&
          (this.space(),
          this.word("from"),
          this.space(),
          this.print(e.source, e)),
        this.semicolon();
  }
  function c() {
    this.space(), this.tokenChar(38), this.space();
  }
  function p() {
    this.space(), this.tokenChar(124), this.space();
  }
})(ld);
var pd = {};
Object.defineProperty(pd, "__esModule", { value: !0 }),
  (pd.BlockStatement = function (e) {
    var t;
    this.tokenChar(123);
    var r = null == (t = e.directives) ? void 0 : t.length;
    if (r) {
      var n,
        i = e.body.length ? 2 : 1;
      this.printSequence(e.directives, e, {
        indent: !0,
        trailingCommentsLineOffset: i,
      }),
        (null != (n = e.directives[r - 1].trailingComments) && n.length) ||
          this.newline(i);
    }
    this.printSequence(e.body, e, { indent: !0 }), this.rightBrace(e);
  }),
  (pd.Directive = function (e) {
    this.print(e.value, e), this.semicolon();
  }),
  (pd.DirectiveLiteral = function (e) {
    var t = this.getPossibleRaw(e);
    if (!this.format.minified && void 0 !== t) return void this.token(t);
    var r = e.value;
    if (dd.test(r)) {
      if (hd.test(r))
        throw new Error(
          "Malformed AST: it is not possible to print a directive containing both unescaped single and double quotes."
        );
      this.token("'".concat(r, "'"));
    } else this.token('"'.concat(r, '"'));
  }),
  (pd.File = function (e) {
    e.program && this.print(e.program.interpreter, e);
    this.print(e.program, e);
  }),
  (pd.InterpreterDirective = function (e) {
    this.token("#!".concat(e.value)), this.newline(1, !0);
  }),
  (pd.Placeholder = function (e) {
    this.token("%%"),
      this.print(e.name),
      this.token("%%"),
      "Statement" === e.expectedNode && this.semicolon();
  }),
  (pd.Program = function (e) {
    var t;
    this.noIndentInnerCommentsHere(), this.printInnerComments();
    var r = null == (t = e.directives) ? void 0 : t.length;
    if (r) {
      var n,
        i = e.body.length ? 2 : 1;
      this.printSequence(e.directives, e, { trailingCommentsLineOffset: i }),
        (null != (n = e.directives[r - 1].trailingComments) && n.length) ||
          this.newline(i);
    }
    this.printSequence(e.body, e);
  });
var hd = /(?:^|[^\\])(?:\\\\)*'/,
  dd = /(?:^|[^\\])(?:\\\\)*"/;
var fd = {};
function yd(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return md(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return md(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function md(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function vd() {
  this.space();
}
Object.defineProperty(fd, "__esModule", { value: !0 }),
  (fd.JSXAttribute = function (e) {
    this.print(e.name, e),
      e.value && (this.tokenChar(61), this.print(e.value, e));
  }),
  (fd.JSXClosingElement = function (e) {
    this.token("</"), this.print(e.name, e), this.tokenChar(62);
  }),
  (fd.JSXClosingFragment = function () {
    this.token("</"), this.tokenChar(62);
  }),
  (fd.JSXElement = function (e) {
    var t = e.openingElement;
    if ((this.print(t, e), t.selfClosing)) return;
    this.indent();
    var r,
      n = yd(e.children);
    try {
      for (n.s(); !(r = n.n()).done; ) {
        var i = r.value;
        this.print(i, e);
      }
    } catch (e) {
      n.e(e);
    } finally {
      n.f();
    }
    this.dedent(), this.print(e.closingElement, e);
  }),
  (fd.JSXEmptyExpression = function () {
    this.printInnerComments();
  }),
  (fd.JSXExpressionContainer = function (e) {
    this.tokenChar(123), this.print(e.expression, e), this.tokenChar(125);
  }),
  (fd.JSXFragment = function (e) {
    this.print(e.openingFragment, e), this.indent();
    var t,
      r = yd(e.children);
    try {
      for (r.s(); !(t = r.n()).done; ) {
        var n = t.value;
        this.print(n, e);
      }
    } catch (e) {
      r.e(e);
    } finally {
      r.f();
    }
    this.dedent(), this.print(e.closingFragment, e);
  }),
  (fd.JSXIdentifier = function (e) {
    this.word(e.name);
  }),
  (fd.JSXMemberExpression = function (e) {
    this.print(e.object, e), this.tokenChar(46), this.print(e.property, e);
  }),
  (fd.JSXNamespacedName = function (e) {
    this.print(e.namespace, e), this.tokenChar(58), this.print(e.name, e);
  }),
  (fd.JSXOpeningElement = function (e) {
    this.tokenChar(60),
      this.print(e.name, e),
      this.print(e.typeParameters, e),
      e.attributes.length > 0 &&
        (this.space(), this.printJoin(e.attributes, e, { separator: vd }));
    e.selfClosing ? (this.space(), this.token("/>")) : this.tokenChar(62);
  }),
  (fd.JSXOpeningFragment = function () {
    this.tokenChar(60), this.tokenChar(62);
  }),
  (fd.JSXSpreadAttribute = function (e) {
    this.tokenChar(123),
      this.token("..."),
      this.print(e.argument, e),
      this.tokenChar(125);
  }),
  (fd.JSXSpreadChild = function (e) {
    this.tokenChar(123),
      this.token("..."),
      this.print(e.expression, e),
      this.tokenChar(125);
  }),
  (fd.JSXText = function (e) {
    var t = this.getPossibleRaw(e);
    void 0 !== t ? this.token(t, !0) : this.token(e.value, !0);
  });
var gd = {};
function bd(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Td(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Td(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Td(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Sd(e, t, r) {
  if ((e.token("{"), t.length)) {
    e.indent(), e.newline();
    var n,
      i = bd(t);
    try {
      for (i.s(); !(n = i.n()).done; ) {
        var a = n.value;
        e.print(a, r), e.newline();
      }
    } catch (e) {
      i.e(e);
    } finally {
      i.f();
    }
    e.dedent();
  }
  e.rightBrace(r);
}
function xd(e, t, r) {
  e.printJoin(t.types, t, {
    separator: function () {
      this.space(), this.token(r), this.space();
    },
  });
}
function Ed(e, t) {
  !0 !== t && e.token(t);
}
Object.defineProperty(gd, "__esModule", { value: !0 }),
  (gd.TSAnyKeyword = function () {
    this.word("any");
  }),
  (gd.TSArrayType = function (e) {
    this.print(e.elementType, e, !0), this.token("[]");
  }),
  (gd.TSSatisfiesExpression = gd.TSAsExpression =
    function (e) {
      var t,
        r = e.type,
        n = e.expression,
        i = e.typeAnnotation,
        a = !(null == (t = n.trailingComments) || !t.length);
      this.print(n, e, !0, void 0, a),
        this.space(),
        this.word("TSAsExpression" === r ? "as" : "satisfies"),
        this.space(),
        this.print(i, e);
    }),
  (gd.TSBigIntKeyword = function () {
    this.word("bigint");
  }),
  (gd.TSBooleanKeyword = function () {
    this.word("boolean");
  }),
  (gd.TSCallSignatureDeclaration = function (e) {
    this.tsPrintSignatureDeclarationBase(e), this.tokenChar(59);
  }),
  (gd.TSConditionalType = function (e) {
    this.print(e.checkType),
      this.space(),
      this.word("extends"),
      this.space(),
      this.print(e.extendsType),
      this.space(),
      this.tokenChar(63),
      this.space(),
      this.print(e.trueType),
      this.space(),
      this.tokenChar(58),
      this.space(),
      this.print(e.falseType);
  }),
  (gd.TSConstructSignatureDeclaration = function (e) {
    this.word("new"),
      this.space(),
      this.tsPrintSignatureDeclarationBase(e),
      this.tokenChar(59);
  }),
  (gd.TSConstructorType = function (e) {
    e.abstract && (this.word("abstract"), this.space());
    this.word("new"), this.space(), this.tsPrintFunctionOrConstructorType(e);
  }),
  (gd.TSDeclareFunction = function (e, t) {
    e.declare && (this.word("declare"), this.space());
    this._functionHead(e, t), this.tokenChar(59);
  }),
  (gd.TSDeclareMethod = function (e) {
    this._classMethodHead(e), this.tokenChar(59);
  }),
  (gd.TSEnumDeclaration = function (e) {
    var t = e.declare,
      r = e.const,
      n = e.id,
      i = e.members;
    t && (this.word("declare"), this.space());
    r && (this.word("const"), this.space());
    this.word("enum"),
      this.space(),
      this.print(n, e),
      this.space(),
      Sd(this, i, e);
  }),
  (gd.TSEnumMember = function (e) {
    var t = e.id,
      r = e.initializer;
    this.print(t, e),
      r && (this.space(), this.tokenChar(61), this.space(), this.print(r, e));
    this.tokenChar(44);
  }),
  (gd.TSExportAssignment = function (e) {
    this.word("export"),
      this.space(),
      this.tokenChar(61),
      this.space(),
      this.print(e.expression, e),
      this.tokenChar(59);
  }),
  (gd.TSExpressionWithTypeArguments = function (e) {
    this.print(e.expression, e), this.print(e.typeParameters, e);
  }),
  (gd.TSExternalModuleReference = function (e) {
    this.token("require("), this.print(e.expression, e), this.tokenChar(41);
  }),
  (gd.TSFunctionType = function (e) {
    this.tsPrintFunctionOrConstructorType(e);
  }),
  (gd.TSImportEqualsDeclaration = function (e) {
    var t = e.isExport,
      r = e.id,
      n = e.moduleReference;
    t && (this.word("export"), this.space());
    this.word("import"),
      this.space(),
      this.print(r, e),
      this.space(),
      this.tokenChar(61),
      this.space(),
      this.print(n, e),
      this.tokenChar(59);
  }),
  (gd.TSImportType = function (e) {
    var t = e.argument,
      r = e.qualifier,
      n = e.typeParameters;
    this.word("import"),
      this.tokenChar(40),
      this.print(t, e),
      this.tokenChar(41),
      r && (this.tokenChar(46), this.print(r, e));
    n && this.print(n, e);
  }),
  (gd.TSIndexSignature = function (e) {
    var t = e.readonly,
      r = e.static;
    r && (this.word("static"), this.space());
    t && (this.word("readonly"), this.space());
    this.tokenChar(91),
      this._parameters(e.parameters, e),
      this.tokenChar(93),
      this.print(e.typeAnnotation, e),
      this.tokenChar(59);
  }),
  (gd.TSIndexedAccessType = function (e) {
    this.print(e.objectType, e, !0),
      this.tokenChar(91),
      this.print(e.indexType, e),
      this.tokenChar(93);
  }),
  (gd.TSInferType = function (e) {
    this.token("infer"), this.space(), this.print(e.typeParameter);
  }),
  (gd.TSInstantiationExpression = function (e) {
    this.print(e.expression, e), this.print(e.typeParameters, e);
  }),
  (gd.TSInterfaceBody = function (e) {
    this.tsPrintTypeLiteralOrInterfaceBody(e.body, e);
  }),
  (gd.TSInterfaceDeclaration = function (e) {
    var t = e.declare,
      r = e.id,
      n = e.typeParameters,
      i = e.extends,
      a = e.body;
    t && (this.word("declare"), this.space());
    this.word("interface"),
      this.space(),
      this.print(r, e),
      this.print(n, e),
      null != i &&
        i.length &&
        (this.space(),
        this.word("extends"),
        this.space(),
        this.printList(i, e));
    this.space(), this.print(a, e);
  }),
  (gd.TSIntersectionType = function (e) {
    xd(this, e, "&");
  }),
  (gd.TSIntrinsicKeyword = function () {
    this.word("intrinsic");
  }),
  (gd.TSLiteralType = function (e) {
    this.print(e.literal, e);
  }),
  (gd.TSMappedType = function (e) {
    var t = e.nameType,
      r = e.optional,
      n = e.readonly,
      i = e.typeParameter;
    this.tokenChar(123),
      this.space(),
      n && (Ed(this, n), this.word("readonly"), this.space());
    this.tokenChar(91),
      this.word(i.name),
      this.space(),
      this.word("in"),
      this.space(),
      this.print(i.constraint, i),
      t && (this.space(), this.word("as"), this.space(), this.print(t, e));
    this.tokenChar(93), r && (Ed(this, r), this.tokenChar(63));
    this.tokenChar(58),
      this.space(),
      this.print(e.typeAnnotation, e),
      this.space(),
      this.tokenChar(125);
  }),
  (gd.TSMethodSignature = function (e) {
    var t = e.kind;
    ("set" !== t && "get" !== t) || (this.word(t), this.space());
    this.tsPrintPropertyOrMethodName(e),
      this.tsPrintSignatureDeclarationBase(e),
      this.tokenChar(59);
  }),
  (gd.TSModuleBlock = function (e) {
    Sd(this, e.body, e);
  }),
  (gd.TSModuleDeclaration = function (e) {
    var t = e.declare,
      r = e.id;
    t && (this.word("declare"), this.space());
    e.global ||
      (this.word("Identifier" === r.type ? "namespace" : "module"),
      this.space());
    if ((this.print(r, e), !e.body)) return void this.tokenChar(59);
    var n = e.body;
    for (; "TSModuleDeclaration" === n.type; )
      this.tokenChar(46), this.print(n.id, n), (n = n.body);
    this.space(), this.print(n, e);
  }),
  (gd.TSNamedTupleMember = function (e) {
    this.print(e.label, e), e.optional && this.tokenChar(63);
    this.tokenChar(58), this.space(), this.print(e.elementType, e);
  }),
  (gd.TSNamespaceExportDeclaration = function (e) {
    this.word("export"),
      this.space(),
      this.word("as"),
      this.space(),
      this.word("namespace"),
      this.space(),
      this.print(e.id, e);
  }),
  (gd.TSNeverKeyword = function () {
    this.word("never");
  }),
  (gd.TSNonNullExpression = function (e) {
    this.print(e.expression, e), this.tokenChar(33);
  }),
  (gd.TSNullKeyword = function () {
    this.word("null");
  }),
  (gd.TSNumberKeyword = function () {
    this.word("number");
  }),
  (gd.TSObjectKeyword = function () {
    this.word("object");
  }),
  (gd.TSOptionalType = function (e) {
    this.print(e.typeAnnotation, e), this.tokenChar(63);
  }),
  (gd.TSParameterProperty = function (e) {
    e.accessibility && (this.word(e.accessibility), this.space());
    e.readonly && (this.word("readonly"), this.space());
    this._param(e.parameter);
  }),
  (gd.TSParenthesizedType = function (e) {
    this.tokenChar(40), this.print(e.typeAnnotation, e), this.tokenChar(41);
  }),
  (gd.TSPropertySignature = function (e) {
    var t = e.readonly,
      r = e.initializer;
    t && (this.word("readonly"), this.space());
    this.tsPrintPropertyOrMethodName(e),
      this.print(e.typeAnnotation, e),
      r && (this.space(), this.tokenChar(61), this.space(), this.print(r, e));
    this.tokenChar(59);
  }),
  (gd.TSQualifiedName = function (e) {
    this.print(e.left, e), this.tokenChar(46), this.print(e.right, e);
  }),
  (gd.TSRestType = function (e) {
    this.token("..."), this.print(e.typeAnnotation, e);
  }),
  (gd.TSStringKeyword = function () {
    this.word("string");
  }),
  (gd.TSSymbolKeyword = function () {
    this.word("symbol");
  }),
  (gd.TSThisType = function () {
    this.word("this");
  }),
  (gd.TSTupleType = function (e) {
    this.tokenChar(91), this.printList(e.elementTypes, e), this.tokenChar(93);
  }),
  (gd.TSTypeAliasDeclaration = function (e) {
    var t = e.declare,
      r = e.id,
      n = e.typeParameters,
      i = e.typeAnnotation;
    t && (this.word("declare"), this.space());
    this.word("type"),
      this.space(),
      this.print(r, e),
      this.print(n, e),
      this.space(),
      this.tokenChar(61),
      this.space(),
      this.print(i, e),
      this.tokenChar(59);
  }),
  (gd.TSTypeAnnotation = function (e) {
    this.tokenChar(58), this.space(), e.optional && this.tokenChar(63);
    this.print(e.typeAnnotation, e);
  }),
  (gd.TSTypeAssertion = function (e) {
    var t = e.typeAnnotation,
      r = e.expression;
    this.tokenChar(60),
      this.print(t, e),
      this.tokenChar(62),
      this.space(),
      this.print(r, e);
  }),
  (gd.TSTypeLiteral = function (e) {
    this.tsPrintTypeLiteralOrInterfaceBody(e.members, e);
  }),
  (gd.TSTypeOperator = function (e) {
    this.word(e.operator), this.space(), this.print(e.typeAnnotation, e);
  }),
  (gd.TSTypeParameter = function (e) {
    e.in && (this.word("in"), this.space());
    e.out && (this.word("out"), this.space());
    this.word(e.name),
      e.constraint &&
        (this.space(),
        this.word("extends"),
        this.space(),
        this.print(e.constraint, e));
    e.default &&
      (this.space(),
      this.tokenChar(61),
      this.space(),
      this.print(e.default, e));
  }),
  (gd.TSTypeParameterDeclaration = gd.TSTypeParameterInstantiation =
    function (e, t) {
      this.tokenChar(60),
        this.printList(e.params, e, {}),
        "ArrowFunctionExpression" === t.type &&
          1 === e.params.length &&
          this.tokenChar(44);
      this.tokenChar(62);
    }),
  (gd.TSTypePredicate = function (e) {
    e.asserts && (this.word("asserts"), this.space());
    this.print(e.parameterName),
      e.typeAnnotation &&
        (this.space(),
        this.word("is"),
        this.space(),
        this.print(e.typeAnnotation.typeAnnotation));
  }),
  (gd.TSTypeQuery = function (e) {
    this.word("typeof"),
      this.space(),
      this.print(e.exprName),
      e.typeParameters && this.print(e.typeParameters, e);
  }),
  (gd.TSTypeReference = function (e) {
    this.print(e.typeName, e, !0), this.print(e.typeParameters, e, !0);
  }),
  (gd.TSUndefinedKeyword = function () {
    this.word("undefined");
  }),
  (gd.TSUnionType = function (e) {
    xd(this, e, "|");
  }),
  (gd.TSUnknownKeyword = function () {
    this.word("unknown");
  }),
  (gd.TSVoidKeyword = function () {
    this.word("void");
  }),
  (gd.tsPrintClassMemberModifiers = function (e) {
    var t = "ClassAccessorProperty" === e.type || "ClassProperty" === e.type;
    t && e.declare && (this.word("declare"), this.space());
    e.accessibility && (this.word(e.accessibility), this.space());
    e.static && (this.word("static"), this.space());
    e.override && (this.word("override"), this.space());
    e.abstract && (this.word("abstract"), this.space());
    t && e.readonly && (this.word("readonly"), this.space());
  }),
  (gd.tsPrintFunctionOrConstructorType = function (e) {
    var t = e.typeParameters,
      r = e.parameters;
    this.print(t, e),
      this.tokenChar(40),
      this._parameters(r, e),
      this.tokenChar(41),
      this.space(),
      this.token("=>"),
      this.space();
    var n = e.typeAnnotation;
    this.print(n.typeAnnotation, e);
  }),
  (gd.tsPrintPropertyOrMethodName = function (e) {
    e.computed && this.tokenChar(91);
    this.print(e.key, e), e.computed && this.tokenChar(93);
    e.optional && this.tokenChar(63);
  }),
  (gd.tsPrintSignatureDeclarationBase = function (e) {
    var t = e.typeParameters,
      r = e.parameters;
    this.print(t, e),
      this.tokenChar(40),
      this._parameters(r, e),
      this.tokenChar(41);
    var n = e.typeAnnotation;
    this.print(n, e);
  }),
  (gd.tsPrintTypeLiteralOrInterfaceBody = function (e, t) {
    Sd(this, e, t);
  }),
  (function (e) {
    Object.defineProperty(e, "__esModule", { value: !0 });
    var t = sh;
    Object.keys(t).forEach(function (r) {
      "default" !== r &&
        "__esModule" !== r &&
        ((r in e && e[r] === t[r]) ||
          Object.defineProperty(e, r, {
            enumerable: !0,
            get: function () {
              return t[r];
            },
          }));
    });
    var r = oh;
    Object.keys(r).forEach(function (t) {
      "default" !== t &&
        "__esModule" !== t &&
        ((t in e && e[t] === r[t]) ||
          Object.defineProperty(e, t, {
            enumerable: !0,
            get: function () {
              return r[t];
            },
          }));
    });
    var n = yh;
    Object.keys(n).forEach(function (t) {
      "default" !== t &&
        "__esModule" !== t &&
        ((t in e && e[t] === n[t]) ||
          Object.defineProperty(e, t, {
            enumerable: !0,
            get: function () {
              return n[t];
            },
          }));
    });
    var i = Ch;
    Object.keys(i).forEach(function (t) {
      "default" !== t &&
        "__esModule" !== t &&
        ((t in e && e[t] === i[t]) ||
          Object.defineProperty(e, t, {
            enumerable: !0,
            get: function () {
              return i[t];
            },
          }));
    });
    var a = _h;
    Object.keys(a).forEach(function (t) {
      "default" !== t &&
        "__esModule" !== t &&
        ((t in e && e[t] === a[t]) ||
          Object.defineProperty(e, t, {
            enumerable: !0,
            get: function () {
              return a[t];
            },
          }));
    });
    var s = Mh;
    Object.keys(s).forEach(function (t) {
      "default" !== t &&
        "__esModule" !== t &&
        ((t in e && e[t] === s[t]) ||
          Object.defineProperty(e, t, {
            enumerable: !0,
            get: function () {
              return s[t];
            },
          }));
    });
    var o = qh;
    Object.keys(o).forEach(function (t) {
      "default" !== t &&
        "__esModule" !== t &&
        ((t in e && e[t] === o[t]) ||
          Object.defineProperty(e, t, {
            enumerable: !0,
            get: function () {
              return o[t];
            },
          }));
    });
    var l = ld;
    Object.keys(l).forEach(function (t) {
      "default" !== t &&
        "__esModule" !== t &&
        ((t in e && e[t] === l[t]) ||
          Object.defineProperty(e, t, {
            enumerable: !0,
            get: function () {
              return l[t];
            },
          }));
    });
    var u = pd;
    Object.keys(u).forEach(function (t) {
      "default" !== t &&
        "__esModule" !== t &&
        ((t in e && e[t] === u[t]) ||
          Object.defineProperty(e, t, {
            enumerable: !0,
            get: function () {
              return u[t];
            },
          }));
    });
    var c = fd;
    Object.keys(c).forEach(function (t) {
      "default" !== t &&
        "__esModule" !== t &&
        ((t in e && e[t] === c[t]) ||
          Object.defineProperty(e, t, {
            enumerable: !0,
            get: function () {
              return c[t];
            },
          }));
    });
    var p = gd;
    Object.keys(p).forEach(function (t) {
      "default" !== t &&
        "__esModule" !== t &&
        ((t in e && e[t] === p[t]) ||
          Object.defineProperty(e, t, {
            enumerable: !0,
            get: function () {
              return p[t];
            },
          }));
    });
  })(ah),
  Object.defineProperty(Ei, "__esModule", { value: !0 }),
  (Ei.default = void 0);
var Pd = Pi,
  Ad = ki,
  kd = mc(),
  wd = ah,
  Cd = kd.isFunction,
  Id = kd.isStatement,
  Od = kd.isClassBody,
  Nd = kd.isTSInterfaceBody,
  _d = kd.isTSEnumDeclaration,
  Dd = /e/i,
  Ld = /\.0+$/,
  Md = /^0[box]/,
  jd = /^\s*[@#]__PURE__\s*$/,
  Fd = /[\n\r\u2028\u2029]/,
  Bd = /\*\//,
  Rd = Ad.needsParens,
  Ud = (function () {
    function e(t, r) {
      E(this, e),
        (this.inForStatementInitCounter = 0),
        (this._printStack = []),
        (this._indent = 0),
        (this._indentChar = 0),
        (this._indentRepeat = 0),
        (this._insideAux = !1),
        (this._parenPushNewlineState = null),
        (this._noLineTerminator = !1),
        (this._printAuxAfterOnNextUserNode = !1),
        (this._printedComments = new Set()),
        (this._endsWithInteger = !1),
        (this._endsWithWord = !1),
        (this._lastCommentLine = 0),
        (this._endsWithInnerRaw = !1),
        (this._indentInnerComments = !0),
        (this.format = t),
        (this._buf = new Pd.default(r)),
        (this._indentChar = t.indent.style.charCodeAt(0)),
        (this._indentRepeat = t.indent.style.length),
        (this._inputMap = null == r ? void 0 : r._inputMap);
    }
    return (
      A(e, [
        {
          key: "generate",
          value: function (e) {
            return this.print(e), this._maybeAddAuxComment(), this._buf.get();
          },
        },
        {
          key: "indent",
          value: function () {
            this.format.compact || this.format.concise || this._indent++;
          },
        },
        {
          key: "dedent",
          value: function () {
            this.format.compact || this.format.concise || this._indent--;
          },
        },
        {
          key: "semicolon",
          value: function () {
            var e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            this._maybeAddAuxComment(),
              e ? this._appendChar(59) : this._queue(59),
              (this._noLineTerminator = !1);
          },
        },
        {
          key: "rightBrace",
          value: function (e) {
            this.format.minified && this._buf.removeLastSemicolon(),
              this.sourceWithOffset("end", e.loc, 0, -1),
              this.tokenChar(125);
          },
        },
        {
          key: "rightParens",
          value: function (e) {
            this.sourceWithOffset("end", e.loc, 0, -1), this.tokenChar(41);
          },
        },
        {
          key: "space",
          value: function () {
            var e =
              arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
            if (!this.format.compact)
              if (e) this._space();
              else if (this._buf.hasContent()) {
                var t = this.getLastChar();
                32 !== t && 10 !== t && this._space();
              }
          },
        },
        {
          key: "word",
          value: function (e) {
            var t =
              arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            this._maybePrintInnerComments(),
              (this._endsWithWord ||
                (47 === e.charCodeAt(0) && this.endsWith(47))) &&
                this._space(),
              this._maybeAddAuxComment(),
              this._append(e, !1),
              (this._endsWithWord = !0),
              (this._noLineTerminator = t);
          },
        },
        {
          key: "number",
          value: function (e) {
            this.word(e),
              (this._endsWithInteger =
                Number.isInteger(+e) &&
                !Md.test(e) &&
                !Dd.test(e) &&
                !Ld.test(e) &&
                46 !== e.charCodeAt(e.length - 1));
          },
        },
        {
          key: "token",
          value: function (e) {
            var t =
              arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            this._maybePrintInnerComments();
            var r = this.getLastChar(),
              n = e.charCodeAt(0);
            ((33 === r && ("--" === e || 61 === n)) ||
              (43 === n && 43 === r) ||
              (45 === n && 45 === r) ||
              (46 === n && this._endsWithInteger)) &&
              this._space(),
              this._maybeAddAuxComment(),
              this._append(e, t),
              (this._noLineTerminator = !1);
          },
        },
        {
          key: "tokenChar",
          value: function (e) {
            this._maybePrintInnerComments();
            var t = this.getLastChar();
            ((43 === e && 43 === t) ||
              (45 === e && 45 === t) ||
              (46 === e && this._endsWithInteger)) &&
              this._space(),
              this._maybeAddAuxComment(),
              this._appendChar(e),
              (this._noLineTerminator = !1);
          },
        },
        {
          key: "newline",
          value: function () {
            var e =
              arguments.length > 0 && void 0 !== arguments[0]
                ? arguments[0]
                : 1;
            if (!(e <= 0)) {
              if (!(arguments.length > 1 ? arguments[1] : void 0)) {
                if (this.format.retainLines || this.format.compact) return;
                if (this.format.concise) return void this.space();
              }
              e > 2 && (e = 2), (e -= this._buf.getNewlineCount());
              for (var t = 0; t < e; t++) this._newline();
            }
          },
        },
        {
          key: "endsWith",
          value: function (e) {
            return this.getLastChar() === e;
          },
        },
        {
          key: "getLastChar",
          value: function () {
            return this._buf.getLastChar();
          },
        },
        {
          key: "endsWithCharAndNewline",
          value: function () {
            return this._buf.endsWithCharAndNewline();
          },
        },
        {
          key: "removeTrailingNewline",
          value: function () {
            this._buf.removeTrailingNewline();
          },
        },
        {
          key: "exactSource",
          value: function (e, t) {
            e ? (this._catchUp("start", e), this._buf.exactSource(e, t)) : t();
          },
        },
        {
          key: "source",
          value: function (e, t) {
            t && (this._catchUp(e, t), this._buf.source(e, t));
          },
        },
        {
          key: "sourceWithOffset",
          value: function (e, t, r, n) {
            t && (this._catchUp(e, t), this._buf.sourceWithOffset(e, t, r, n));
          },
        },
        {
          key: "withSource",
          value: function (e, t, r) {
            t ? (this._catchUp(e, t), this._buf.withSource(e, t, r)) : r();
          },
        },
        {
          key: "sourceIdentifierName",
          value: function (e, t) {
            if (this._buf._canMarkIdName) {
              var r = this._buf._sourcePosition;
              (r.identifierNamePos = t), (r.identifierName = e);
            }
          },
        },
        {
          key: "_space",
          value: function () {
            this._queue(32);
          },
        },
        {
          key: "_newline",
          value: function () {
            this._queue(10);
          },
        },
        {
          key: "_append",
          value: function (e, t) {
            this._maybeAddParen(e),
              this._maybeIndent(e.charCodeAt(0)),
              this._buf.append(e, t),
              (this._endsWithWord = !1),
              (this._endsWithInteger = !1);
          },
        },
        {
          key: "_appendChar",
          value: function (e) {
            this._maybeAddParenChar(e),
              this._maybeIndent(e),
              this._buf.appendChar(e),
              (this._endsWithWord = !1),
              (this._endsWithInteger = !1);
          },
        },
        {
          key: "_queue",
          value: function (e) {
            this._maybeAddParenChar(e),
              this._maybeIndent(e),
              this._buf.queue(e),
              (this._endsWithWord = !1),
              (this._endsWithInteger = !1);
          },
        },
        {
          key: "_maybeIndent",
          value: function (e) {
            this._indent &&
              10 !== e &&
              this.endsWith(10) &&
              this._buf.queueIndentation(this._indentChar, this._getIndent());
          },
        },
        {
          key: "_shouldIndent",
          value: function (e) {
            if (this._indent && 10 !== e && this.endsWith(10)) return !0;
          },
        },
        {
          key: "_maybeAddParenChar",
          value: function (e) {
            var t = this._parenPushNewlineState;
            t &&
              32 !== e &&
              (10 === e
                ? (this.tokenChar(40), this.indent(), (t.printed = !0))
                : (this._parenPushNewlineState = null));
          },
        },
        {
          key: "_maybeAddParen",
          value: function (e) {
            var t = this._parenPushNewlineState;
            if (t) {
              var r,
                n = e.length;
              for (r = 0; r < n && 32 === e.charCodeAt(r); r++) continue;
              if (r !== n) {
                var i = e.charCodeAt(r);
                if (10 !== i) {
                  if (47 !== i || r + 1 === n)
                    return void (this._parenPushNewlineState = null);
                  var a = e.charCodeAt(r + 1);
                  if (42 === a) {
                    if (jd.test(e.slice(r + 2, n - 2))) return;
                  } else if (47 !== a)
                    return void (this._parenPushNewlineState = null);
                }
                this.tokenChar(40), this.indent(), (t.printed = !0);
              }
            }
          },
        },
        {
          key: "catchUp",
          value: function (e) {
            if (this.format.retainLines)
              for (var t = e - this._buf.getCurrentLine(), r = 0; r < t; r++)
                this._newline();
          },
        },
        {
          key: "_catchUp",
          value: function (e, t) {
            var r;
            if (this.format.retainLines) {
              var n = null == t || null == (r = t[e]) ? void 0 : r.line;
              if (null != n)
                for (var i = n - this._buf.getCurrentLine(), a = 0; a < i; a++)
                  this._newline();
            }
          },
        },
        {
          key: "_getIndent",
          value: function () {
            return this._indentRepeat * this._indent;
          },
        },
        {
          key: "printTerminatorless",
          value: function (e, t, r) {
            if (r) (this._noLineTerminator = !0), this.print(e, t);
            else {
              var n = { printed: !1 };
              (this._parenPushNewlineState = n),
                this.print(e, t),
                n.printed &&
                  (this.dedent(), this.newline(), this.tokenChar(41));
            }
          },
        },
        {
          key: "print",
          value: function (e, t, r, n, i) {
            var a;
            if (e) {
              this._endsWithInnerRaw = !1;
              var s = e.type,
                o = this.format,
                l = o.concise;
              e._compact && (o.concise = !0);
              var u = this[s];
              if (void 0 === u)
                throw new ReferenceError(
                  "unknown node of type "
                    .concat(JSON.stringify(s), " with constructor ")
                    .concat(JSON.stringify(e.constructor.name))
                );
              this._printStack.push(e);
              var c = this._insideAux;
              (this._insideAux = null == e.loc),
                this._maybeAddAuxComment(this._insideAux && !c);
              var p =
                i ||
                (o.retainFunctionParens &&
                  "FunctionExpression" === s &&
                  (null == (a = e.extra) ? void 0 : a.parenthesized)) ||
                Rd(e, t, this._printStack);
              p && (this.tokenChar(40), (this._endsWithInnerRaw = !1)),
                (this._lastCommentLine = 0),
                this._printLeadingComments(e, t);
              var h = "Program" === s || "File" === s ? null : e.loc;
              this.exactSource(h, u.bind(this, e, t)),
                p
                  ? (this._printTrailingComments(e, t),
                    this.tokenChar(41),
                    (this._noLineTerminator = r))
                  : r && !this._noLineTerminator
                  ? ((this._noLineTerminator = !0),
                    this._printTrailingComments(e, t))
                  : this._printTrailingComments(e, t, n),
                this._printStack.pop(),
                (o.concise = l),
                (this._insideAux = c),
                (this._endsWithInnerRaw = !1);
            }
          },
        },
        {
          key: "_maybeAddAuxComment",
          value: function (e) {
            e && this._printAuxBeforeComment(),
              this._insideAux || this._printAuxAfterComment();
          },
        },
        {
          key: "_printAuxBeforeComment",
          value: function () {
            if (!this._printAuxAfterOnNextUserNode) {
              this._printAuxAfterOnNextUserNode = !0;
              var e = this.format.auxiliaryCommentBefore;
              e && this._printComment({ type: "CommentBlock", value: e }, 0);
            }
          },
        },
        {
          key: "_printAuxAfterComment",
          value: function () {
            if (this._printAuxAfterOnNextUserNode) {
              this._printAuxAfterOnNextUserNode = !1;
              var e = this.format.auxiliaryCommentAfter;
              e && this._printComment({ type: "CommentBlock", value: e }, 0);
            }
          },
        },
        {
          key: "getPossibleRaw",
          value: function (e) {
            var t = e.extra;
            if (
              t &&
              null != t.raw &&
              null != t.rawValue &&
              e.value === t.rawValue
            )
              return t.raw;
          },
        },
        {
          key: "printJoin",
          value: function (e, t) {
            var r =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            if (null != e && e.length) {
              var n = r.indent;
              if (null == n && this.format.retainLines) {
                var i,
                  a = null == (i = e[0].loc) ? void 0 : i.start.line;
                null != a && a !== this._buf.getCurrentLine() && (n = !0);
              }
              n && this.indent();
              for (
                var s = { addNewlines: r.addNewlines, nextNodeStartLine: 0 },
                  o = r.separator ? r.separator.bind(this) : null,
                  l = e.length,
                  u = 0;
                u < l;
                u++
              ) {
                var c = e[u];
                if (
                  c &&
                  (r.statement && this._printNewline(0 === u, s),
                  this.print(c, t, void 0, r.trailingCommentsLineOffset || 0),
                  null == r.iterator || r.iterator(c, u),
                  u < l - 1 && (null == o || o()),
                  r.statement)
                )
                  if (u + 1 === l) this.newline(1);
                  else {
                    var p,
                      h = e[u + 1];
                    (s.nextNodeStartLine =
                      (null == (p = h.loc) ? void 0 : p.start.line) || 0),
                      this._printNewline(!0, s);
                  }
              }
              n && this.dedent();
            }
          },
        },
        {
          key: "printAndIndentOnComments",
          value: function (e, t) {
            var r = e.leadingComments && e.leadingComments.length > 0;
            r && this.indent(), this.print(e, t), r && this.dedent();
          },
        },
        {
          key: "printBlock",
          value: function (e) {
            var t = e.body;
            "EmptyStatement" !== t.type && this.space(), this.print(t, e);
          },
        },
        {
          key: "_printTrailingComments",
          value: function (e, t, r) {
            var n = e.innerComments,
              i = e.trailingComments;
            null != n && n.length && this._printComments(2, n, e, t, r),
              null != i && i.length && this._printComments(2, i, e, t, r);
          },
        },
        {
          key: "_printLeadingComments",
          value: function (e, t) {
            var r = e.leadingComments;
            null != r && r.length && this._printComments(0, r, e, t);
          },
        },
        {
          key: "_maybePrintInnerComments",
          value: function () {
            this._endsWithInnerRaw && this.printInnerComments(),
              (this._endsWithInnerRaw = !0),
              (this._indentInnerComments = !0);
          },
        },
        {
          key: "printInnerComments",
          value: function () {
            var e = this._printStack[this._printStack.length - 1],
              t = e.innerComments;
            if (null != t && t.length) {
              var r = this.endsWith(32),
                n = this._indentInnerComments,
                i = this._printedComments.size;
              n && this.indent(),
                this._printComments(1, t, e),
                r && i !== this._printedComments.size && this.space(),
                n && this.dedent();
            }
          },
        },
        {
          key: "noIndentInnerCommentsHere",
          value: function () {
            this._indentInnerComments = !1;
          },
        },
        {
          key: "printSequence",
          value: function (e, t) {
            var r =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            (r.statement = !0),
              null != r.indent || (r.indent = !1),
              this.printJoin(e, t, r);
          },
        },
        {
          key: "printList",
          value: function (e, t) {
            var r =
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : {};
            null == r.separator && (r.separator = Kd), this.printJoin(e, t, r);
          },
        },
        {
          key: "_printNewline",
          value: function (e, t) {
            var r = this.format;
            if (!r.retainLines && !r.compact)
              if (r.concise) this.space();
              else if (e) {
                var n = t.nextNodeStartLine,
                  i = this._lastCommentLine;
                if (n > 0 && i > 0) {
                  var a = n - i;
                  if (a >= 0) return void this.newline(a || 1);
                }
                this._buf.hasContent() && this.newline(1);
              }
          },
        },
        {
          key: "_shouldPrintComment",
          value: function (e) {
            return e.ignore || this._printedComments.has(e)
              ? 0
              : this._noLineTerminator && (Fd.test(e.value) || Bd.test(e.value))
              ? 2
              : (this._printedComments.add(e),
                this.format.shouldPrintComment(e.value) ? 1 : 0);
          },
        },
        {
          key: "_printComment",
          value: function (e, t) {
            var r = this._noLineTerminator,
              n = "CommentBlock" === e.type,
              i = n && 1 !== t && !this._noLineTerminator;
            i && this._buf.hasContent() && 2 !== t && this.newline(1);
            var a,
              s = this.getLastChar();
            if ((91 !== s && 123 !== s && this.space(), n)) {
              if (
                ((a = "/*".concat(e.value, "*/")),
                this.format.indent.adjustMultilineComment)
              ) {
                var o,
                  l = null == (o = e.loc) ? void 0 : o.start.column;
                if (l) {
                  var u = new RegExp("\\n\\s{1," + l + "}", "g");
                  a = a.replace(u, "\n");
                }
                var c = this.format.retainLines
                  ? 0
                  : this._buf.getCurrentColumn();
                (this._shouldIndent(47) || this.format.retainLines) &&
                  (c += this._getIndent()),
                  (a = a.replace(/\n(?!$)/g, "\n".concat(" ".repeat(c))));
              }
            } else a = r ? "/*".concat(e.value, "*/") : "//".concat(e.value);
            this.endsWith(47) && this._space(),
              this.source("start", e.loc),
              this._append(a, n),
              n || r || this.newline(1, !0),
              i && 3 !== t && this.newline(1);
          },
        },
        {
          key: "_printComments",
          value: function (e, t, r, n) {
            for (
              var i =
                  arguments.length > 4 && void 0 !== arguments[4]
                    ? arguments[4]
                    : 0,
                a = r.loc,
                s = t.length,
                o = !!a,
                l = o ? a.start.line : 0,
                u = o ? a.end.line : 0,
                c = 0,
                p = 0,
                h = this._noLineTerminator
                  ? function () {}
                  : this.newline.bind(this),
                d = 0;
              d < s;
              d++
            ) {
              var f = t[d],
                y = this._shouldPrintComment(f);
              if (2 === y) {
                o = !1;
                break;
              }
              if (o && f.loc && 1 === y) {
                var m = f.loc.start.line,
                  v = f.loc.end.line;
                if (0 === e) {
                  var g = 0;
                  0 === d
                    ? !this._buf.hasContent() ||
                      ("CommentLine" !== f.type && m == v) ||
                      (g = p = 1)
                    : (g = m - c),
                    (c = v),
                    h(g),
                    this._printComment(f, 1),
                    d + 1 === s && (h(Math.max(l - c, p)), (c = l));
                } else if (1 === e) {
                  var b = m - (0 === d ? l : c);
                  (c = v),
                    h(b),
                    this._printComment(f, 1),
                    d + 1 === s && (h(Math.min(1, u - c)), (c = u));
                } else {
                  var T = m - (0 === d ? u - i : c);
                  (c = v), h(T), this._printComment(f, 1);
                }
              } else {
                if (((o = !1), 1 !== y)) continue;
                if (1 === s) {
                  var S = f.loc
                      ? f.loc.start.line === f.loc.end.line
                      : !Fd.test(f.value),
                    x = S && !Id(r) && !Od(n) && !Nd(n) && !_d(n);
                  0 === e
                    ? this._printComment(
                        f,
                        (x && "ObjectExpression" !== r.type) ||
                          (S && Cd(n, { body: r }))
                          ? 1
                          : 0
                      )
                    : x && 2 === e
                    ? this._printComment(f, 1)
                    : this._printComment(f, 0);
                } else
                  1 !== e ||
                  ("ObjectExpression" === r.type && r.properties.length > 1) ||
                  "ClassBody" === r.type ||
                  "TSInterfaceBody" === r.type
                    ? this._printComment(f, 0)
                    : this._printComment(f, 0 === d ? 2 : d === s - 1 ? 3 : 0);
              }
            }
            2 === e && o && c && (this._lastCommentLine = c);
          },
        },
      ]),
      e
    );
  })();
Object.assign(Ud.prototype, wd), (Ud.prototype.Noop = function () {});
var Vd = Ud;
function Kd() {
  this.tokenChar(44), this.space();
}
function Wd(e) {
  var t = (function () {
    if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
    if (Reflect.construct.sham) return !1;
    if ("function" == typeof Proxy) return !0;
    try {
      return (
        Boolean.prototype.valueOf.call(
          Reflect.construct(Boolean, [], function () {})
        ),
        !0
      );
    } catch (e) {
      return !1;
    }
  })();
  return function () {
    var r,
      n = N(e);
    if (t) {
      var i = N(this).constructor;
      r = Reflect.construct(n, arguments, i);
    } else r = n.apply(this, arguments);
    return O(this, r);
  };
}
(Ei.default = Vd),
  Object.defineProperty(ai, "__esModule", { value: !0 }),
  (ai.CodeGenerator = void 0);
var qd = (ai.default = function (e, t, r) {
    return new Jd(e, t, r).generate();
  }),
  Hd = si,
  Yd = Ei,
  Jd = (function (e) {
    I(r, Yd["default"]);
    var t = Wd(r);
    function r(e) {
      var n,
        i = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {},
        a = arguments.length > 2 ? arguments[2] : void 0;
      E(this, r);
      var s = (function (e, t) {
          var r = {
            auxiliaryCommentBefore: t.auxiliaryCommentBefore,
            auxiliaryCommentAfter: t.auxiliaryCommentAfter,
            shouldPrintComment: t.shouldPrintComment,
            retainLines: t.retainLines,
            retainFunctionParens: t.retainFunctionParens,
            comments: null == t.comments || t.comments,
            compact: t.compact,
            minified: t.minified,
            concise: t.concise,
            indent: { adjustMultilineComment: !0, style: "  " },
            jsescOption: Object.assign(
              { quotes: "double", wrap: !0, minimal: !1 },
              t.jsescOption
            ),
            recordAndTupleSyntaxType: t.recordAndTupleSyntaxType,
            topicToken: t.topicToken,
          };
          (r.decoratorsBeforeExport = t.decoratorsBeforeExport),
            (r.jsescOption.json = t.jsonCompatibleStrings),
            r.minified
              ? ((r.compact = !0),
                (r.shouldPrintComment =
                  r.shouldPrintComment ||
                  function () {
                    return r.comments;
                  }))
              : (r.shouldPrintComment =
                  r.shouldPrintComment ||
                  function (e) {
                    return (
                      r.comments ||
                      e.includes("@license") ||
                      e.includes("@preserve")
                    );
                  });
          "auto" === r.compact &&
            ((r.compact = "string" == typeof e && e.length > 5e5),
            r.compact &&
              console.error(
                "[BABEL] Note: The code generator has deoptimised the styling of " +
                  "".concat(
                    t.filename,
                    " as it exceeds the max of ",
                    "500KB",
                    "."
                  )
              ));
          r.compact && (r.indent.adjustMultilineComment = !1);
          var n = r.auxiliaryCommentBefore,
            i = r.auxiliaryCommentAfter,
            a = r.shouldPrintComment;
          n && !a(n) && (r.auxiliaryCommentBefore = void 0);
          i && !a(i) && (r.auxiliaryCommentAfter = void 0);
          return r;
        })(a, i),
        o = i.sourceMaps ? new Hd.default(i, a) : null;
      return ((n = t.call(this, s, o)).ast = void 0), (n.ast = e), n;
    }
    return (
      A(r, [
        {
          key: "generate",
          value: function () {
            return Fe(N(r.prototype), "generate", this).call(this, this.ast);
          },
        },
      ]),
      r
    );
  })();
var Xd = (function () {
  function e(t, r, n) {
    E(this, e), (this._generator = void 0), (this._generator = new Jd(t, r, n));
  }
  return (
    A(e, [
      {
        key: "generate",
        value: function () {
          return this._generator.generate();
        },
      },
    ]),
    e
  );
})();
ai.CodeGenerator = Xd;
var Gd = mc(),
  zd = function e(t, r, n) {
    u.default.readdirSync(t).forEach(function (i) {
      var a = "".concat(t, "/").concat(i),
        s = u.default.statSync(a);
      if (s.isFile()) {
        var o = h.default.extname(i);
        r.includes(o) && n(a);
      } else s.isDirectory() && e(a, r, n);
    });
  },
  $d = {},
  Qd = {},
  Zd = {};
Object.defineProperty(Zd, "__esModule", { value: !0 }),
  (Zd.Var =
    Zd.User =
    Zd.Statement =
    Zd.SpreadProperty =
    Zd.Scope =
    Zd.RestProperty =
    Zd.ReferencedMemberExpression =
    Zd.ReferencedIdentifier =
    Zd.Referenced =
    Zd.Pure =
    Zd.NumericLiteralTypeAnnotation =
    Zd.Generated =
    Zd.ForAwaitStatement =
    Zd.Flow =
    Zd.Expression =
    Zd.ExistentialTypeParam =
    Zd.BlockScoped =
    Zd.BindingIdentifier =
      void 0);
Zd.ReferencedIdentifier = ["Identifier", "JSXIdentifier"];
Zd.ReferencedMemberExpression = ["MemberExpression"];
Zd.BindingIdentifier = ["Identifier"];
Zd.Statement = ["Statement"];
Zd.Expression = ["Expression"];
Zd.Scope = ["Scopable", "Pattern"];
Zd.Referenced = null;
Zd.BlockScoped = null;
Zd.Var = ["VariableDeclaration"];
Zd.User = null;
Zd.Generated = null;
Zd.Pure = null;
Zd.Flow = ["Flow", "ImportDeclaration", "ExportDeclaration", "ImportSpecifier"];
Zd.RestProperty = ["RestElement"];
Zd.SpreadProperty = ["RestElement"];
Zd.ExistentialTypeParam = ["ExistsTypeAnnotation"];
Zd.NumericLiteralTypeAnnotation = ["NumberLiteralTypeAnnotation"];
function ef(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return tf(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return tf(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function tf(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
(Zd.ForAwaitStatement = ["ForOfStatement"]),
  Object.defineProperty(Qd, "__esModule", { value: !0 }),
  (Qd.explode = pf),
  (Qd.merge = function (e) {
    for (
      var t =
          arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : [],
        r = arguments.length > 2 ? arguments[2] : void 0,
        n = {},
        i = 0;
      i < e.length;
      i++
    ) {
      var a = e[i],
        s = t[i];
      pf(a);
      for (var o = 0, l = Object.keys(a); o < l.length; o++) {
        var u = l[o],
          c = a[u];
        (s || r) && (c = ff(c, s, r)), gf(n[u] || (n[u] = {}), c);
      }
    }
    return n;
  }),
  (Qd.verify = hf);
var rf = Zd,
  nf = mc(),
  af = nf.DEPRECATED_KEYS,
  sf = nf.DEPRECATED_ALIASES,
  of = nf.FLIPPED_ALIAS_KEYS,
  lf = nf.TYPES,
  uf = nf.__internal__deprecationWarning;
function cf(e) {
  return e in rf;
}
function pf(e) {
  if (e._exploded) return e;
  e._exploded = !0;
  for (var t = 0, r = Object.keys(e); t < r.length; t++) {
    var n = r[t];
    if (!vf(n)) {
      var i = n.split("|");
      if (1 !== i.length) {
        var a = e[n];
        delete e[n];
        var s,
          o = ef(i);
        try {
          for (o.s(); !(s = o.n()).done; ) {
            e[s.value] = a;
          }
        } catch (e) {
          o.e(e);
        } finally {
          o.f();
        }
      }
    }
  }
  hf(e),
    delete e.__esModule,
    (function (e) {
      for (var t = 0, r = Object.keys(e); t < r.length; t++) {
        var n = r[t];
        if (!vf(n)) {
          var i = e[n];
          "function" == typeof i && (e[n] = { enter: i });
        }
      }
    })(e),
    yf(e);
  for (var l = 0, u = Object.keys(e); l < u.length; l++) {
    var c = u[l];
    if (!vf(c) && cf(c)) {
      for (var p = e[c], h = 0, d = Object.keys(p); h < d.length; h++) {
        var f = d[h];
        p[f] = mf(c, p[f]);
      }
      delete e[c];
      var y = rf[c];
      if (null !== y) {
        var m,
          v = ef(y);
        try {
          for (v.s(); !(m = v.n()).done; ) {
            var g = m.value;
            e[g] ? gf(e[g], p) : (e[g] = p);
          }
        } catch (e) {
          v.e(e);
        } finally {
          v.f();
        }
      } else gf(e, p);
    }
  }
  for (var b = 0, T = Object.keys(e); b < T.length; b++) {
    var S = T[b];
    if (!vf(S)) {
      var x = of[S];
      if (S in af) {
        var E = af[S];
        uf(S, E, "Visitor "), (x = [E]);
      } else if (S in sf) {
        var P = sf[S];
        uf(S, P, "Visitor "), (x = of[P]);
      }
      if (x) {
        var A = e[S];
        delete e[S];
        var k,
          w = ef(x);
        try {
          for (w.s(); !(k = w.n()).done; ) {
            var C = k.value,
              I = e[C];
            I ? gf(I, A) : (e[C] = Object.assign({}, A));
          }
        } catch (e) {
          w.e(e);
        } finally {
          w.f();
        }
      }
    }
  }
  for (var O = 0, N = Object.keys(e); O < N.length; O++) {
    var _ = N[O];
    vf(_) || yf(e[_]);
  }
  return e;
}
function hf(e) {
  if (!e._verified) {
    if ("function" == typeof e)
      throw new Error(
        "You passed `traverse()` a function when it expected a visitor object, are you sure you didn't mean `{ enter: Function }`?"
      );
    for (var t = 0, r = Object.keys(e); t < r.length; t++) {
      var n = r[t];
      if ((("enter" !== n && "exit" !== n) || df(n, e[n]), !vf(n))) {
        if (lf.indexOf(n) < 0)
          throw new Error(
            "You gave us a visitor for the node type ".concat(
              n,
              " but it's not a valid type"
            )
          );
        var i = e[n];
        if ("object" === g(i))
          for (var a = 0, s = Object.keys(i); a < s.length; a++) {
            var o = s[a];
            if ("enter" !== o && "exit" !== o)
              throw new Error(
                "You passed `traverse()` a visitor object with the property " +
                  "".concat(n, " that has the invalid property ").concat(o)
              );
            df("".concat(n, ".").concat(o), i[o]);
          }
      }
    }
    e._verified = !0;
  }
}
function df(e, t) {
  var r,
    n = ef([].concat(t));
  try {
    for (n.s(); !(r = n.n()).done; ) {
      var i = r.value;
      if ("function" != typeof i)
        throw new TypeError(
          "Non-function found defined in ".concat(e, " with type ").concat(g(i))
        );
    }
  } catch (e) {
    n.e(e);
  } finally {
    n.f();
  }
}
function ff(e, t, r) {
  for (
    var n = {},
      i = function () {
        var i = s[a],
          o = e[i];
        if (!Array.isArray(o)) return "continue";
        (o = o.map(function (e) {
          var n = e;
          return (
            t &&
              (n = function (r) {
                return e.call(t, r, t);
              }),
            r && (n = r(t.key, i, n)),
            n !== e &&
              (n.toString = function () {
                return e.toString();
              }),
            n
          );
        })),
          (n[i] = o);
      },
      a = 0,
      s = Object.keys(e);
    a < s.length;
    a++
  )
    i();
  return n;
}
function yf(e) {
  e.enter && !Array.isArray(e.enter) && (e.enter = [e.enter]),
    e.exit && !Array.isArray(e.exit) && (e.exit = [e.exit]);
}
function mf(e, t) {
  var r = function (r) {
    if (r["is".concat(e)]()) return t.apply(this, arguments);
  };
  return (
    (r.toString = function () {
      return t.toString();
    }),
    r
  );
}
function vf(e) {
  return (
    "_" === e[0] ||
    "enter" === e ||
    "exit" === e ||
    "shouldSkip" === e ||
    "denylist" === e ||
    "noScope" === e ||
    "skipKeys" === e ||
    "blacklist" === e
  );
}
function gf(e, t) {
  for (var r = 0, n = Object.keys(t); r < n.length; r++) {
    var i = n[r];
    e[i] = [].concat(e[i] || [], t[i]);
  }
}
var bf = {};
Object.defineProperty(bf, "__esModule", { value: !0 }),
  (bf.clear = function () {
    xf(), Ef();
  }),
  (bf.clearPath = xf),
  (bf.clearScope = Ef),
  (bf.scope = bf.path = void 0);
var Tf = new WeakMap();
bf.path = Tf;
var Sf = new WeakMap();
function xf() {
  bf.path = Tf = new WeakMap();
}
function Ef() {
  bf.scope = Sf = new WeakMap();
}
bf.scope = Sf;
var Pf,
  Af,
  kf,
  wf,
  Cf,
  If = {},
  Of = {},
  Nf = {},
  _f = { exports: {} },
  Df = { exports: {} };
function Lf() {
  if (Af) return Pf;
  Af = 1;
  var e = 1e3,
    t = 60 * e,
    r = 60 * t,
    n = 24 * r,
    i = 7 * n,
    a = 365.25 * n;
  function s(e, t, r, n) {
    var i = t >= 1.5 * r;
    return Math.round(e / r) + " " + n + (i ? "s" : "");
  }
  return (
    (Pf = function (o, l) {
      l = l || {};
      var u = g(o);
      if ("string" === u && o.length > 0)
        return (function (s) {
          if ((s = String(s)).length > 100) return;
          var o =
            /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
              s
            );
          if (!o) return;
          var l = parseFloat(o[1]);
          switch ((o[2] || "ms").toLowerCase()) {
            case "years":
            case "year":
            case "yrs":
            case "yr":
            case "y":
              return l * a;
            case "weeks":
            case "week":
            case "w":
              return l * i;
            case "days":
            case "day":
            case "d":
              return l * n;
            case "hours":
            case "hour":
            case "hrs":
            case "hr":
            case "h":
              return l * r;
            case "minutes":
            case "minute":
            case "mins":
            case "min":
            case "m":
              return l * t;
            case "seconds":
            case "second":
            case "secs":
            case "sec":
            case "s":
              return l * e;
            case "milliseconds":
            case "millisecond":
            case "msecs":
            case "msec":
            case "ms":
              return l;
            default:
              return;
          }
        })(o);
      if ("number" === u && isFinite(o))
        return l.long
          ? (function (i) {
              var a = Math.abs(i);
              if (a >= n) return s(i, a, n, "day");
              if (a >= r) return s(i, a, r, "hour");
              if (a >= t) return s(i, a, t, "minute");
              if (a >= e) return s(i, a, e, "second");
              return i + " ms";
            })(o)
          : (function (i) {
              var a = Math.abs(i);
              if (a >= n) return Math.round(i / n) + "d";
              if (a >= r) return Math.round(i / r) + "h";
              if (a >= t) return Math.round(i / t) + "m";
              if (a >= e) return Math.round(i / e) + "s";
              return i + "ms";
            })(o);
      throw new Error(
        "val is not a non-empty string or a valid number. val=" +
          JSON.stringify(o)
      );
    }),
    Pf
  );
}
function Mf() {
  if (wf) return kf;
  return (
    (wf = 1),
    (kf = function (e) {
      function t(e) {
        var n,
          i,
          a,
          s = null;
        function o() {
          for (var e = arguments.length, r = new Array(e), i = 0; i < e; i++)
            r[i] = arguments[i];
          if (o.enabled) {
            var a = o,
              s = Number(new Date()),
              l = s - (n || s);
            (a.diff = l),
              (a.prev = n),
              (a.curr = s),
              (n = s),
              (r[0] = t.coerce(r[0])),
              "string" != typeof r[0] && r.unshift("%O");
            var u = 0;
            (r[0] = r[0].replace(/%([a-zA-Z%])/g, function (e, n) {
              if ("%%" === e) return "%";
              u++;
              var i = t.formatters[n];
              if ("function" == typeof i) {
                var s = r[u];
                (e = i.call(a, s)), r.splice(u, 1), u--;
              }
              return e;
            })),
              t.formatArgs.call(a, r),
              (a.log || t.log).apply(a, r);
          }
        }
        return (
          (o.namespace = e),
          (o.useColors = t.useColors()),
          (o.color = t.selectColor(e)),
          (o.extend = r),
          (o.destroy = t.destroy),
          Object.defineProperty(o, "enabled", {
            enumerable: !0,
            configurable: !1,
            get: function () {
              return null !== s
                ? s
                : (i !== t.namespaces &&
                    ((i = t.namespaces), (a = t.enabled(e))),
                  a);
            },
            set: function (e) {
              s = e;
            },
          }),
          "function" == typeof t.init && t.init(o),
          o
        );
      }
      function r(e, r) {
        var n = t(this.namespace + (void 0 === r ? ":" : r) + e);
        return (n.log = this.log), n;
      }
      function n(e) {
        return e
          .toString()
          .substring(2, e.toString().length - 2)
          .replace(/\.\*\?$/, "*");
      }
      return (
        (t.debug = t),
        (t.default = t),
        (t.coerce = function (e) {
          if (e instanceof Error) return e.stack || e.message;
          return e;
        }),
        (t.disable = function () {
          var e = []
            .concat(
              K(t.names.map(n)),
              K(
                t.skips.map(n).map(function (e) {
                  return "-" + e;
                })
              )
            )
            .join(",");
          return t.enable(""), e;
        }),
        (t.enable = function (e) {
          var r;
          t.save(e), (t.namespaces = e), (t.names = []), (t.skips = []);
          var n = ("string" == typeof e ? e : "").split(/[\s,]+/),
            i = n.length;
          for (r = 0; r < i; r++)
            n[r] &&
              ("-" === (e = n[r].replace(/\*/g, ".*?"))[0]
                ? t.skips.push(new RegExp("^" + e.slice(1) + "$"))
                : t.names.push(new RegExp("^" + e + "$")));
        }),
        (t.enabled = function (e) {
          if ("*" === e[e.length - 1]) return !0;
          var r, n;
          for (r = 0, n = t.skips.length; r < n; r++)
            if (t.skips[r].test(e)) return !1;
          for (r = 0, n = t.names.length; r < n; r++)
            if (t.names[r].test(e)) return !0;
          return !1;
        }),
        (t.humanize = Lf()),
        (t.destroy = function () {
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
          );
        }),
        Object.keys(e).forEach(function (r) {
          t[r] = e[r];
        }),
        (t.names = []),
        (t.skips = []),
        (t.formatters = {}),
        (t.selectColor = function (e) {
          for (var r = 0, n = 0; n < e.length; n++)
            (r = (r << 5) - r + e.charCodeAt(n)), (r |= 0);
          return t.colors[Math.abs(r) % t.colors.length];
        }),
        t.enable(t.load()),
        t
      );
    }),
    kf
  );
}
var jf,
  Ff,
  Bf,
  Rf,
  Uf,
  Vf,
  Kf = { exports: {} };
function Wf() {
  return (
    Ff ||
      ((Ff = 1),
      (jf = function (e, t) {
        t = t || process.argv;
        var r = e.startsWith("-") ? "" : 1 === e.length ? "-" : "--",
          n = t.indexOf(r + e),
          i = t.indexOf("--");
        return -1 !== n && (-1 === i || n < i);
      })),
    jf
  );
}
function qf() {
  if (Rf) return Bf;
  Rf = 1;
  var e,
    t = m.default,
    r = Wf(),
    n = process.env;
  function i(i) {
    var a = (function (i) {
      if (!1 === e) return 0;
      if (r("color=16m") || r("color=full") || r("color=truecolor")) return 3;
      if (r("color=256")) return 2;
      if (i && !i.isTTY && !0 !== e) return 0;
      var a = e ? 1 : 0;
      if ("win32" === process.platform) {
        var s = t.release().split(".");
        return Number(process.versions.node.split(".")[0]) >= 8 &&
          Number(s[0]) >= 10 &&
          Number(s[2]) >= 10586
          ? Number(s[2]) >= 14931
            ? 3
            : 2
          : 1;
      }
      if ("CI" in n)
        return ["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI"].some(function (
          e
        ) {
          return e in n;
        }) || "codeship" === n.CI_NAME
          ? 1
          : a;
      if ("TEAMCITY_VERSION" in n)
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(n.TEAMCITY_VERSION) ? 1 : 0;
      if ("truecolor" === n.COLORTERM) return 3;
      if ("TERM_PROGRAM" in n) {
        var o = parseInt((n.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (n.TERM_PROGRAM) {
          case "iTerm.app":
            return o >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      return /-256(color)?$/i.test(n.TERM)
        ? 2
        : /^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(
            n.TERM
          ) || "COLORTERM" in n
        ? 1
        : (n.TERM, a);
    })(i);
    return (function (e) {
      return (
        0 !== e && { level: e, hasBasic: !0, has256: e >= 2, has16m: e >= 3 }
      );
    })(a);
  }
  return (
    r("no-color") || r("no-colors") || r("color=false")
      ? (e = !1)
      : (r("color") || r("colors") || r("color=true") || r("color=always")) &&
        (e = !0),
    "FORCE_COLOR" in n &&
      (e = 0 === n.FORCE_COLOR.length || 0 !== parseInt(n.FORCE_COLOR, 10)),
    (Bf = {
      supportsColor: i,
      stdout: i(process.stdout),
      stderr: i(process.stderr),
    })
  );
}
function Hf() {
  return (
    Uf ||
      ((Uf = 1),
      (function (e, t) {
        var r = f.default,
          n = y.default;
        (t.init = function (e) {
          e.inspectOpts = {};
          for (var r = Object.keys(t.inspectOpts), n = 0; n < r.length; n++)
            e.inspectOpts[r[n]] = t.inspectOpts[r[n]];
        }),
          (t.log = function () {
            return process.stderr.write(n.format.apply(n, arguments) + "\n");
          }),
          (t.formatArgs = function (r) {
            var n = this.namespace,
              i = this.useColors;
            if (i) {
              var a = this.color,
                s = "[3" + (a < 8 ? a : "8;5;" + a),
                o = "  ".concat(s, ";1m").concat(n, " [0m");
              (r[0] = o + r[0].split("\n").join("\n" + o)),
                r.push(s + "m+" + e.exports.humanize(this.diff) + "[0m");
            } else
              r[0] =
                (function () {
                  if (t.inspectOpts.hideDate) return "";
                  return new Date().toISOString() + " ";
                })() +
                n +
                " " +
                r[0];
          }),
          (t.save = function (e) {
            e ? (process.env.DEBUG = e) : delete process.env.DEBUG;
          }),
          (t.load = function () {
            return process.env.DEBUG;
          }),
          (t.useColors = function () {
            return "colors" in t.inspectOpts
              ? Boolean(t.inspectOpts.colors)
              : r.isatty(process.stderr.fd);
          }),
          (t.destroy = n.deprecate(function () {},
          "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")),
          (t.colors = [6, 2, 3, 4, 5, 1]);
        try {
          var i = qf();
          i &&
            (i.stderr || i).level >= 2 &&
            (t.colors = [
              20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57,
              62, 63, 68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99,
              112, 113, 128, 129, 134, 135, 148, 149, 160, 161, 162, 163, 164,
              165, 166, 167, 168, 169, 170, 171, 172, 173, 178, 179, 184, 185,
              196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208,
              209, 214, 215, 220, 221,
            ]);
        } catch (e) {}
        (t.inspectOpts = Object.keys(process.env)
          .filter(function (e) {
            return /^debug_/i.test(e);
          })
          .reduce(function (e, t) {
            var r = t
                .substring(6)
                .toLowerCase()
                .replace(/_([a-z])/g, function (e, t) {
                  return t.toUpperCase();
                }),
              n = process.env[t];
            return (
              (n =
                !!/^(yes|on|true|enabled)$/i.test(n) ||
                (!/^(no|off|false|disabled)$/i.test(n) &&
                  ("null" === n ? null : Number(n)))),
              (e[r] = n),
              e
            );
          }, {})),
          (e.exports = Mf()(t));
        var a = e.exports.formatters;
        (a.o = function (e) {
          return (
            (this.inspectOpts.colors = this.useColors),
            n
              .inspect(e, this.inspectOpts)
              .split("\n")
              .map(function (e) {
                return e.trim();
              })
              .join(" ")
          );
        }),
          (a.O = function (e) {
            return (
              (this.inspectOpts.colors = this.useColors),
              n.inspect(e, this.inspectOpts)
            );
          });
      })(Kf, Kf.exports)),
    Kf.exports
  );
}
(Vf = _f),
  "undefined" == typeof process ||
  "renderer" === process.type ||
  !0 === process.browser ||
  process.__nwjs
    ? (Vf.exports = (function () {
        return (
          Cf ||
            ((Cf = 1),
            (e = Df),
            ((t = Df.exports).formatArgs = function (t) {
              if (
                ((t[0] =
                  (this.useColors ? "%c" : "") +
                  this.namespace +
                  (this.useColors ? " %c" : " ") +
                  t[0] +
                  (this.useColors ? "%c " : " ") +
                  "+" +
                  e.exports.humanize(this.diff)),
                this.useColors)
              ) {
                var r = "color: " + this.color;
                t.splice(1, 0, r, "color: inherit");
                var n = 0,
                  i = 0;
                t[0].replace(/%[a-zA-Z%]/g, function (e) {
                  "%%" !== e && (n++, "%c" === e && (i = n));
                }),
                  t.splice(i, 0, r);
              }
            }),
            (t.save = function (e) {
              try {
                e
                  ? t.storage.setItem("debug", e)
                  : t.storage.removeItem("debug");
              } catch (e) {}
            }),
            (t.load = function () {
              var e;
              try {
                e = t.storage.getItem("debug");
              } catch (e) {}
              return (
                !e &&
                  "undefined" != typeof process &&
                  "env" in process &&
                  (e = process.env.DEBUG),
                e
              );
            }),
            (t.useColors = function () {
              return (
                !(
                  "undefined" == typeof window ||
                  !window.process ||
                  ("renderer" !== window.process.type && !window.process.__nwjs)
                ) ||
                (("undefined" == typeof navigator ||
                  !navigator.userAgent ||
                  !navigator.userAgent
                    .toLowerCase()
                    .match(/(edge|trident)\/(\d+)/)) &&
                  (("undefined" != typeof document &&
                    document.documentElement &&
                    document.documentElement.style &&
                    document.documentElement.style.WebkitAppearance) ||
                    ("undefined" != typeof window &&
                      window.console &&
                      (window.console.firebug ||
                        (window.console.exception && window.console.table))) ||
                    ("undefined" != typeof navigator &&
                      navigator.userAgent &&
                      navigator.userAgent
                        .toLowerCase()
                        .match(/firefox\/(\d+)/) &&
                      parseInt(RegExp.$1, 10) >= 31) ||
                    ("undefined" != typeof navigator &&
                      navigator.userAgent &&
                      navigator.userAgent
                        .toLowerCase()
                        .match(/applewebkit\/(\d+)/))))
              );
            }),
            (t.storage = (function () {
              try {
                return localStorage;
              } catch (e) {}
            })()),
            (t.destroy =
              ((r = !1),
              function () {
                r ||
                  ((r = !0),
                  console.warn(
                    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."
                  ));
              })),
            (t.colors = [
              "#0000CC",
              "#0000FF",
              "#0033CC",
              "#0033FF",
              "#0066CC",
              "#0066FF",
              "#0099CC",
              "#0099FF",
              "#00CC00",
              "#00CC33",
              "#00CC66",
              "#00CC99",
              "#00CCCC",
              "#00CCFF",
              "#3300CC",
              "#3300FF",
              "#3333CC",
              "#3333FF",
              "#3366CC",
              "#3366FF",
              "#3399CC",
              "#3399FF",
              "#33CC00",
              "#33CC33",
              "#33CC66",
              "#33CC99",
              "#33CCCC",
              "#33CCFF",
              "#6600CC",
              "#6600FF",
              "#6633CC",
              "#6633FF",
              "#66CC00",
              "#66CC33",
              "#9900CC",
              "#9900FF",
              "#9933CC",
              "#9933FF",
              "#99CC00",
              "#99CC33",
              "#CC0000",
              "#CC0033",
              "#CC0066",
              "#CC0099",
              "#CC00CC",
              "#CC00FF",
              "#CC3300",
              "#CC3333",
              "#CC3366",
              "#CC3399",
              "#CC33CC",
              "#CC33FF",
              "#CC6600",
              "#CC6633",
              "#CC9900",
              "#CC9933",
              "#CCCC00",
              "#CCCC33",
              "#FF0000",
              "#FF0033",
              "#FF0066",
              "#FF0099",
              "#FF00CC",
              "#FF00FF",
              "#FF3300",
              "#FF3333",
              "#FF3366",
              "#FF3399",
              "#FF33CC",
              "#FF33FF",
              "#FF6600",
              "#FF6633",
              "#FF9900",
              "#FF9933",
              "#FFCC00",
              "#FFCC33",
            ]),
            (t.log = console.debug || console.log || function () {}),
            (e.exports = Mf()(t)),
            (e.exports.formatters.j = function (e) {
              try {
                return JSON.stringify(e);
              } catch (e) {
                return "[UnexpectedJSONParseError]: " + e.message;
              }
            })),
          Df.exports
        );
        var e, t, r;
      })())
    : (Vf.exports = Hf());
var Yf = {},
  Jf = {},
  Xf = {};
Object.defineProperty(Xf, "__esModule", { value: !0 }),
  (Xf.default = function (e) {
    if (!e.isExportDeclaration() || e.isExportAllDeclaration())
      throw new Error(
        "Only default and named export declarations can be split."
      );
    if (e.isExportDefaultDeclaration()) {
      var t = e.get("declaration"),
        r = t.isFunctionDeclaration() || t.isClassDeclaration(),
        n = t.isScope() ? t.scope.parent : t.scope,
        i = t.node.id,
        a = !1;
      i ||
        ((a = !0),
        (i = n.generateUidIdentifier("default")),
        (r || t.isFunctionExpression() || t.isClassExpression()) &&
          (t.node.id = zf(i)));
      var s = r ? t.node : ey("var", [ty(zf(i), t.node)]),
        o = $f(null, [Qf(zf(i), Zf("default"))]);
      return (
        e.insertAfter(o), e.replaceWith(s), a && n.registerDeclaration(e), e
      );
    }
    if (e.get("specifiers").length > 0)
      throw new Error("It doesn't make sense to split exported specifiers.");
    var l = e.get("declaration"),
      u = l.getOuterBindingIdentifiers(),
      c = Object.keys(u).map(function (e) {
        return Qf(Zf(e), Zf(e));
      }),
      p = $f(null, c);
    return e.insertAfter(p), e.replaceWith(l.node), e;
  });
var Gf = mc(),
  zf = Gf.cloneNode,
  $f = Gf.exportNamedDeclaration,
  Qf = Gf.exportSpecifier,
  Zf = Gf.identifier,
  ey = Gf.variableDeclaration,
  ty = Gf.variableDeclarator;
var ry = {};
function ny(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return iy(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return iy(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function iy(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function ay(e) {
  var t = e.context,
    r = e.node;
  if ((r.computed && t.maybeQueue(e.get("key")), r.decorators)) {
    var n,
      i = ny(e.get("decorators"));
    try {
      for (i.s(); !(n = i.n()).done; ) {
        var a = n.value;
        t.maybeQueue(a);
      }
    } catch (e) {
      i.e(e);
    } finally {
      i.f();
    }
  }
}
Object.defineProperty(ry, "__esModule", { value: !0 }),
  (ry.default = void 0),
  (ry.requeueComputedKeyAndDecorators = ay),
  (ry.skipAllButComputedKey = function (e) {
    e.skip(), e.node.computed && e.context.maybeQueue(e.get("key"));
  });
var sy,
  oy = {
    FunctionParent: function (e) {
      e.isArrowFunctionExpression() || (e.skip(), e.isMethod() && ay(e));
    },
    Property: function (e) {
      e.isObjectProperty() || (e.skip(), ay(e));
    },
  },
  ly = oy;
ry.default = ly;
var uy = {};
Object.defineProperty(uy, "__esModule", { value: !0 }), (uy.default = void 0);
var cy = (function () {
  function e(t) {
    var r = t.identifier,
      n = t.scope,
      i = t.path,
      a = t.kind;
    E(this, e),
      (this.identifier = void 0),
      (this.scope = void 0),
      (this.path = void 0),
      (this.kind = void 0),
      (this.constantViolations = []),
      (this.constant = !0),
      (this.referencePaths = []),
      (this.referenced = !1),
      (this.references = 0),
      (this.identifier = r),
      (this.scope = n),
      (this.path = i),
      (this.kind = a),
      ("var" !== a && "hoisted" !== a) ||
        !(function (e) {
          for (
            var t = e.parentPath, r = e.key;
            t;
            t = (n = t).parentPath, r = n.key, n
          ) {
            var n;
            if (t.isFunctionParent()) return !1;
            if (
              t.isWhile() ||
              t.isForXStatement() ||
              (t.isForStatement() && "body" === r)
            )
              return !0;
          }
          return !1;
        })(
          i ||
            (function () {
              throw new Error("Internal Babel error: unreachable ");
            })()
        ) ||
        this.reassign(i),
      this.clearValue();
  }
  return (
    A(e, [
      {
        key: "deoptValue",
        value: function () {
          this.clearValue(), (this.hasDeoptedValue = !0);
        },
      },
      {
        key: "setValue",
        value: function (e) {
          this.hasDeoptedValue || ((this.hasValue = !0), (this.value = e));
        },
      },
      {
        key: "clearValue",
        value: function () {
          (this.hasDeoptedValue = !1),
            (this.hasValue = !1),
            (this.value = null);
        },
      },
      {
        key: "reassign",
        value: function (e) {
          (this.constant = !1),
            -1 === this.constantViolations.indexOf(e) &&
              this.constantViolations.push(e);
        },
      },
      {
        key: "reference",
        value: function (e) {
          -1 === this.referencePaths.indexOf(e) &&
            ((this.referenced = !0),
            this.references++,
            this.referencePaths.push(e));
        },
      },
      {
        key: "dereference",
        value: function () {
          this.references--, (this.referenced = !!this.references);
        },
      },
    ]),
    e
  );
})();
uy.default = cy;
var py,
  hy = { exports: {} },
  dy = {
    builtin: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      BigInt: !1,
      BigInt64Array: !1,
      BigUint64Array: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      globalThis: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1,
    },
    es5: {
      Array: !1,
      Boolean: !1,
      constructor: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      propertyIsEnumerable: !1,
      RangeError: !1,
      ReferenceError: !1,
      RegExp: !1,
      String: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
    },
    es2015: {
      Array: !1,
      ArrayBuffer: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1,
    },
    es2017: {
      Array: !1,
      ArrayBuffer: !1,
      Atomics: !1,
      Boolean: !1,
      constructor: !1,
      DataView: !1,
      Date: !1,
      decodeURI: !1,
      decodeURIComponent: !1,
      encodeURI: !1,
      encodeURIComponent: !1,
      Error: !1,
      escape: !1,
      eval: !1,
      EvalError: !1,
      Float32Array: !1,
      Float64Array: !1,
      Function: !1,
      hasOwnProperty: !1,
      Infinity: !1,
      Int16Array: !1,
      Int32Array: !1,
      Int8Array: !1,
      isFinite: !1,
      isNaN: !1,
      isPrototypeOf: !1,
      JSON: !1,
      Map: !1,
      Math: !1,
      NaN: !1,
      Number: !1,
      Object: !1,
      parseFloat: !1,
      parseInt: !1,
      Promise: !1,
      propertyIsEnumerable: !1,
      Proxy: !1,
      RangeError: !1,
      ReferenceError: !1,
      Reflect: !1,
      RegExp: !1,
      Set: !1,
      SharedArrayBuffer: !1,
      String: !1,
      Symbol: !1,
      SyntaxError: !1,
      toLocaleString: !1,
      toString: !1,
      TypeError: !1,
      Uint16Array: !1,
      Uint32Array: !1,
      Uint8Array: !1,
      Uint8ClampedArray: !1,
      undefined: !1,
      unescape: !1,
      URIError: !1,
      valueOf: !1,
      WeakMap: !1,
      WeakSet: !1,
    },
    browser: {
      AbortController: !1,
      AbortSignal: !1,
      addEventListener: !1,
      alert: !1,
      AnalyserNode: !1,
      Animation: !1,
      AnimationEffectReadOnly: !1,
      AnimationEffectTiming: !1,
      AnimationEffectTimingReadOnly: !1,
      AnimationEvent: !1,
      AnimationPlaybackEvent: !1,
      AnimationTimeline: !1,
      applicationCache: !1,
      ApplicationCache: !1,
      ApplicationCacheErrorEvent: !1,
      atob: !1,
      Attr: !1,
      Audio: !1,
      AudioBuffer: !1,
      AudioBufferSourceNode: !1,
      AudioContext: !1,
      AudioDestinationNode: !1,
      AudioListener: !1,
      AudioNode: !1,
      AudioParam: !1,
      AudioProcessingEvent: !1,
      AudioScheduledSourceNode: !1,
      "AudioWorkletGlobalScope ": !1,
      AudioWorkletNode: !1,
      AudioWorkletProcessor: !1,
      BarProp: !1,
      BaseAudioContext: !1,
      BatteryManager: !1,
      BeforeUnloadEvent: !1,
      BiquadFilterNode: !1,
      Blob: !1,
      BlobEvent: !1,
      blur: !1,
      BroadcastChannel: !1,
      btoa: !1,
      BudgetService: !1,
      ByteLengthQueuingStrategy: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      cancelAnimationFrame: !1,
      cancelIdleCallback: !1,
      CanvasCaptureMediaStreamTrack: !1,
      CanvasGradient: !1,
      CanvasPattern: !1,
      CanvasRenderingContext2D: !1,
      ChannelMergerNode: !1,
      ChannelSplitterNode: !1,
      CharacterData: !1,
      clearInterval: !1,
      clearTimeout: !1,
      clientInformation: !1,
      ClipboardEvent: !1,
      close: !1,
      closed: !1,
      CloseEvent: !1,
      Comment: !1,
      CompositionEvent: !1,
      confirm: !1,
      console: !1,
      ConstantSourceNode: !1,
      ConvolverNode: !1,
      CountQueuingStrategy: !1,
      createImageBitmap: !1,
      Credential: !1,
      CredentialsContainer: !1,
      crypto: !1,
      Crypto: !1,
      CryptoKey: !1,
      CSS: !1,
      CSSConditionRule: !1,
      CSSFontFaceRule: !1,
      CSSGroupingRule: !1,
      CSSImportRule: !1,
      CSSKeyframeRule: !1,
      CSSKeyframesRule: !1,
      CSSMediaRule: !1,
      CSSNamespaceRule: !1,
      CSSPageRule: !1,
      CSSRule: !1,
      CSSRuleList: !1,
      CSSStyleDeclaration: !1,
      CSSStyleRule: !1,
      CSSStyleSheet: !1,
      CSSSupportsRule: !1,
      CustomElementRegistry: !1,
      customElements: !1,
      CustomEvent: !1,
      DataTransfer: !1,
      DataTransferItem: !1,
      DataTransferItemList: !1,
      defaultstatus: !1,
      defaultStatus: !1,
      DelayNode: !1,
      DeviceMotionEvent: !1,
      DeviceOrientationEvent: !1,
      devicePixelRatio: !1,
      dispatchEvent: !1,
      document: !1,
      Document: !1,
      DocumentFragment: !1,
      DocumentType: !1,
      DOMError: !1,
      DOMException: !1,
      DOMImplementation: !1,
      DOMMatrix: !1,
      DOMMatrixReadOnly: !1,
      DOMParser: !1,
      DOMPoint: !1,
      DOMPointReadOnly: !1,
      DOMQuad: !1,
      DOMRect: !1,
      DOMRectReadOnly: !1,
      DOMStringList: !1,
      DOMStringMap: !1,
      DOMTokenList: !1,
      DragEvent: !1,
      DynamicsCompressorNode: !1,
      Element: !1,
      ErrorEvent: !1,
      event: !1,
      Event: !1,
      EventSource: !1,
      EventTarget: !1,
      external: !1,
      fetch: !1,
      File: !1,
      FileList: !1,
      FileReader: !1,
      find: !1,
      focus: !1,
      FocusEvent: !1,
      FontFace: !1,
      FontFaceSetLoadEvent: !1,
      FormData: !1,
      frameElement: !1,
      frames: !1,
      GainNode: !1,
      Gamepad: !1,
      GamepadButton: !1,
      GamepadEvent: !1,
      getComputedStyle: !1,
      getSelection: !1,
      HashChangeEvent: !1,
      Headers: !1,
      history: !1,
      History: !1,
      HTMLAllCollection: !1,
      HTMLAnchorElement: !1,
      HTMLAreaElement: !1,
      HTMLAudioElement: !1,
      HTMLBaseElement: !1,
      HTMLBodyElement: !1,
      HTMLBRElement: !1,
      HTMLButtonElement: !1,
      HTMLCanvasElement: !1,
      HTMLCollection: !1,
      HTMLContentElement: !1,
      HTMLDataElement: !1,
      HTMLDataListElement: !1,
      HTMLDetailsElement: !1,
      HTMLDialogElement: !1,
      HTMLDirectoryElement: !1,
      HTMLDivElement: !1,
      HTMLDListElement: !1,
      HTMLDocument: !1,
      HTMLElement: !1,
      HTMLEmbedElement: !1,
      HTMLFieldSetElement: !1,
      HTMLFontElement: !1,
      HTMLFormControlsCollection: !1,
      HTMLFormElement: !1,
      HTMLFrameElement: !1,
      HTMLFrameSetElement: !1,
      HTMLHeadElement: !1,
      HTMLHeadingElement: !1,
      HTMLHRElement: !1,
      HTMLHtmlElement: !1,
      HTMLIFrameElement: !1,
      HTMLImageElement: !1,
      HTMLInputElement: !1,
      HTMLLabelElement: !1,
      HTMLLegendElement: !1,
      HTMLLIElement: !1,
      HTMLLinkElement: !1,
      HTMLMapElement: !1,
      HTMLMarqueeElement: !1,
      HTMLMediaElement: !1,
      HTMLMenuElement: !1,
      HTMLMetaElement: !1,
      HTMLMeterElement: !1,
      HTMLModElement: !1,
      HTMLObjectElement: !1,
      HTMLOListElement: !1,
      HTMLOptGroupElement: !1,
      HTMLOptionElement: !1,
      HTMLOptionsCollection: !1,
      HTMLOutputElement: !1,
      HTMLParagraphElement: !1,
      HTMLParamElement: !1,
      HTMLPictureElement: !1,
      HTMLPreElement: !1,
      HTMLProgressElement: !1,
      HTMLQuoteElement: !1,
      HTMLScriptElement: !1,
      HTMLSelectElement: !1,
      HTMLShadowElement: !1,
      HTMLSlotElement: !1,
      HTMLSourceElement: !1,
      HTMLSpanElement: !1,
      HTMLStyleElement: !1,
      HTMLTableCaptionElement: !1,
      HTMLTableCellElement: !1,
      HTMLTableColElement: !1,
      HTMLTableElement: !1,
      HTMLTableRowElement: !1,
      HTMLTableSectionElement: !1,
      HTMLTemplateElement: !1,
      HTMLTextAreaElement: !1,
      HTMLTimeElement: !1,
      HTMLTitleElement: !1,
      HTMLTrackElement: !1,
      HTMLUListElement: !1,
      HTMLUnknownElement: !1,
      HTMLVideoElement: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      IdleDeadline: !1,
      IIRFilterNode: !1,
      Image: !1,
      ImageBitmap: !1,
      ImageBitmapRenderingContext: !1,
      ImageCapture: !1,
      ImageData: !1,
      indexedDB: !1,
      innerHeight: !1,
      innerWidth: !1,
      InputEvent: !1,
      IntersectionObserver: !1,
      IntersectionObserverEntry: !1,
      Intl: !1,
      isSecureContext: !1,
      KeyboardEvent: !1,
      KeyframeEffect: !1,
      KeyframeEffectReadOnly: !1,
      length: !1,
      localStorage: !1,
      location: !0,
      Location: !1,
      locationbar: !1,
      matchMedia: !1,
      MediaDeviceInfo: !1,
      MediaDevices: !1,
      MediaElementAudioSourceNode: !1,
      MediaEncryptedEvent: !1,
      MediaError: !1,
      MediaKeyMessageEvent: !1,
      MediaKeySession: !1,
      MediaKeyStatusMap: !1,
      MediaKeySystemAccess: !1,
      MediaList: !1,
      MediaQueryList: !1,
      MediaQueryListEvent: !1,
      MediaRecorder: !1,
      MediaSettingsRange: !1,
      MediaSource: !1,
      MediaStream: !1,
      MediaStreamAudioDestinationNode: !1,
      MediaStreamAudioSourceNode: !1,
      MediaStreamEvent: !1,
      MediaStreamTrack: !1,
      MediaStreamTrackEvent: !1,
      menubar: !1,
      MessageChannel: !1,
      MessageEvent: !1,
      MessagePort: !1,
      MIDIAccess: !1,
      MIDIConnectionEvent: !1,
      MIDIInput: !1,
      MIDIInputMap: !1,
      MIDIMessageEvent: !1,
      MIDIOutput: !1,
      MIDIOutputMap: !1,
      MIDIPort: !1,
      MimeType: !1,
      MimeTypeArray: !1,
      MouseEvent: !1,
      moveBy: !1,
      moveTo: !1,
      MutationEvent: !1,
      MutationObserver: !1,
      MutationRecord: !1,
      name: !1,
      NamedNodeMap: !1,
      NavigationPreloadManager: !1,
      navigator: !1,
      Navigator: !1,
      NetworkInformation: !1,
      Node: !1,
      NodeFilter: !1,
      NodeIterator: !1,
      NodeList: !1,
      Notification: !1,
      OfflineAudioCompletionEvent: !1,
      OfflineAudioContext: !1,
      offscreenBuffering: !1,
      OffscreenCanvas: !0,
      onabort: !0,
      onafterprint: !0,
      onanimationend: !0,
      onanimationiteration: !0,
      onanimationstart: !0,
      onappinstalled: !0,
      onauxclick: !0,
      onbeforeinstallprompt: !0,
      onbeforeprint: !0,
      onbeforeunload: !0,
      onblur: !0,
      oncancel: !0,
      oncanplay: !0,
      oncanplaythrough: !0,
      onchange: !0,
      onclick: !0,
      onclose: !0,
      oncontextmenu: !0,
      oncuechange: !0,
      ondblclick: !0,
      ondevicemotion: !0,
      ondeviceorientation: !0,
      ondeviceorientationabsolute: !0,
      ondrag: !0,
      ondragend: !0,
      ondragenter: !0,
      ondragleave: !0,
      ondragover: !0,
      ondragstart: !0,
      ondrop: !0,
      ondurationchange: !0,
      onemptied: !0,
      onended: !0,
      onerror: !0,
      onfocus: !0,
      ongotpointercapture: !0,
      onhashchange: !0,
      oninput: !0,
      oninvalid: !0,
      onkeydown: !0,
      onkeypress: !0,
      onkeyup: !0,
      onlanguagechange: !0,
      onload: !0,
      onloadeddata: !0,
      onloadedmetadata: !0,
      onloadstart: !0,
      onlostpointercapture: !0,
      onmessage: !0,
      onmessageerror: !0,
      onmousedown: !0,
      onmouseenter: !0,
      onmouseleave: !0,
      onmousemove: !0,
      onmouseout: !0,
      onmouseover: !0,
      onmouseup: !0,
      onmousewheel: !0,
      onoffline: !0,
      ononline: !0,
      onpagehide: !0,
      onpageshow: !0,
      onpause: !0,
      onplay: !0,
      onplaying: !0,
      onpointercancel: !0,
      onpointerdown: !0,
      onpointerenter: !0,
      onpointerleave: !0,
      onpointermove: !0,
      onpointerout: !0,
      onpointerover: !0,
      onpointerup: !0,
      onpopstate: !0,
      onprogress: !0,
      onratechange: !0,
      onrejectionhandled: !0,
      onreset: !0,
      onresize: !0,
      onscroll: !0,
      onsearch: !0,
      onseeked: !0,
      onseeking: !0,
      onselect: !0,
      onstalled: !0,
      onstorage: !0,
      onsubmit: !0,
      onsuspend: !0,
      ontimeupdate: !0,
      ontoggle: !0,
      ontransitionend: !0,
      onunhandledrejection: !0,
      onunload: !0,
      onvolumechange: !0,
      onwaiting: !0,
      onwheel: !0,
      open: !1,
      openDatabase: !1,
      opener: !1,
      Option: !1,
      origin: !1,
      OscillatorNode: !1,
      outerHeight: !1,
      outerWidth: !1,
      PageTransitionEvent: !1,
      pageXOffset: !1,
      pageYOffset: !1,
      PannerNode: !1,
      parent: !1,
      Path2D: !1,
      PaymentAddress: !1,
      PaymentRequest: !1,
      PaymentRequestUpdateEvent: !1,
      PaymentResponse: !1,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceLongTaskTiming: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceNavigationTiming: !1,
      PerformanceObserver: !1,
      PerformanceObserverEntryList: !1,
      PerformancePaintTiming: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      PeriodicWave: !1,
      Permissions: !1,
      PermissionStatus: !1,
      personalbar: !1,
      PhotoCapabilities: !1,
      Plugin: !1,
      PluginArray: !1,
      PointerEvent: !1,
      PopStateEvent: !1,
      postMessage: !1,
      Presentation: !1,
      PresentationAvailability: !1,
      PresentationConnection: !1,
      PresentationConnectionAvailableEvent: !1,
      PresentationConnectionCloseEvent: !1,
      PresentationConnectionList: !1,
      PresentationReceiver: !1,
      PresentationRequest: !1,
      print: !1,
      ProcessingInstruction: !1,
      ProgressEvent: !1,
      PromiseRejectionEvent: !1,
      prompt: !1,
      PushManager: !1,
      PushSubscription: !1,
      PushSubscriptionOptions: !1,
      queueMicrotask: !1,
      RadioNodeList: !1,
      Range: !1,
      ReadableStream: !1,
      registerProcessor: !1,
      RemotePlayback: !1,
      removeEventListener: !1,
      Request: !1,
      requestAnimationFrame: !1,
      requestIdleCallback: !1,
      resizeBy: !1,
      ResizeObserver: !1,
      ResizeObserverEntry: !1,
      resizeTo: !1,
      Response: !1,
      RTCCertificate: !1,
      RTCDataChannel: !1,
      RTCDataChannelEvent: !1,
      RTCDtlsTransport: !1,
      RTCIceCandidate: !1,
      RTCIceGatherer: !1,
      RTCIceTransport: !1,
      RTCPeerConnection: !1,
      RTCPeerConnectionIceEvent: !1,
      RTCRtpContributingSource: !1,
      RTCRtpReceiver: !1,
      RTCRtpSender: !1,
      RTCSctpTransport: !1,
      RTCSessionDescription: !1,
      RTCStatsReport: !1,
      RTCTrackEvent: !1,
      screen: !1,
      Screen: !1,
      screenLeft: !1,
      ScreenOrientation: !1,
      screenTop: !1,
      screenX: !1,
      screenY: !1,
      ScriptProcessorNode: !1,
      scroll: !1,
      scrollbars: !1,
      scrollBy: !1,
      scrollTo: !1,
      scrollX: !1,
      scrollY: !1,
      SecurityPolicyViolationEvent: !1,
      Selection: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerRegistration: !1,
      sessionStorage: !1,
      setInterval: !1,
      setTimeout: !1,
      ShadowRoot: !1,
      SharedWorker: !1,
      SourceBuffer: !1,
      SourceBufferList: !1,
      speechSynthesis: !1,
      SpeechSynthesisEvent: !1,
      SpeechSynthesisUtterance: !1,
      StaticRange: !1,
      status: !1,
      statusbar: !1,
      StereoPannerNode: !1,
      stop: !1,
      Storage: !1,
      StorageEvent: !1,
      StorageManager: !1,
      styleMedia: !1,
      StyleSheet: !1,
      StyleSheetList: !1,
      SubtleCrypto: !1,
      SVGAElement: !1,
      SVGAngle: !1,
      SVGAnimatedAngle: !1,
      SVGAnimatedBoolean: !1,
      SVGAnimatedEnumeration: !1,
      SVGAnimatedInteger: !1,
      SVGAnimatedLength: !1,
      SVGAnimatedLengthList: !1,
      SVGAnimatedNumber: !1,
      SVGAnimatedNumberList: !1,
      SVGAnimatedPreserveAspectRatio: !1,
      SVGAnimatedRect: !1,
      SVGAnimatedString: !1,
      SVGAnimatedTransformList: !1,
      SVGAnimateElement: !1,
      SVGAnimateMotionElement: !1,
      SVGAnimateTransformElement: !1,
      SVGAnimationElement: !1,
      SVGCircleElement: !1,
      SVGClipPathElement: !1,
      SVGComponentTransferFunctionElement: !1,
      SVGDefsElement: !1,
      SVGDescElement: !1,
      SVGDiscardElement: !1,
      SVGElement: !1,
      SVGEllipseElement: !1,
      SVGFEBlendElement: !1,
      SVGFEColorMatrixElement: !1,
      SVGFEComponentTransferElement: !1,
      SVGFECompositeElement: !1,
      SVGFEConvolveMatrixElement: !1,
      SVGFEDiffuseLightingElement: !1,
      SVGFEDisplacementMapElement: !1,
      SVGFEDistantLightElement: !1,
      SVGFEDropShadowElement: !1,
      SVGFEFloodElement: !1,
      SVGFEFuncAElement: !1,
      SVGFEFuncBElement: !1,
      SVGFEFuncGElement: !1,
      SVGFEFuncRElement: !1,
      SVGFEGaussianBlurElement: !1,
      SVGFEImageElement: !1,
      SVGFEMergeElement: !1,
      SVGFEMergeNodeElement: !1,
      SVGFEMorphologyElement: !1,
      SVGFEOffsetElement: !1,
      SVGFEPointLightElement: !1,
      SVGFESpecularLightingElement: !1,
      SVGFESpotLightElement: !1,
      SVGFETileElement: !1,
      SVGFETurbulenceElement: !1,
      SVGFilterElement: !1,
      SVGForeignObjectElement: !1,
      SVGGElement: !1,
      SVGGeometryElement: !1,
      SVGGradientElement: !1,
      SVGGraphicsElement: !1,
      SVGImageElement: !1,
      SVGLength: !1,
      SVGLengthList: !1,
      SVGLinearGradientElement: !1,
      SVGLineElement: !1,
      SVGMarkerElement: !1,
      SVGMaskElement: !1,
      SVGMatrix: !1,
      SVGMetadataElement: !1,
      SVGMPathElement: !1,
      SVGNumber: !1,
      SVGNumberList: !1,
      SVGPathElement: !1,
      SVGPatternElement: !1,
      SVGPoint: !1,
      SVGPointList: !1,
      SVGPolygonElement: !1,
      SVGPolylineElement: !1,
      SVGPreserveAspectRatio: !1,
      SVGRadialGradientElement: !1,
      SVGRect: !1,
      SVGRectElement: !1,
      SVGScriptElement: !1,
      SVGSetElement: !1,
      SVGStopElement: !1,
      SVGStringList: !1,
      SVGStyleElement: !1,
      SVGSVGElement: !1,
      SVGSwitchElement: !1,
      SVGSymbolElement: !1,
      SVGTextContentElement: !1,
      SVGTextElement: !1,
      SVGTextPathElement: !1,
      SVGTextPositioningElement: !1,
      SVGTitleElement: !1,
      SVGTransform: !1,
      SVGTransformList: !1,
      SVGTSpanElement: !1,
      SVGUnitTypes: !1,
      SVGUseElement: !1,
      SVGViewElement: !1,
      TaskAttributionTiming: !1,
      Text: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      TextEvent: !1,
      TextMetrics: !1,
      TextTrack: !1,
      TextTrackCue: !1,
      TextTrackCueList: !1,
      TextTrackList: !1,
      TimeRanges: !1,
      toolbar: !1,
      top: !1,
      Touch: !1,
      TouchEvent: !1,
      TouchList: !1,
      TrackEvent: !1,
      TransitionEvent: !1,
      TreeWalker: !1,
      UIEvent: !1,
      URL: !1,
      URLSearchParams: !1,
      ValidityState: !1,
      visualViewport: !1,
      VisualViewport: !1,
      VTTCue: !1,
      WaveShaperNode: !1,
      WebAssembly: !1,
      WebGL2RenderingContext: !1,
      WebGLActiveInfo: !1,
      WebGLBuffer: !1,
      WebGLContextEvent: !1,
      WebGLFramebuffer: !1,
      WebGLProgram: !1,
      WebGLQuery: !1,
      WebGLRenderbuffer: !1,
      WebGLRenderingContext: !1,
      WebGLSampler: !1,
      WebGLShader: !1,
      WebGLShaderPrecisionFormat: !1,
      WebGLSync: !1,
      WebGLTexture: !1,
      WebGLTransformFeedback: !1,
      WebGLUniformLocation: !1,
      WebGLVertexArrayObject: !1,
      WebSocket: !1,
      WheelEvent: !1,
      window: !1,
      Window: !1,
      Worker: !1,
      WritableStream: !1,
      XMLDocument: !1,
      XMLHttpRequest: !1,
      XMLHttpRequestEventTarget: !1,
      XMLHttpRequestUpload: !1,
      XMLSerializer: !1,
      XPathEvaluator: !1,
      XPathExpression: !1,
      XPathResult: !1,
      XSLTProcessor: !1,
    },
    worker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      clearInterval: !1,
      clearTimeout: !1,
      close: !0,
      console: !1,
      fetch: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !0,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onoffline: !0,
      ononline: !0,
      onrejectionhandled: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !0,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1,
    },
    node: {
      __dirname: !1,
      __filename: !1,
      Buffer: !1,
      clearImmediate: !1,
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      exports: !0,
      global: !1,
      Intl: !1,
      module: !1,
      process: !1,
      queueMicrotask: !1,
      require: !1,
      setImmediate: !1,
      setInterval: !1,
      setTimeout: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
    },
    commonjs: { exports: !0, global: !1, module: !1, require: !1 },
    amd: { define: !1, require: !1 },
    mocha: {
      after: !1,
      afterEach: !1,
      before: !1,
      beforeEach: !1,
      context: !1,
      describe: !1,
      it: !1,
      mocha: !1,
      run: !1,
      setup: !1,
      specify: !1,
      suite: !1,
      suiteSetup: !1,
      suiteTeardown: !1,
      teardown: !1,
      test: !1,
      xcontext: !1,
      xdescribe: !1,
      xit: !1,
      xspecify: !1,
    },
    jasmine: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fail: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jasmine: !1,
      pending: !1,
      runs: !1,
      spyOn: !1,
      spyOnProperty: !1,
      waits: !1,
      waitsFor: !1,
      xdescribe: !1,
      xit: !1,
    },
    jest: {
      afterAll: !1,
      afterEach: !1,
      beforeAll: !1,
      beforeEach: !1,
      describe: !1,
      expect: !1,
      fdescribe: !1,
      fit: !1,
      it: !1,
      jest: !1,
      pit: !1,
      require: !1,
      test: !1,
      xdescribe: !1,
      xit: !1,
      xtest: !1,
    },
    qunit: {
      asyncTest: !1,
      deepEqual: !1,
      equal: !1,
      expect: !1,
      module: !1,
      notDeepEqual: !1,
      notEqual: !1,
      notOk: !1,
      notPropEqual: !1,
      notStrictEqual: !1,
      ok: !1,
      propEqual: !1,
      QUnit: !1,
      raises: !1,
      start: !1,
      stop: !1,
      strictEqual: !1,
      test: !1,
      throws: !1,
    },
    phantomjs: {
      console: !0,
      exports: !0,
      phantom: !0,
      require: !0,
      WebPage: !0,
    },
    couch: {
      emit: !1,
      exports: !1,
      getRow: !1,
      log: !1,
      module: !1,
      provides: !1,
      require: !1,
      respond: !1,
      send: !1,
      start: !1,
      sum: !1,
    },
    rhino: {
      defineClass: !1,
      deserialize: !1,
      gc: !1,
      help: !1,
      importClass: !1,
      importPackage: !1,
      java: !1,
      load: !1,
      loadClass: !1,
      Packages: !1,
      print: !1,
      quit: !1,
      readFile: !1,
      readUrl: !1,
      runCommand: !1,
      seal: !1,
      serialize: !1,
      spawn: !1,
      sync: !1,
      toint32: !1,
      version: !1,
    },
    nashorn: {
      __DIR__: !1,
      __FILE__: !1,
      __LINE__: !1,
      com: !1,
      edu: !1,
      exit: !1,
      java: !1,
      Java: !1,
      javafx: !1,
      JavaImporter: !1,
      javax: !1,
      JSAdapter: !1,
      load: !1,
      loadWithNewGlobal: !1,
      org: !1,
      Packages: !1,
      print: !1,
      quit: !1,
    },
    wsh: {
      ActiveXObject: !0,
      Enumerator: !0,
      GetObject: !0,
      ScriptEngine: !0,
      ScriptEngineBuildVersion: !0,
      ScriptEngineMajorVersion: !0,
      ScriptEngineMinorVersion: !0,
      VBArray: !0,
      WScript: !0,
      WSH: !0,
      XDomainRequest: !0,
    },
    jquery: { $: !1, jQuery: !1 },
    yui: { YAHOO: !1, YAHOO_config: !1, YUI: !1, YUI_config: !1 },
    shelljs: {
      cat: !1,
      cd: !1,
      chmod: !1,
      config: !1,
      cp: !1,
      dirs: !1,
      echo: !1,
      env: !1,
      error: !1,
      exec: !1,
      exit: !1,
      find: !1,
      grep: !1,
      ln: !1,
      ls: !1,
      mkdir: !1,
      mv: !1,
      popd: !1,
      pushd: !1,
      pwd: !1,
      rm: !1,
      sed: !1,
      set: !1,
      target: !1,
      tempdir: !1,
      test: !1,
      touch: !1,
      which: !1,
    },
    prototypejs: {
      $: !1,
      $$: !1,
      $A: !1,
      $break: !1,
      $continue: !1,
      $F: !1,
      $H: !1,
      $R: !1,
      $w: !1,
      Abstract: !1,
      Ajax: !1,
      Autocompleter: !1,
      Builder: !1,
      Class: !1,
      Control: !1,
      Draggable: !1,
      Draggables: !1,
      Droppables: !1,
      Effect: !1,
      Element: !1,
      Enumerable: !1,
      Event: !1,
      Field: !1,
      Form: !1,
      Hash: !1,
      Insertion: !1,
      ObjectRange: !1,
      PeriodicalExecuter: !1,
      Position: !1,
      Prototype: !1,
      Scriptaculous: !1,
      Selector: !1,
      Sortable: !1,
      SortableObserver: !1,
      Sound: !1,
      Template: !1,
      Toggle: !1,
      Try: !1,
    },
    meteor: {
      _: !1,
      $: !1,
      Accounts: !1,
      AccountsClient: !1,
      AccountsCommon: !1,
      AccountsServer: !1,
      App: !1,
      Assets: !1,
      Blaze: !1,
      check: !1,
      Cordova: !1,
      DDP: !1,
      DDPRateLimiter: !1,
      DDPServer: !1,
      Deps: !1,
      EJSON: !1,
      Email: !1,
      HTTP: !1,
      Log: !1,
      Match: !1,
      Meteor: !1,
      Mongo: !1,
      MongoInternals: !1,
      Npm: !1,
      Package: !1,
      Plugin: !1,
      process: !1,
      Random: !1,
      ReactiveDict: !1,
      ReactiveVar: !1,
      Router: !1,
      ServiceConfiguration: !1,
      Session: !1,
      share: !1,
      Spacebars: !1,
      Template: !1,
      Tinytest: !1,
      Tracker: !1,
      UI: !1,
      Utils: !1,
      WebApp: !1,
      WebAppInternals: !1,
    },
    mongo: {
      _isWindows: !1,
      _rand: !1,
      BulkWriteResult: !1,
      cat: !1,
      cd: !1,
      connect: !1,
      db: !1,
      getHostName: !1,
      getMemInfo: !1,
      hostname: !1,
      ISODate: !1,
      listFiles: !1,
      load: !1,
      ls: !1,
      md5sumFile: !1,
      mkdir: !1,
      Mongo: !1,
      NumberInt: !1,
      NumberLong: !1,
      ObjectId: !1,
      PlanCache: !1,
      print: !1,
      printjson: !1,
      pwd: !1,
      quit: !1,
      removeFile: !1,
      rs: !1,
      sh: !1,
      UUID: !1,
      version: !1,
      WriteResult: !1,
    },
    applescript: {
      $: !1,
      Application: !1,
      Automation: !1,
      console: !1,
      delay: !1,
      Library: !1,
      ObjC: !1,
      ObjectSpecifier: !1,
      Path: !1,
      Progress: !1,
      Ref: !1,
    },
    serviceworker: {
      addEventListener: !1,
      applicationCache: !1,
      atob: !1,
      Blob: !1,
      BroadcastChannel: !1,
      btoa: !1,
      Cache: !1,
      caches: !1,
      CacheStorage: !1,
      clearInterval: !1,
      clearTimeout: !1,
      Client: !1,
      clients: !1,
      Clients: !1,
      close: !0,
      console: !1,
      ExtendableEvent: !1,
      ExtendableMessageEvent: !1,
      fetch: !1,
      FetchEvent: !1,
      FileReaderSync: !1,
      FormData: !1,
      Headers: !1,
      IDBCursor: !1,
      IDBCursorWithValue: !1,
      IDBDatabase: !1,
      IDBFactory: !1,
      IDBIndex: !1,
      IDBKeyRange: !1,
      IDBObjectStore: !1,
      IDBOpenDBRequest: !1,
      IDBRequest: !1,
      IDBTransaction: !1,
      IDBVersionChangeEvent: !1,
      ImageData: !1,
      importScripts: !1,
      indexedDB: !1,
      location: !1,
      MessageChannel: !1,
      MessagePort: !1,
      name: !1,
      navigator: !1,
      Notification: !1,
      onclose: !0,
      onconnect: !0,
      onerror: !0,
      onfetch: !0,
      oninstall: !0,
      onlanguagechange: !0,
      onmessage: !0,
      onmessageerror: !0,
      onnotificationclick: !0,
      onnotificationclose: !0,
      onoffline: !0,
      ononline: !0,
      onpush: !0,
      onpushsubscriptionchange: !0,
      onrejectionhandled: !0,
      onsync: !0,
      onunhandledrejection: !0,
      performance: !1,
      Performance: !1,
      PerformanceEntry: !1,
      PerformanceMark: !1,
      PerformanceMeasure: !1,
      PerformanceNavigation: !1,
      PerformanceResourceTiming: !1,
      PerformanceTiming: !1,
      postMessage: !0,
      Promise: !1,
      queueMicrotask: !1,
      registration: !1,
      removeEventListener: !1,
      Request: !1,
      Response: !1,
      self: !1,
      ServiceWorker: !1,
      ServiceWorkerContainer: !1,
      ServiceWorkerGlobalScope: !1,
      ServiceWorkerMessageEvent: !1,
      ServiceWorkerRegistration: !1,
      setInterval: !1,
      setTimeout: !1,
      skipWaiting: !1,
      TextDecoder: !1,
      TextEncoder: !1,
      URL: !1,
      URLSearchParams: !1,
      WebSocket: !1,
      WindowClient: !1,
      Worker: !1,
      WorkerGlobalScope: !1,
      XMLHttpRequest: !1,
    },
    atomtest: {
      advanceClock: !1,
      fakeClearInterval: !1,
      fakeClearTimeout: !1,
      fakeSetInterval: !1,
      fakeSetTimeout: !1,
      resetTimeouts: !1,
      waitsForPromise: !1,
    },
    embertest: {
      andThen: !1,
      click: !1,
      currentPath: !1,
      currentRouteName: !1,
      currentURL: !1,
      fillIn: !1,
      find: !1,
      findAll: !1,
      findWithAssert: !1,
      keyEvent: !1,
      pauseTest: !1,
      resumeTest: !1,
      triggerEvent: !1,
      visit: !1,
      wait: !1,
    },
    protractor: {
      $: !1,
      $$: !1,
      browser: !1,
      by: !1,
      By: !1,
      DartObject: !1,
      element: !1,
      protractor: !1,
    },
    "shared-node-browser": {
      clearInterval: !1,
      clearTimeout: !1,
      console: !1,
      setInterval: !1,
      setTimeout: !1,
      URL: !1,
      URLSearchParams: !1,
    },
    webextensions: { browser: !1, chrome: !1, opr: !1 },
    greasemonkey: {
      cloneInto: !1,
      createObjectIn: !1,
      exportFunction: !1,
      GM: !1,
      GM_addStyle: !1,
      GM_deleteValue: !1,
      GM_getResourceText: !1,
      GM_getResourceURL: !1,
      GM_getValue: !1,
      GM_info: !1,
      GM_listValues: !1,
      GM_log: !1,
      GM_openInTab: !1,
      GM_registerMenuCommand: !1,
      GM_setClipboard: !1,
      GM_setValue: !1,
      GM_xmlhttpRequest: !1,
      unsafeWindow: !1,
    },
    devtools: {
      $: !1,
      $_: !1,
      $$: !1,
      $0: !1,
      $1: !1,
      $2: !1,
      $3: !1,
      $4: !1,
      $x: !1,
      chrome: !1,
      clear: !1,
      copy: !1,
      debug: !1,
      dir: !1,
      dirxml: !1,
      getEventListeners: !1,
      inspect: !1,
      keys: !1,
      monitor: !1,
      monitorEvents: !1,
      profile: !1,
      profileEnd: !1,
      queryObjects: !1,
      table: !1,
      undebug: !1,
      unmonitor: !1,
      unmonitorEvents: !1,
      values: !1,
    },
  };
function fy(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return yy(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return yy(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function yy(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function my() {
  if (py) return Yf;
  (py = 1),
    Object.defineProperty(Yf, "__esModule", { value: !0 }),
    (Yf.default = void 0);
  var e = (function () {
      if (sy) return Jf;
      (sy = 1),
        Object.defineProperty(Jf, "__esModule", { value: !0 }),
        (Jf.default = void 0);
      var e = Xf,
        t = mc(),
        r = ry,
        n = zT(),
        i = Qd,
        a = {
          ReferencedIdentifier: function (e, t) {
            var r = e.node;
            r.name === t.oldName && (r.name = t.newName);
          },
          Scope: function (e, t) {
            e.scope.bindingIdentifierEquals(t.oldName, t.binding.identifier) ||
              (e.skip(),
              e.isMethod() && (0, r.requeueComputedKeyAndDecorators)(e));
          },
          "AssignmentExpression|Declaration|VariableDeclarator": function (
            e,
            t
          ) {
            if (!e.isVariableDeclaration()) {
              var r = e.getOuterBindingIdentifiers();
              for (var n in r) n === t.oldName && (r[n].name = t.newName);
            }
          },
        },
        s = (function () {
          function r(e, t, n) {
            E(this, r),
              (this.newName = n),
              (this.oldName = t),
              (this.binding = e);
          }
          return (
            A(r, [
              {
                key: "maybeConvertFromExportDeclaration",
                value: function (r) {
                  var n = r.parentPath;
                  if (n.isExportDeclaration()) {
                    if (n.isExportDefaultDeclaration()) {
                      var i = n.node.declaration;
                      if (t.isDeclaration(i) && !i.id) return;
                    }
                    n.isExportAllDeclaration() || (0, e.default)(n);
                  }
                },
              },
              {
                key: "maybeConvertFromClassFunctionDeclaration",
                value: function (e) {
                  return e;
                },
              },
              {
                key: "maybeConvertFromClassFunctionExpression",
                value: function (e) {
                  return e;
                },
              },
              {
                key: "rename",
                value: function () {
                  var e = this.binding,
                    t = this.oldName,
                    r = this.newName,
                    s = e.scope,
                    o = e.path,
                    l = o.find(function (e) {
                      return (
                        e.isDeclaration() ||
                        e.isFunctionExpression() ||
                        e.isClassExpression()
                      );
                    });
                  l &&
                    l.getOuterBindingIdentifiers()[t] === e.identifier &&
                    this.maybeConvertFromExportDeclaration(l);
                  var u = arguments[0] || s.block;
                  (0, n.traverseNode)(u, (0, i.explode)(a), s, this, s.path, {
                    discriminant: !0,
                  }),
                    arguments[0] ||
                      (s.removeOwnBinding(t),
                      (s.bindings[r] = e),
                      (this.binding.identifier.name = r)),
                    l &&
                      (this.maybeConvertFromClassFunctionDeclaration(o),
                      this.maybeConvertFromClassFunctionExpression(o));
                },
              },
            ]),
            r
          );
        })();
      return (Jf.default = s), Jf;
    })(),
    t = eS(),
    r = uy,
    n = hy.exports,
    i = mc(),
    a = bf,
    s = i.NOT_LOCAL_BINDING,
    o = i.callExpression,
    l = i.cloneNode,
    u = i.getBindingIdentifiers,
    c = i.identifier,
    p = i.isArrayExpression,
    h = i.isBinary,
    d = i.isClass,
    f = i.isClassBody,
    y = i.isClassDeclaration,
    m = i.isExportAllDeclaration,
    v = i.isExportDefaultDeclaration,
    g = i.isExportNamedDeclaration,
    b = i.isFunctionDeclaration,
    T = i.isIdentifier,
    S = i.isImportDeclaration,
    x = i.isLiteral,
    P = i.isMethod,
    k = i.isModuleSpecifier,
    w = i.isNullLiteral,
    C = i.isObjectExpression,
    I = i.isProperty,
    O = i.isPureish,
    N = i.isRegExpLiteral,
    _ = i.isSuper,
    D = i.isTaggedTemplateExpression,
    L = i.isTemplateLiteral,
    M = i.isThisExpression,
    j = i.isUnaryExpression,
    F = i.isVariableDeclaration,
    B = i.matchesPattern,
    R = i.memberExpression,
    U = i.numericLiteral,
    V = i.toIdentifier,
    K = i.unaryExpression,
    W = i.variableDeclaration,
    q = i.variableDeclarator,
    Y = i.isRecordExpression,
    J = i.isTupleExpression,
    X = i.isObjectProperty,
    G = i.isTopicReference,
    z = i.isMetaProperty,
    $ = i.isPrivateName,
    Q = i.isExportDeclaration;
  function Z(e, t) {
    switch (null == e ? void 0 : e.type) {
      default:
        if (S(e) || Q(e))
          if ((m(e) || g(e) || S(e)) && e.source) Z(e.source, t);
          else if ((g(e) || S(e)) && e.specifiers && e.specifiers.length) {
            var r,
              n = fy(e.specifiers);
            try {
              for (n.s(); !(r = n.n()).done; ) {
                Z(r.value, t);
              }
            } catch (e) {
              n.e(e);
            } finally {
              n.f();
            }
          } else (v(e) || g(e)) && e.declaration && Z(e.declaration, t);
        else
          k(e)
            ? Z(e.local, t)
            : !x(e) || w(e) || N(e) || L(e) || t.push(e.value);
        break;
      case "MemberExpression":
      case "OptionalMemberExpression":
      case "JSXMemberExpression":
        Z(e.object, t), Z(e.property, t);
        break;
      case "Identifier":
      case "JSXIdentifier":
        t.push(e.name);
        break;
      case "CallExpression":
      case "OptionalCallExpression":
      case "NewExpression":
        Z(e.callee, t);
        break;
      case "ObjectExpression":
      case "ObjectPattern":
        var i,
          a = fy(e.properties);
        try {
          for (a.s(); !(i = a.n()).done; ) {
            Z(i.value, t);
          }
        } catch (e) {
          a.e(e);
        } finally {
          a.f();
        }
        break;
      case "SpreadElement":
      case "RestElement":
      case "UnaryExpression":
      case "UpdateExpression":
        Z(e.argument, t);
        break;
      case "ObjectProperty":
      case "ObjectMethod":
      case "ClassProperty":
      case "ClassMethod":
      case "ClassPrivateProperty":
      case "ClassPrivateMethod":
        Z(e.key, t);
        break;
      case "ThisExpression":
        t.push("this");
        break;
      case "Super":
        t.push("super");
        break;
      case "Import":
        t.push("import");
        break;
      case "DoExpression":
        t.push("do");
        break;
      case "YieldExpression":
        t.push("yield"), Z(e.argument, t);
        break;
      case "AwaitExpression":
        t.push("await"), Z(e.argument, t);
        break;
      case "AssignmentExpression":
        Z(e.left, t);
        break;
      case "VariableDeclarator":
      case "FunctionExpression":
      case "FunctionDeclaration":
      case "ClassExpression":
      case "ClassDeclaration":
      case "PrivateName":
        Z(e.id, t);
        break;
      case "ParenthesizedExpression":
        Z(e.expression, t);
        break;
      case "MetaProperty":
        Z(e.meta, t), Z(e.property, t);
        break;
      case "JSXElement":
        Z(e.openingElement, t);
        break;
      case "JSXOpeningElement":
        Z(e.name, t);
        break;
      case "JSXFragment":
        Z(e.openingFragment, t);
        break;
      case "JSXOpeningFragment":
        t.push("Fragment");
        break;
      case "JSXNamespacedName":
        Z(e.namespace, t), Z(e.name, t);
    }
  }
  var ee = {
      ForStatement: function (e) {
        var t = e.get("init");
        if (t.isVar()) {
          var r = e.scope;
          (r.getFunctionParent() || r.getProgramParent()).registerBinding(
            "var",
            t
          );
        }
      },
      Declaration: function (e) {
        e.isBlockScoped() ||
          e.isImportDeclaration() ||
          e.isExportDeclaration() ||
          (
            e.scope.getFunctionParent() || e.scope.getProgramParent()
          ).registerDeclaration(e);
      },
      ImportDeclaration: function (e) {
        e.scope.getBlockParent().registerDeclaration(e);
      },
      ReferencedIdentifier: function (e, t) {
        t.references.push(e);
      },
      ForXStatement: function (e, t) {
        var r = e.get("left");
        if (r.isPattern() || r.isIdentifier()) t.constantViolations.push(e);
        else if (r.isVar()) {
          var n = e.scope;
          (n.getFunctionParent() || n.getProgramParent()).registerBinding(
            "var",
            r
          );
        }
      },
      ExportDeclaration: {
        exit: function (e) {
          var t = e.node,
            r = e.scope;
          if (!m(t)) {
            var n = t.declaration;
            if (y(n) || b(n)) {
              var i = n.id;
              if (!i) return;
              var a = r.getBinding(i.name);
              null == a || a.reference(e);
            } else if (F(n)) {
              var s,
                o = fy(n.declarations);
              try {
                for (o.s(); !(s = o.n()).done; )
                  for (
                    var l = s.value, c = 0, p = Object.keys(u(l));
                    c < p.length;
                    c++
                  ) {
                    var h = p[c],
                      d = r.getBinding(h);
                    null == d || d.reference(e);
                  }
              } catch (e) {
                o.e(e);
              } finally {
                o.f();
              }
            }
          }
        },
      },
      LabeledStatement: function (e) {
        e.scope.getBlockParent().registerDeclaration(e);
      },
      AssignmentExpression: function (e, t) {
        t.assignments.push(e);
      },
      UpdateExpression: function (e, t) {
        t.constantViolations.push(e);
      },
      UnaryExpression: function (e, t) {
        "delete" === e.node.operator && t.constantViolations.push(e);
      },
      BlockScoped: function (e) {
        var t = e.scope;
        if (
          (t.path === e && (t = t.parent),
          t.getBlockParent().registerDeclaration(e),
          e.isClassDeclaration() && e.node.id)
        ) {
          var r = e.node.id.name;
          e.scope.bindings[r] = e.scope.parent.getBinding(r);
        }
      },
      CatchClause: function (e) {
        e.scope.registerBinding("let", e);
      },
      Function: function (e) {
        var t,
          r = fy(e.get("params"));
        try {
          for (r.s(); !(t = r.n()).done; ) {
            var n = t.value;
            e.scope.registerBinding("param", n);
          }
        } catch (e) {
          r.e(e);
        } finally {
          r.f();
        }
        e.isFunctionExpression() &&
          e.has("id") &&
          !e.get("id").node[s] &&
          e.scope.registerBinding("local", e.get("id"), e);
      },
      ClassExpression: function (e) {
        e.has("id") &&
          !e.get("id").node[s] &&
          e.scope.registerBinding("local", e);
      },
    },
    te = 0,
    re = (function () {
      function n(e) {
        E(this, n),
          (this.uid = void 0),
          (this.path = void 0),
          (this.block = void 0),
          (this.labels = void 0),
          (this.inited = void 0),
          (this.bindings = void 0),
          (this.references = void 0),
          (this.globals = void 0),
          (this.uids = void 0),
          (this.data = void 0),
          (this.crawling = void 0);
        var t = e.node,
          r = a.scope.get(t);
        if ((null == r ? void 0 : r.path) === e) return r;
        a.scope.set(t, this),
          (this.uid = te++),
          (this.block = t),
          (this.path = e),
          (this.labels = new Map()),
          (this.inited = !1);
      }
      return (
        A(n, [
          {
            key: "parent",
            get: function () {
              var e,
                t,
                r = this.path;
              do {
                var n = "key" === r.key || "decorators" === r.listKey;
                (r = r.parentPath),
                  n && r.isMethod() && (r = r.parentPath),
                  r && r.isScope() && (t = r);
              } while (r && !t);
              return null == (e = t) ? void 0 : e.scope;
            },
          },
          {
            key: "parentBlock",
            get: function () {
              return this.path.parent;
            },
          },
          {
            key: "hub",
            get: function () {
              return this.path.hub;
            },
          },
          {
            key: "traverse",
            value: function (e, r, n) {
              (0, t.default)(e, r, this, n, this.path);
            },
          },
          {
            key: "generateDeclaredUidIdentifier",
            value: function (e) {
              var t = this.generateUidIdentifier(e);
              return this.push({ id: t }), l(t);
            },
          },
          {
            key: "generateUidIdentifier",
            value: function (e) {
              return c(this.generateUid(e));
            },
          },
          {
            key: "generateUid",
            value: function () {
              var e,
                t =
                  arguments.length > 0 && void 0 !== arguments[0]
                    ? arguments[0]
                    : "temp";
              t = V(t)
                .replace(/^_+/, "")
                .replace(/[0-9]+$/g, "");
              var r = 1;
              do {
                (e = this._generateUid(t, r)), r++;
              } while (
                this.hasLabel(e) ||
                this.hasBinding(e) ||
                this.hasGlobal(e) ||
                this.hasReference(e)
              );
              var n = this.getProgramParent();
              return (n.references[e] = !0), (n.uids[e] = !0), e;
            },
          },
          {
            key: "_generateUid",
            value: function (e, t) {
              var r = e;
              return t > 1 && (r += t), "_".concat(r);
            },
          },
          {
            key: "generateUidBasedOnNode",
            value: function (e, t) {
              var r = [];
              Z(e, r);
              var n = r.join("$");
              return (
                (n = n.replace(/^_/, "") || t || "ref"),
                this.generateUid(n.slice(0, 20))
              );
            },
          },
          {
            key: "generateUidIdentifierBasedOnNode",
            value: function (e, t) {
              return c(this.generateUidBasedOnNode(e, t));
            },
          },
          {
            key: "isStatic",
            value: function (e) {
              if (M(e) || _(e) || G(e)) return !0;
              if (T(e)) {
                var t = this.getBinding(e.name);
                return t ? t.constant : this.hasBinding(e.name);
              }
              return !1;
            },
          },
          {
            key: "maybeGenerateMemoised",
            value: function (e, t) {
              if (this.isStatic(e)) return null;
              var r = this.generateUidIdentifierBasedOnNode(e);
              return t ? r : (this.push({ id: r }), l(r));
            },
          },
          {
            key: "checkBlockScopedCollisions",
            value: function (e, t, r, n) {
              if (
                "param" !== t &&
                "local" !== e.kind &&
                ("let" === t ||
                  "let" === e.kind ||
                  "const" === e.kind ||
                  "module" === e.kind ||
                  ("param" === e.kind && "const" === t))
              )
                throw this.hub.buildError(
                  n,
                  'Duplicate declaration "'.concat(r, '"'),
                  TypeError
                );
            },
          },
          {
            key: "rename",
            value: function (t, r) {
              var n = this.getBinding(t);
              n &&
                (r || (r = this.generateUidIdentifier(t).name),
                new e.default(n, t, r).rename(arguments[2]));
            },
          },
          {
            key: "_renameFromMap",
            value: function (e, t, r, n) {
              e[t] && ((e[r] = n), (e[t] = null));
            },
          },
          {
            key: "dump",
            value: function () {
              var e = "-".repeat(60);
              console.log(e);
              var t = this;
              do {
                console.log("#", t.block.type);
                for (
                  var r = 0, n = Object.keys(t.bindings);
                  r < n.length;
                  r++
                ) {
                  var i = n[r],
                    a = t.bindings[i];
                  console.log(" -", i, {
                    constant: a.constant,
                    references: a.references,
                    violations: a.constantViolations.length,
                    kind: a.kind,
                  });
                }
              } while ((t = t.parent));
              console.log(e);
            },
          },
          {
            key: "toArray",
            value: function (e, t, r) {
              if (T(e)) {
                var n = this.getBinding(e.name);
                if (null != n && n.constant && n.path.isGenericType("Array"))
                  return e;
              }
              if (p(e)) return e;
              if (T(e, { name: "arguments" }))
                return o(
                  R(R(R(c("Array"), c("prototype")), c("slice")), c("call")),
                  [e]
                );
              var i,
                a = [e];
              return (
                !0 === t
                  ? (i = "toConsumableArray")
                  : "number" == typeof t
                  ? (a.push(U(t)), (i = "slicedToArray"))
                  : (i = "toArray"),
                r && (a.unshift(this.hub.addHelper(i)), (i = "maybeArrayLike")),
                o(this.hub.addHelper(i), a)
              );
            },
          },
          {
            key: "hasLabel",
            value: function (e) {
              return !!this.getLabel(e);
            },
          },
          {
            key: "getLabel",
            value: function (e) {
              return this.labels.get(e);
            },
          },
          {
            key: "registerLabel",
            value: function (e) {
              this.labels.set(e.node.label.name, e);
            },
          },
          {
            key: "registerDeclaration",
            value: function (e) {
              if (e.isLabeledStatement()) this.registerLabel(e);
              else if (e.isFunctionDeclaration())
                this.registerBinding("hoisted", e.get("id"), e);
              else if (e.isVariableDeclaration()) {
                var t,
                  r = e.get("declarations"),
                  n = e.node.kind,
                  i = fy(r);
                try {
                  for (i.s(); !(t = i.n()).done; ) {
                    var a = t.value;
                    this.registerBinding("using" === n ? "const" : n, a);
                  }
                } catch (e) {
                  i.e(e);
                } finally {
                  i.f();
                }
              } else if (e.isClassDeclaration()) {
                if (e.node.declare) return;
                this.registerBinding("let", e);
              } else if (e.isImportDeclaration()) {
                var s,
                  o =
                    "type" === e.node.importKind ||
                    "typeof" === e.node.importKind,
                  l = fy(e.get("specifiers"));
                try {
                  for (l.s(); !(s = l.n()).done; ) {
                    var u = s.value,
                      c =
                        o ||
                        (u.isImportSpecifier() &&
                          ("type" === u.node.importKind ||
                            "typeof" === u.node.importKind));
                    this.registerBinding(c ? "unknown" : "module", u);
                  }
                } catch (e) {
                  l.e(e);
                } finally {
                  l.f();
                }
              } else if (e.isExportDeclaration()) {
                var p = e.get("declaration");
                (p.isClassDeclaration() ||
                  p.isFunctionDeclaration() ||
                  p.isVariableDeclaration()) &&
                  this.registerDeclaration(p);
              } else this.registerBinding("unknown", e);
            },
          },
          {
            key: "buildUndefinedNode",
            value: function () {
              return K("void", U(0), !0);
            },
          },
          {
            key: "registerConstantViolation",
            value: function (e) {
              for (
                var t = e.getBindingIdentifiers(), r = 0, n = Object.keys(t);
                r < n.length;
                r++
              ) {
                var i = n[r],
                  a = this.getBinding(i);
                a && a.reassign(e);
              }
            },
          },
          {
            key: "registerBinding",
            value: function (e, t) {
              var n =
                arguments.length > 2 && void 0 !== arguments[2]
                  ? arguments[2]
                  : t;
              if (!e) throw new ReferenceError("no `kind`");
              if (t.isVariableDeclaration()) {
                var i,
                  a = fy(t.get("declarations"));
                try {
                  for (a.s(); !(i = a.n()).done; ) {
                    var s = i.value;
                    this.registerBinding(e, s);
                  }
                } catch (e) {
                  a.e(e);
                } finally {
                  a.f();
                }
              } else
                for (
                  var o = this.getProgramParent(),
                    l = t.getOuterBindingIdentifiers(!0),
                    u = 0,
                    c = Object.keys(l);
                  u < c.length;
                  u++
                ) {
                  var p = c[u];
                  o.references[p] = !0;
                  var h,
                    d = fy(l[p]);
                  try {
                    for (d.s(); !(h = d.n()).done; ) {
                      var f = h.value,
                        y = this.getOwnBinding(p);
                      if (y) {
                        if (y.identifier === f) continue;
                        this.checkBlockScopedCollisions(y, e, p, f);
                      }
                      y
                        ? this.registerConstantViolation(n)
                        : (this.bindings[p] = new r.default({
                            identifier: f,
                            scope: this,
                            path: n,
                            kind: e,
                          }));
                    }
                  } catch (e) {
                    d.e(e);
                  } finally {
                    d.f();
                  }
                }
            },
          },
          {
            key: "addGlobal",
            value: function (e) {
              this.globals[e.name] = e;
            },
          },
          {
            key: "hasUid",
            value: function (e) {
              var t = this;
              do {
                if (t.uids[e]) return !0;
              } while ((t = t.parent));
              return !1;
            },
          },
          {
            key: "hasGlobal",
            value: function (e) {
              var t = this;
              do {
                if (t.globals[e]) return !0;
              } while ((t = t.parent));
              return !1;
            },
          },
          {
            key: "hasReference",
            value: function (e) {
              return !!this.getProgramParent().references[e];
            },
          },
          {
            key: "isPure",
            value: function (e, t) {
              if (T(e)) {
                var r = this.getBinding(e.name);
                return !!r && (!t || r.constant);
              }
              if (M(e) || z(e) || G(e) || $(e)) return !0;
              var n, i, a;
              if (d(e))
                return (
                  !(e.superClass && !this.isPure(e.superClass, t)) &&
                  !((null == (n = e.decorators) ? void 0 : n.length) > 0) &&
                  this.isPure(e.body, t)
                );
              if (f(e)) {
                var s,
                  o = fy(e.body);
                try {
                  for (o.s(); !(s = o.n()).done; ) {
                    var l = s.value;
                    if (!this.isPure(l, t)) return !1;
                  }
                } catch (e) {
                  o.e(e);
                } finally {
                  o.f();
                }
                return !0;
              }
              if (h(e))
                return this.isPure(e.left, t) && this.isPure(e.right, t);
              if (p(e) || J(e)) {
                var u,
                  c = fy(e.elements);
                try {
                  for (c.s(); !(u = c.n()).done; ) {
                    var y = u.value;
                    if (null !== y && !this.isPure(y, t)) return !1;
                  }
                } catch (e) {
                  c.e(e);
                } finally {
                  c.f();
                }
                return !0;
              }
              if (C(e) || Y(e)) {
                var m,
                  v = fy(e.properties);
                try {
                  for (v.s(); !(m = v.n()).done; ) {
                    var g = m.value;
                    if (!this.isPure(g, t)) return !1;
                  }
                } catch (e) {
                  v.e(e);
                } finally {
                  v.f();
                }
                return !0;
              }
              if (P(e))
                return (
                  !(e.computed && !this.isPure(e.key, t)) &&
                  !((null == (i = e.decorators) ? void 0 : i.length) > 0)
                );
              if (I(e))
                return (
                  !(e.computed && !this.isPure(e.key, t)) &&
                  !((null == (a = e.decorators) ? void 0 : a.length) > 0) &&
                  !(
                    (X(e) || e.static) &&
                    null !== e.value &&
                    !this.isPure(e.value, t)
                  )
                );
              if (j(e)) return this.isPure(e.argument, t);
              if (D(e))
                return (
                  B(e.tag, "String.raw") &&
                  !this.hasBinding("String", !0) &&
                  this.isPure(e.quasi, t)
                );
              if (L(e)) {
                var b,
                  S = fy(e.expressions);
                try {
                  for (S.s(); !(b = S.n()).done; ) {
                    var x = b.value;
                    if (!this.isPure(x, t)) return !1;
                  }
                } catch (e) {
                  S.e(e);
                } finally {
                  S.f();
                }
                return !0;
              }
              return O(e);
            },
          },
          {
            key: "setData",
            value: function (e, t) {
              return (this.data[e] = t);
            },
          },
          {
            key: "getData",
            value: function (e) {
              var t = this;
              do {
                var r = t.data[e];
                if (null != r) return r;
              } while ((t = t.parent));
            },
          },
          {
            key: "removeData",
            value: function (e) {
              var t = this;
              do {
                null != t.data[e] && (t.data[e] = null);
              } while ((t = t.parent));
            },
          },
          {
            key: "init",
            value: function () {
              this.inited || ((this.inited = !0), this.crawl());
            },
          },
          {
            key: "crawl",
            value: function () {
              var e = this.path;
              (this.references = Object.create(null)),
                (this.bindings = Object.create(null)),
                (this.globals = Object.create(null)),
                (this.uids = Object.create(null)),
                (this.data = Object.create(null));
              var t = this.getProgramParent();
              if (!t.crawling) {
                var r = {
                  references: [],
                  constantViolations: [],
                  assignments: [],
                };
                if (
                  ((this.crawling = !0), "Program" !== e.type && ee._exploded)
                ) {
                  var n,
                    i = fy(ee.enter);
                  try {
                    for (i.s(); !(n = i.n()).done; ) {
                      (0, n.value)(e, r);
                    }
                  } catch (e) {
                    i.e(e);
                  } finally {
                    i.f();
                  }
                  var a = ee[e.type];
                  if (a) {
                    var s,
                      o = fy(a.enter);
                    try {
                      for (o.s(); !(s = o.n()).done; ) {
                        (0, s.value)(e, r);
                      }
                    } catch (e) {
                      o.e(e);
                    } finally {
                      o.f();
                    }
                  }
                }
                e.traverse(ee, r), (this.crawling = !1);
                var l,
                  u = fy(r.assignments);
                try {
                  for (u.s(); !(l = u.n()).done; ) {
                    for (
                      var c = l.value,
                        p = c.getBindingIdentifiers(),
                        h = 0,
                        d = Object.keys(p);
                      h < d.length;
                      h++
                    ) {
                      var f = d[h];
                      c.scope.getBinding(f) || t.addGlobal(p[f]);
                    }
                    c.scope.registerConstantViolation(c);
                  }
                } catch (e) {
                  u.e(e);
                } finally {
                  u.f();
                }
                var y,
                  m = fy(r.references);
                try {
                  for (m.s(); !(y = m.n()).done; ) {
                    var v = y.value,
                      g = v.scope.getBinding(v.node.name);
                    g ? g.reference(v) : t.addGlobal(v.node);
                  }
                } catch (e) {
                  m.e(e);
                } finally {
                  m.f();
                }
                var b,
                  T = fy(r.constantViolations);
                try {
                  for (T.s(); !(b = T.n()).done; ) {
                    var S = b.value;
                    S.scope.registerConstantViolation(S);
                  }
                } catch (e) {
                  T.e(e);
                } finally {
                  T.f();
                }
              }
            },
          },
          {
            key: "push",
            value: function (e) {
              var t = this.path;
              t.isPattern()
                ? (t = this.getPatternParent().path)
                : t.isBlockStatement() ||
                  t.isProgram() ||
                  (t = this.getBlockParent().path),
                t.isSwitchStatement() &&
                  (t = (this.getFunctionParent() || this.getProgramParent())
                    .path),
                (t.isLoop() || t.isCatchClause() || t.isFunction()) &&
                  (t.ensureBlock(), (t = t.get("body")));
              var r = e.unique,
                n = e.kind || "var",
                i = null == e._blockHoist ? 2 : e._blockHoist,
                a = "declaration:".concat(n, ":").concat(i),
                s = !r && t.getData(a);
              if (!s) {
                var o = W(n, []);
                (o._blockHoist = i),
                  (s = H(t.unshiftContainer("body", [o]), 1)[0]),
                  r || t.setData(a, s);
              }
              var l = q(e.id, e.init),
                u = s.node.declarations.push(l);
              t.scope.registerBinding(n, s.get("declarations")[u - 1]);
            },
          },
          {
            key: "getProgramParent",
            value: function () {
              var e = this;
              do {
                if (e.path.isProgram()) return e;
              } while ((e = e.parent));
              throw new Error("Couldn't find a Program");
            },
          },
          {
            key: "getFunctionParent",
            value: function () {
              var e = this;
              do {
                if (e.path.isFunctionParent()) return e;
              } while ((e = e.parent));
              return null;
            },
          },
          {
            key: "getBlockParent",
            value: function () {
              var e = this;
              do {
                if (e.path.isBlockParent()) return e;
              } while ((e = e.parent));
              throw new Error(
                "We couldn't find a BlockStatement, For, Switch, Function, Loop or Program..."
              );
            },
          },
          {
            key: "getPatternParent",
            value: function () {
              var e = this;
              do {
                if (!e.path.isPattern()) return e.getBlockParent();
              } while ((e = e.parent.parent));
              throw new Error(
                "We couldn't find a BlockStatement, For, Switch, Function, Loop or Program..."
              );
            },
          },
          {
            key: "getAllBindings",
            value: function () {
              var e = Object.create(null),
                t = this;
              do {
                for (
                  var r = 0, n = Object.keys(t.bindings);
                  r < n.length;
                  r++
                ) {
                  var i = n[r];
                  i in e == !1 && (e[i] = t.bindings[i]);
                }
                t = t.parent;
              } while (t);
              return e;
            },
          },
          {
            key: "getAllBindingsOfKind",
            value: function () {
              for (
                var e = Object.create(null),
                  t = arguments.length,
                  r = new Array(t),
                  n = 0;
                n < t;
                n++
              )
                r[n] = arguments[n];
              for (var i = 0, a = r; i < a.length; i++) {
                var s = a[i],
                  o = this;
                do {
                  for (
                    var l = 0, u = Object.keys(o.bindings);
                    l < u.length;
                    l++
                  ) {
                    var c = u[l],
                      p = o.bindings[c];
                    p.kind === s && (e[c] = p);
                  }
                  o = o.parent;
                } while (o);
              }
              return e;
            },
          },
          {
            key: "bindingIdentifierEquals",
            value: function (e, t) {
              return this.getBindingIdentifier(e) === t;
            },
          },
          {
            key: "getBinding",
            value: function (e) {
              var t,
                r = this;
              do {
                var n,
                  i = r.getOwnBinding(e);
                if (i) {
                  if (
                    null == (n = t) ||
                    !n.isPattern() ||
                    "param" === i.kind ||
                    "local" === i.kind
                  )
                    return i;
                } else if (
                  !i &&
                  "arguments" === e &&
                  r.path.isFunction() &&
                  !r.path.isArrowFunctionExpression()
                )
                  break;
                t = r.path;
              } while ((r = r.parent));
            },
          },
          {
            key: "getOwnBinding",
            value: function (e) {
              return this.bindings[e];
            },
          },
          {
            key: "getBindingIdentifier",
            value: function (e) {
              var t;
              return null == (t = this.getBinding(e)) ? void 0 : t.identifier;
            },
          },
          {
            key: "getOwnBindingIdentifier",
            value: function (e) {
              var t = this.bindings[e];
              return null == t ? void 0 : t.identifier;
            },
          },
          {
            key: "hasOwnBinding",
            value: function (e) {
              return !!this.getOwnBinding(e);
            },
          },
          {
            key: "hasBinding",
            value: function (e, t) {
              var r, i, a;
              return (
                !!e &&
                (!!this.hasOwnBinding(e) ||
                  ("boolean" == typeof t && (t = { noGlobals: t }),
                  !!this.parentHasBinding(e, t) ||
                    !((null != (r = t) && r.noUids) || !this.hasUid(e)) ||
                    !(
                      (null != (i = t) && i.noGlobals) ||
                      !n.globals.includes(e)
                    ) ||
                    !(
                      (null != (a = t) && a.noGlobals) ||
                      !n.contextVariables.includes(e)
                    )))
              );
            },
          },
          {
            key: "parentHasBinding",
            value: function (e, t) {
              var r;
              return null == (r = this.parent) ? void 0 : r.hasBinding(e, t);
            },
          },
          {
            key: "moveBindingTo",
            value: function (e, t) {
              var r = this.getBinding(e);
              r &&
                (r.scope.removeOwnBinding(e),
                (r.scope = t),
                (t.bindings[e] = r));
            },
          },
          {
            key: "removeOwnBinding",
            value: function (e) {
              delete this.bindings[e];
            },
          },
          {
            key: "removeBinding",
            value: function (e) {
              var t;
              null == (t = this.getBinding(e)) || t.scope.removeOwnBinding(e);
              var r = this;
              do {
                r.uids[e] && (r.uids[e] = !1);
              } while ((r = r.parent));
            },
          },
        ]),
        n
      );
    })();
  return (
    (Yf.default = re),
    (re.globals = Object.keys(n.builtin)),
    (re.contextVariables = ["arguments", "undefined", "Infinity", "NaN"]),
    Yf
  );
}
hy.exports = dy;
var vy = {};
function gy(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return by(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return by(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function by(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(vy, "__esModule", { value: !0 }),
  (vy.find = function (e) {
    var t = this;
    do {
      if (e(t)) return t;
    } while ((t = t.parentPath));
    return null;
  }),
  (vy.findParent = function (e) {
    var t = this;
    for (; (t = t.parentPath); ) if (e(t)) return t;
    return null;
  }),
  (vy.getAncestry = function () {
    var e = this,
      t = [];
    do {
      t.push(e);
    } while ((e = e.parentPath));
    return t;
  }),
  (vy.getDeepestCommonAncestorFrom = function (e, t) {
    var r = this;
    if (!e.length) return this;
    if (1 === e.length) return e[0];
    var n,
      i,
      a = 1 / 0,
      s = e.map(function (e) {
        var t = [];
        do {
          t.unshift(e);
        } while ((e = e.parentPath) && e !== r);
        return t.length < a && (a = t.length), t;
      }),
      o = s[0];
    e: for (var l = 0; l < a; l++) {
      var u,
        c = o[l],
        p = gy(s);
      try {
        for (p.s(); !(u = p.n()).done; ) {
          if (u.value[l] !== c) break e;
        }
      } catch (e) {
        p.e(e);
      } finally {
        p.f();
      }
      (n = l), (i = c);
    }
    if (i) return t ? t(i, n, s) : i;
    throw new Error("Couldn't find intersection");
  }),
  (vy.getEarliestCommonAncestorFrom = function (e) {
    return this.getDeepestCommonAncestorFrom(e, function (e, t, r) {
      var n,
        i,
        a = Ty[e.type],
        s = gy(r);
      try {
        for (s.s(); !(i = s.n()).done; ) {
          var o = i.value[t + 1];
          if (n)
            if (o.listKey && n.listKey === o.listKey && o.key < n.key) n = o;
            else a.indexOf(n.parentKey) > a.indexOf(o.parentKey) && (n = o);
          else n = o;
        }
      } catch (e) {
        s.e(e);
      } finally {
        s.f();
      }
      return n;
    });
  }),
  (vy.getFunctionParent = function () {
    return this.findParent(function (e) {
      return e.isFunction();
    });
  }),
  (vy.getStatementParent = function () {
    var e = this;
    do {
      if (!e.parentPath || (Array.isArray(e.container) && e.isStatement()))
        break;
      e = e.parentPath;
    } while (e);
    if (e && (e.isProgram() || e.isFile()))
      throw new Error(
        "File/Program node, we can't possibly find a statement parent to this"
      );
    return e;
  }),
  (vy.inType = function () {
    for (
      var e = this, t = arguments.length, r = new Array(t), n = 0;
      n < t;
      n++
    )
      r[n] = arguments[n];
    for (; e; ) {
      var i,
        a = gy(r);
      try {
        for (a.s(); !(i = a.n()).done; ) {
          var s = i.value;
          if (e.node.type === s) return !0;
        }
      } catch (e) {
        a.e(e);
      } finally {
        a.f();
      }
      e = e.parentPath;
    }
    return !1;
  }),
  (vy.isAncestor = function (e) {
    return e.isDescendant(this);
  }),
  (vy.isDescendant = function (e) {
    return !!this.findParent(function (t) {
      return t === e;
    });
  });
var Ty = mc().VISITOR_KEYS;
var Sy,
  xy,
  Ey,
  Py,
  Ay = {},
  ky = {},
  wy = {},
  Cy = {};
function Iy() {
  if (Sy) return Cy;
  (Sy = 1),
    Object.defineProperty(Cy, "__esModule", { value: !0 }),
    (Cy.createUnionType = function (e) {
      if (i(e[0])) return t ? t(e) : n(e);
      if (r) return r(e);
    });
  var e = mc(),
    t = e.createFlowUnionType,
    r = e.createTSUnionType,
    n = e.createUnionTypeAnnotation,
    i = e.isFlowType;
  return e.isTSType, Cy;
}
function Oy(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Ny(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Ny(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Ny(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function _y() {
  if (xy) return wy;
  (xy = 1),
    Object.defineProperty(wy, "__esModule", { value: !0 }),
    (wy.default = function (e) {
      if (!this.isReferenced()) return;
      var r = this.scope.getBinding(e.name);
      if (r)
        return r.identifier.typeAnnotation
          ? r.identifier.typeAnnotation
          : (function (e, r, n) {
              var i = [],
                a = [],
                o = s(e, r, a),
                u = l(e, r, n);
              if (u) {
                var c = s(e, u.ifStatement);
                (o = o.filter(function (e) {
                  return c.indexOf(e) < 0;
                })),
                  i.push(u.typeAnnotation);
              }
              if (o.length) {
                var p;
                (p = o).push.apply(p, a);
                var h,
                  d = Oy(o);
                try {
                  for (d.s(); !(h = d.n()).done; ) {
                    var f = h.value;
                    i.push(f.getTypeAnnotation());
                  }
                } catch (e) {
                  d.e(e);
                } finally {
                  d.f();
                }
              }
              if (!i.length) return;
              return (0, t.createUnionType)(i);
            })(r, this, e.name);
      if ("undefined" === e.name) return a();
      if ("NaN" === e.name || "Infinity" === e.name) return i();
      e.name;
    });
  var e = mc(),
    t = Iy(),
    r = e.BOOLEAN_NUMBER_BINARY_OPERATORS,
    n = e.createTypeAnnotationBasedOnTypeof,
    i = e.numberTypeAnnotation,
    a = e.voidTypeAnnotation;
  function s(e, t, r) {
    var n = e.constantViolations.slice();
    return (
      n.unshift(e.path),
      n.filter(function (e) {
        var n = (e = e.resolve())._guessExecutionStatusRelativeTo(t);
        return r && "unknown" === n && r.push(e), "before" === n;
      })
    );
  }
  function o(e, t) {
    var a,
      s,
      o,
      l = t.node.operator,
      u = t.get("right").resolve(),
      c = t.get("left").resolve();
    if (
      (c.isIdentifier({ name: e })
        ? (a = u)
        : u.isIdentifier({ name: e }) && (a = c),
      a)
    )
      return "===" === l
        ? a.getTypeAnnotation()
        : r.indexOf(l) >= 0
        ? i()
        : void 0;
    if (
      ("===" === l || "==" === l) &&
      (c.isUnaryExpression({ operator: "typeof" })
        ? ((s = c), (o = u))
        : u.isUnaryExpression({ operator: "typeof" }) && ((s = u), (o = c)),
      s &&
        s.get("argument").isIdentifier({ name: e }) &&
        (o = o.resolve()).isLiteral())
    ) {
      var p = o.node.value;
      if ("string" == typeof p) return n(p);
    }
  }
  function l(e, r, n) {
    var i = (function (e, t, r) {
      for (var n; (n = t.parentPath); ) {
        if (n.isIfStatement() || n.isConditionalExpression()) {
          if ("test" === t.key) return;
          return n;
        }
        if (n.isFunction() && n.parentPath.scope.getBinding(r) !== e) return;
        t = n;
      }
    })(e, r, n);
    if (i) {
      for (var a = [i.get("test")], s = [], u = 0; u < a.length; u++) {
        var c = a[u];
        if (c.isLogicalExpression())
          "&&" === c.node.operator &&
            (a.push(c.get("left")), a.push(c.get("right")));
        else if (c.isBinaryExpression()) {
          var p = o(n, c);
          p && s.push(p);
        }
      }
      return s.length
        ? { typeAnnotation: (0, t.createUnionType)(s), ifStatement: i }
        : l(e, i, n);
    }
  }
  return wy;
}
function Dy() {
  return (
    Ey ||
      ((Ey = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          (e.ArrayExpression = P),
          (e.AssignmentExpression = function () {
            return this.get("right").getTypeAnnotation();
          }),
          (e.BinaryExpression = function (e) {
            var t = e.operator;
            if (s.indexOf(t) >= 0) return m();
            if (i.indexOf(t) >= 0) return p();
            if ("+" === t) {
              var r = this.get("right"),
                n = this.get("left");
              return n.isBaseType("number") && r.isBaseType("number")
                ? m()
                : n.isBaseType("string") || r.isBaseType("string")
                ? v()
                : b([v(), m()]);
            }
          }),
          (e.BooleanLiteral = function () {
            return p();
          }),
          (e.CallExpression = function () {
            var e = this.node.callee;
            if (w(e)) return c(v());
            if (k(e) || C(e) || S(e, { name: "Array" })) return c(u());
            if (I(e)) return c(g([v(), u()]));
            return O(this.get("callee"));
          }),
          (e.ConditionalExpression = function () {
            var e = [
              this.get("consequent").getTypeAnnotation(),
              this.get("alternate").getTypeAnnotation(),
            ];
            return (0, n.createUnionType)(e);
          }),
          (e.ClassDeclaration =
            e.ClassExpression =
            e.FunctionDeclaration =
            e.ArrowFunctionExpression =
            e.FunctionExpression =
              function () {
                return d(f("Function"));
              }),
          Object.defineProperty(e, "Identifier", {
            enumerable: !0,
            get: function () {
              return r.default;
            },
          }),
          (e.LogicalExpression = function () {
            var e = [
              this.get("left").getTypeAnnotation(),
              this.get("right").getTypeAnnotation(),
            ];
            return (0, n.createUnionType)(e);
          }),
          (e.NewExpression = function (e) {
            if ("Identifier" === e.callee.type) return d(e.callee);
          }),
          (e.NullLiteral = function () {
            return y();
          }),
          (e.NumericLiteral = function () {
            return m();
          }),
          (e.ObjectExpression = function () {
            return d(f("Object"));
          }),
          (e.ParenthesizedExpression = function () {
            return this.get("expression").getTypeAnnotation();
          }),
          (e.RegExpLiteral = function () {
            return d(f("RegExp"));
          }),
          (e.RestElement = A),
          (e.SequenceExpression = function () {
            return this.get("expressions").pop().getTypeAnnotation();
          }),
          (e.StringLiteral = function () {
            return v();
          }),
          (e.TSAsExpression = E),
          (e.TSNonNullExpression = function () {
            return this.get("expression").getTypeAnnotation();
          }),
          (e.TaggedTemplateExpression = function () {
            return O(this.get("tag"));
          }),
          (e.TemplateLiteral = function () {
            return v();
          }),
          (e.TypeCastExpression = x),
          (e.UnaryExpression = function (e) {
            var t = e.operator;
            if ("void" === t) return T();
            if (o.indexOf(t) >= 0) return m();
            if (l.indexOf(t) >= 0) return v();
            if (a.indexOf(t) >= 0) return p();
          }),
          (e.UpdateExpression = function (e) {
            var t = e.operator;
            if ("++" === t || "--" === t) return m();
          }),
          (e.VariableDeclarator = function () {
            if (!this.get("id").isIdentifier()) return;
            return this.get("init").getTypeAnnotation();
          });
        var t = mc(),
          r = _y(),
          n = Iy(),
          i = t.BOOLEAN_BINARY_OPERATORS,
          a = t.BOOLEAN_UNARY_OPERATORS,
          s = t.NUMBER_BINARY_OPERATORS,
          o = t.NUMBER_UNARY_OPERATORS,
          l = t.STRING_UNARY_OPERATORS,
          u = t.anyTypeAnnotation,
          c = t.arrayTypeAnnotation,
          p = t.booleanTypeAnnotation,
          h = t.buildMatchMemberExpression,
          d = t.genericTypeAnnotation,
          f = t.identifier,
          y = t.nullLiteralTypeAnnotation,
          m = t.numberTypeAnnotation,
          v = t.stringTypeAnnotation,
          g = t.tupleTypeAnnotation,
          b = t.unionTypeAnnotation,
          T = t.voidTypeAnnotation,
          S = t.isIdentifier;
        function x(e) {
          return e.typeAnnotation;
        }
        function E(e) {
          return e.typeAnnotation;
        }
        function P() {
          return d(f("Array"));
        }
        function A() {
          return P();
        }
        (x.validParent = !0), (E.validParent = !0), (A.validParent = !0);
        var k = h("Array.from"),
          w = h("Object.keys"),
          C = h("Object.values"),
          I = h("Object.entries");
        function O(e) {
          if ((e = e.resolve()).isFunction()) {
            var t = e.node;
            if (t.async)
              return t.generator ? d(f("AsyncIterator")) : d(f("Promise"));
            if (t.generator) return d(f("Iterator"));
            if (e.node.returnType) return e.node.returnType;
          }
        }
      })(ky)),
    ky
  );
}
function Ly(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return My(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return My(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function My(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
var jy = {},
  Fy = {},
  By = {},
  Ry = {};
Object.defineProperty(Ry, "__esModule", { value: !0 }),
  (Ry.default =
    /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g),
  (Ry.matchToToken = function (e) {
    var t = { type: "invalid", value: e[0], closed: void 0 };
    return (
      e[1]
        ? ((t.type = "string"), (t.closed = !(!e[3] && !e[4])))
        : e[5]
        ? (t.type = "comment")
        : e[6]
        ? ((t.type = "comment"), (t.closed = !!e[7]))
        : e[8]
        ? (t.type = "regex")
        : e[9]
        ? (t.type = "number")
        : e[10]
        ? (t.type = "name")
        : e[11]
        ? (t.type = "punctuator")
        : e[12] && (t.type = "whitespace"),
      t
    );
  });
var Uy = { exports: {} },
  Vy = /[|\\{}()[\]^$+*?.]/g,
  Ky = function (e) {
    if ("string" != typeof e) throw new TypeError("Expected a string");
    return e.replace(Vy, "\\$&");
  },
  Wy = { exports: {} },
  qy = { exports: {} },
  Hy = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  },
  Yy = {};
for (var Jy in Hy) Hy.hasOwnProperty(Jy) && (Yy[Hy[Jy]] = Jy);
var Xy = (qy.exports = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] },
});
for (var Gy in Xy)
  if (Xy.hasOwnProperty(Gy)) {
    if (!("channels" in Xy[Gy]))
      throw new Error("missing channels property: " + Gy);
    if (!("labels" in Xy[Gy]))
      throw new Error("missing channel labels property: " + Gy);
    if (Xy[Gy].labels.length !== Xy[Gy].channels)
      throw new Error("channel and label counts mismatch: " + Gy);
    var zy = Xy[Gy].channels,
      $y = Xy[Gy].labels;
    delete Xy[Gy].channels,
      delete Xy[Gy].labels,
      Object.defineProperty(Xy[Gy], "channels", { value: zy }),
      Object.defineProperty(Xy[Gy], "labels", { value: $y });
  }
(Xy.rgb.hsl = function (e) {
  var t,
    r,
    n = e[0] / 255,
    i = e[1] / 255,
    a = e[2] / 255,
    s = Math.min(n, i, a),
    o = Math.max(n, i, a),
    l = o - s;
  return (
    o === s
      ? (t = 0)
      : n === o
      ? (t = (i - a) / l)
      : i === o
      ? (t = 2 + (a - n) / l)
      : a === o && (t = 4 + (n - i) / l),
    (t = Math.min(60 * t, 360)) < 0 && (t += 360),
    (r = (s + o) / 2),
    [t, 100 * (o === s ? 0 : r <= 0.5 ? l / (o + s) : l / (2 - o - s)), 100 * r]
  );
}),
  (Xy.rgb.hsv = function (e) {
    var t,
      r,
      n,
      i,
      a,
      s = e[0] / 255,
      o = e[1] / 255,
      l = e[2] / 255,
      u = Math.max(s, o, l),
      c = u - Math.min(s, o, l),
      p = function (e) {
        return (u - e) / 6 / c + 0.5;
      };
    return (
      0 === c
        ? (i = a = 0)
        : ((a = c / u),
          (t = p(s)),
          (r = p(o)),
          (n = p(l)),
          s === u
            ? (i = n - r)
            : o === u
            ? (i = 1 / 3 + t - n)
            : l === u && (i = 2 / 3 + r - t),
          i < 0 ? (i += 1) : i > 1 && (i -= 1)),
      [360 * i, 100 * a, 100 * u]
    );
  }),
  (Xy.rgb.hwb = function (e) {
    var t = e[0],
      r = e[1],
      n = e[2];
    return [
      Xy.rgb.hsl(e)[0],
      100 * ((1 / 255) * Math.min(t, Math.min(r, n))),
      100 * (n = 1 - (1 / 255) * Math.max(t, Math.max(r, n))),
    ];
  }),
  (Xy.rgb.cmyk = function (e) {
    var t,
      r = e[0] / 255,
      n = e[1] / 255,
      i = e[2] / 255;
    return [
      100 * ((1 - r - (t = Math.min(1 - r, 1 - n, 1 - i))) / (1 - t) || 0),
      100 * ((1 - n - t) / (1 - t) || 0),
      100 * ((1 - i - t) / (1 - t) || 0),
      100 * t,
    ];
  }),
  (Xy.rgb.keyword = function (e) {
    var t = Yy[e];
    if (t) return t;
    var r,
      n,
      i,
      a = 1 / 0;
    for (var s in Hy)
      if (Hy.hasOwnProperty(s)) {
        var o = Hy[s],
          l =
            ((n = e),
            (i = o),
            Math.pow(n[0] - i[0], 2) +
              Math.pow(n[1] - i[1], 2) +
              Math.pow(n[2] - i[2], 2));
        l < a && ((a = l), (r = s));
      }
    return r;
  }),
  (Xy.keyword.rgb = function (e) {
    return Hy[e];
  }),
  (Xy.rgb.xyz = function (e) {
    var t = e[0] / 255,
      r = e[1] / 255,
      n = e[2] / 255;
    return [
      100 *
        (0.4124 *
          (t = t > 0.04045 ? Math.pow((t + 0.055) / 1.055, 2.4) : t / 12.92) +
          0.3576 *
            (r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92) +
          0.1805 *
            (n = n > 0.04045 ? Math.pow((n + 0.055) / 1.055, 2.4) : n / 12.92)),
      100 * (0.2126 * t + 0.7152 * r + 0.0722 * n),
      100 * (0.0193 * t + 0.1192 * r + 0.9505 * n),
    ];
  }),
  (Xy.rgb.lab = function (e) {
    var t = Xy.rgb.xyz(e),
      r = t[0],
      n = t[1],
      i = t[2];
    return (
      (n /= 100),
      (i /= 108.883),
      (r =
        (r /= 95.047) > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116),
      [
        116 * (n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116) -
          16,
        500 * (r - n),
        200 *
          (n - (i = i > 0.008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116)),
      ]
    );
  }),
  (Xy.hsl.rgb = function (e) {
    var t,
      r,
      n,
      i,
      a,
      s = e[0] / 360,
      o = e[1] / 100,
      l = e[2] / 100;
    if (0 === o) return [(a = 255 * l), a, a];
    (t = 2 * l - (r = l < 0.5 ? l * (1 + o) : l + o - l * o)), (i = [0, 0, 0]);
    for (var u = 0; u < 3; u++)
      (n = s + (1 / 3) * -(u - 1)) < 0 && n++,
        n > 1 && n--,
        (a =
          6 * n < 1
            ? t + 6 * (r - t) * n
            : 2 * n < 1
            ? r
            : 3 * n < 2
            ? t + (r - t) * (2 / 3 - n) * 6
            : t),
        (i[u] = 255 * a);
    return i;
  }),
  (Xy.hsl.hsv = function (e) {
    var t = e[0],
      r = e[1] / 100,
      n = e[2] / 100,
      i = r,
      a = Math.max(n, 0.01);
    return (
      (r *= (n *= 2) <= 1 ? n : 2 - n),
      (i *= a <= 1 ? a : 2 - a),
      [
        t,
        100 * (0 === n ? (2 * i) / (a + i) : (2 * r) / (n + r)),
        100 * ((n + r) / 2),
      ]
    );
  }),
  (Xy.hsv.rgb = function (e) {
    var t = e[0] / 60,
      r = e[1] / 100,
      n = e[2] / 100,
      i = Math.floor(t) % 6,
      a = t - Math.floor(t),
      s = 255 * n * (1 - r),
      o = 255 * n * (1 - r * a),
      l = 255 * n * (1 - r * (1 - a));
    switch (((n *= 255), i)) {
      case 0:
        return [n, l, s];
      case 1:
        return [o, n, s];
      case 2:
        return [s, n, l];
      case 3:
        return [s, o, n];
      case 4:
        return [l, s, n];
      case 5:
        return [n, s, o];
    }
  }),
  (Xy.hsv.hsl = function (e) {
    var t,
      r,
      n,
      i = e[0],
      a = e[1] / 100,
      s = e[2] / 100,
      o = Math.max(s, 0.01);
    return (
      (n = (2 - a) * s),
      (r = a * o),
      [
        i,
        100 * (r = (r /= (t = (2 - a) * o) <= 1 ? t : 2 - t) || 0),
        100 * (n /= 2),
      ]
    );
  }),
  (Xy.hwb.rgb = function (e) {
    var t,
      r,
      n,
      i,
      a,
      s,
      o,
      l = e[0] / 360,
      u = e[1] / 100,
      c = e[2] / 100,
      p = u + c;
    switch (
      (p > 1 && ((u /= p), (c /= p)),
      (n = 6 * l - (t = Math.floor(6 * l))),
      0 != (1 & t) && (n = 1 - n),
      (i = u + n * ((r = 1 - c) - u)),
      t)
    ) {
      default:
      case 6:
      case 0:
        (a = r), (s = i), (o = u);
        break;
      case 1:
        (a = i), (s = r), (o = u);
        break;
      case 2:
        (a = u), (s = r), (o = i);
        break;
      case 3:
        (a = u), (s = i), (o = r);
        break;
      case 4:
        (a = i), (s = u), (o = r);
        break;
      case 5:
        (a = r), (s = u), (o = i);
    }
    return [255 * a, 255 * s, 255 * o];
  }),
  (Xy.cmyk.rgb = function (e) {
    var t = e[0] / 100,
      r = e[1] / 100,
      n = e[2] / 100,
      i = e[3] / 100;
    return [
      255 * (1 - Math.min(1, t * (1 - i) + i)),
      255 * (1 - Math.min(1, r * (1 - i) + i)),
      255 * (1 - Math.min(1, n * (1 - i) + i)),
    ];
  }),
  (Xy.xyz.rgb = function (e) {
    var t,
      r,
      n,
      i = e[0] / 100,
      a = e[1] / 100,
      s = e[2] / 100;
    return (
      (r = -0.9689 * i + 1.8758 * a + 0.0415 * s),
      (n = 0.0557 * i + -0.204 * a + 1.057 * s),
      (t =
        (t = 3.2406 * i + -1.5372 * a + -0.4986 * s) > 0.0031308
          ? 1.055 * Math.pow(t, 1 / 2.4) - 0.055
          : 12.92 * t),
      (r = r > 0.0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : 12.92 * r),
      (n = n > 0.0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - 0.055 : 12.92 * n),
      [
        255 * (t = Math.min(Math.max(0, t), 1)),
        255 * (r = Math.min(Math.max(0, r), 1)),
        255 * (n = Math.min(Math.max(0, n), 1)),
      ]
    );
  }),
  (Xy.xyz.lab = function (e) {
    var t = e[0],
      r = e[1],
      n = e[2];
    return (
      (r /= 100),
      (n /= 108.883),
      (t =
        (t /= 95.047) > 0.008856 ? Math.pow(t, 1 / 3) : 7.787 * t + 16 / 116),
      [
        116 * (r = r > 0.008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116) -
          16,
        500 * (t - r),
        200 *
          (r - (n = n > 0.008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116)),
      ]
    );
  }),
  (Xy.lab.xyz = function (e) {
    var t,
      r,
      n,
      i = e[0];
    (t = e[1] / 500 + (r = (i + 16) / 116)), (n = r - e[2] / 200);
    var a = Math.pow(r, 3),
      s = Math.pow(t, 3),
      o = Math.pow(n, 3);
    return (
      (r = a > 0.008856 ? a : (r - 16 / 116) / 7.787),
      (t = s > 0.008856 ? s : (t - 16 / 116) / 7.787),
      (n = o > 0.008856 ? o : (n - 16 / 116) / 7.787),
      [(t *= 95.047), (r *= 100), (n *= 108.883)]
    );
  }),
  (Xy.lab.lch = function (e) {
    var t,
      r = e[0],
      n = e[1],
      i = e[2];
    return (
      (t = (360 * Math.atan2(i, n)) / 2 / Math.PI) < 0 && (t += 360),
      [r, Math.sqrt(n * n + i * i), t]
    );
  }),
  (Xy.lch.lab = function (e) {
    var t,
      r = e[0],
      n = e[1];
    return (
      (t = (e[2] / 360) * 2 * Math.PI), [r, n * Math.cos(t), n * Math.sin(t)]
    );
  }),
  (Xy.rgb.ansi16 = function (e) {
    var t = e[0],
      r = e[1],
      n = e[2],
      i = 1 in arguments ? arguments[1] : Xy.rgb.hsv(e)[2];
    if (0 === (i = Math.round(i / 50))) return 30;
    var a =
      30 +
      ((Math.round(n / 255) << 2) |
        (Math.round(r / 255) << 1) |
        Math.round(t / 255));
    return 2 === i && (a += 60), a;
  }),
  (Xy.hsv.ansi16 = function (e) {
    return Xy.rgb.ansi16(Xy.hsv.rgb(e), e[2]);
  }),
  (Xy.rgb.ansi256 = function (e) {
    var t = e[0],
      r = e[1],
      n = e[2];
    return t === r && r === n
      ? t < 8
        ? 16
        : t > 248
        ? 231
        : Math.round(((t - 8) / 247) * 24) + 232
      : 16 +
          36 * Math.round((t / 255) * 5) +
          6 * Math.round((r / 255) * 5) +
          Math.round((n / 255) * 5);
  }),
  (Xy.ansi16.rgb = function (e) {
    var t = e % 10;
    if (0 === t || 7 === t)
      return e > 50 && (t += 3.5), [(t = (t / 10.5) * 255), t, t];
    var r = 0.5 * (1 + ~~(e > 50));
    return [
      (1 & t) * r * 255,
      ((t >> 1) & 1) * r * 255,
      ((t >> 2) & 1) * r * 255,
    ];
  }),
  (Xy.ansi256.rgb = function (e) {
    if (e >= 232) {
      var t = 10 * (e - 232) + 8;
      return [t, t, t];
    }
    var r;
    return (
      (e -= 16),
      [
        (Math.floor(e / 36) / 5) * 255,
        (Math.floor((r = e % 36) / 6) / 5) * 255,
        ((r % 6) / 5) * 255,
      ]
    );
  }),
  (Xy.rgb.hex = function (e) {
    var t = (
      ((255 & Math.round(e[0])) << 16) +
      ((255 & Math.round(e[1])) << 8) +
      (255 & Math.round(e[2]))
    )
      .toString(16)
      .toUpperCase();
    return "000000".substring(t.length) + t;
  }),
  (Xy.hex.rgb = function (e) {
    var t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t) return [0, 0, 0];
    var r = t[0];
    3 === t[0].length &&
      (r = r
        .split("")
        .map(function (e) {
          return e + e;
        })
        .join(""));
    var n = parseInt(r, 16);
    return [(n >> 16) & 255, (n >> 8) & 255, 255 & n];
  }),
  (Xy.rgb.hcg = function (e) {
    var t,
      r = e[0] / 255,
      n = e[1] / 255,
      i = e[2] / 255,
      a = Math.max(Math.max(r, n), i),
      s = Math.min(Math.min(r, n), i),
      o = a - s;
    return (
      (t =
        o <= 0
          ? 0
          : a === r
          ? ((n - i) / o) % 6
          : a === n
          ? 2 + (i - r) / o
          : 4 + (r - n) / o + 4),
      (t /= 6),
      [360 * (t %= 1), 100 * o, 100 * (o < 1 ? s / (1 - o) : 0)]
    );
  }),
  (Xy.hsl.hcg = function (e) {
    var t = e[1] / 100,
      r = e[2] / 100,
      n = 1,
      i = 0;
    return (
      (n = r < 0.5 ? 2 * t * r : 2 * t * (1 - r)) < 1 &&
        (i = (r - 0.5 * n) / (1 - n)),
      [e[0], 100 * n, 100 * i]
    );
  }),
  (Xy.hsv.hcg = function (e) {
    var t = e[1] / 100,
      r = e[2] / 100,
      n = t * r,
      i = 0;
    return n < 1 && (i = (r - n) / (1 - n)), [e[0], 100 * n, 100 * i];
  }),
  (Xy.hcg.rgb = function (e) {
    var t = e[0] / 360,
      r = e[1] / 100,
      n = e[2] / 100;
    if (0 === r) return [255 * n, 255 * n, 255 * n];
    var i,
      a = [0, 0, 0],
      s = (t % 1) * 6,
      o = s % 1,
      l = 1 - o;
    switch (Math.floor(s)) {
      case 0:
        (a[0] = 1), (a[1] = o), (a[2] = 0);
        break;
      case 1:
        (a[0] = l), (a[1] = 1), (a[2] = 0);
        break;
      case 2:
        (a[0] = 0), (a[1] = 1), (a[2] = o);
        break;
      case 3:
        (a[0] = 0), (a[1] = l), (a[2] = 1);
        break;
      case 4:
        (a[0] = o), (a[1] = 0), (a[2] = 1);
        break;
      default:
        (a[0] = 1), (a[1] = 0), (a[2] = l);
    }
    return (
      (i = (1 - r) * n),
      [255 * (r * a[0] + i), 255 * (r * a[1] + i), 255 * (r * a[2] + i)]
    );
  }),
  (Xy.hcg.hsv = function (e) {
    var t = e[1] / 100,
      r = t + (e[2] / 100) * (1 - t),
      n = 0;
    return r > 0 && (n = t / r), [e[0], 100 * n, 100 * r];
  }),
  (Xy.hcg.hsl = function (e) {
    var t = e[1] / 100,
      r = (e[2] / 100) * (1 - t) + 0.5 * t,
      n = 0;
    return (
      r > 0 && r < 0.5
        ? (n = t / (2 * r))
        : r >= 0.5 && r < 1 && (n = t / (2 * (1 - r))),
      [e[0], 100 * n, 100 * r]
    );
  }),
  (Xy.hcg.hwb = function (e) {
    var t = e[1] / 100,
      r = t + (e[2] / 100) * (1 - t);
    return [e[0], 100 * (r - t), 100 * (1 - r)];
  }),
  (Xy.hwb.hcg = function (e) {
    var t = e[1] / 100,
      r = 1 - e[2] / 100,
      n = r - t,
      i = 0;
    return n < 1 && (i = (r - n) / (1 - n)), [e[0], 100 * n, 100 * i];
  }),
  (Xy.apple.rgb = function (e) {
    return [(e[0] / 65535) * 255, (e[1] / 65535) * 255, (e[2] / 65535) * 255];
  }),
  (Xy.rgb.apple = function (e) {
    return [(e[0] / 255) * 65535, (e[1] / 255) * 65535, (e[2] / 255) * 65535];
  }),
  (Xy.gray.rgb = function (e) {
    return [(e[0] / 100) * 255, (e[0] / 100) * 255, (e[0] / 100) * 255];
  }),
  (Xy.gray.hsl = Xy.gray.hsv =
    function (e) {
      return [0, 0, e[0]];
    }),
  (Xy.gray.hwb = function (e) {
    return [0, 100, e[0]];
  }),
  (Xy.gray.cmyk = function (e) {
    return [0, 0, 0, e[0]];
  }),
  (Xy.gray.lab = function (e) {
    return [e[0], 0, 0];
  }),
  (Xy.gray.hex = function (e) {
    var t = 255 & Math.round((e[0] / 100) * 255),
      r = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
    return "000000".substring(r.length) + r;
  }),
  (Xy.rgb.gray = function (e) {
    return [((e[0] + e[1] + e[2]) / 3 / 255) * 100];
  });
var Qy = qy.exports;
function Zy(e) {
  var t = (function () {
      for (var e = {}, t = Object.keys(Qy), r = t.length, n = 0; n < r; n++)
        e[t[n]] = { distance: -1, parent: null };
      return e;
    })(),
    r = [e];
  for (t[e].distance = 0; r.length; )
    for (
      var n = r.pop(), i = Object.keys(Qy[n]), a = i.length, s = 0;
      s < a;
      s++
    ) {
      var o = i[s],
        l = t[o];
      -1 === l.distance &&
        ((l.distance = t[n].distance + 1), (l.parent = n), r.unshift(o));
    }
  return t;
}
function em(e, t) {
  return function (r) {
    return t(e(r));
  };
}
function tm(e, t) {
  for (
    var r = [t[e].parent, e], n = Qy[t[e].parent][e], i = t[e].parent;
    t[i].parent;

  )
    r.unshift(t[i].parent), (n = em(Qy[t[i].parent][i], n)), (i = t[i].parent);
  return (n.conversion = r), n;
}
var rm = qy.exports,
  nm = function (e) {
    for (
      var t = Zy(e), r = {}, n = Object.keys(t), i = n.length, a = 0;
      a < i;
      a++
    ) {
      var s = n[a];
      null !== t[s].parent && (r[s] = tm(s, t));
    }
    return r;
  },
  im = {};
Object.keys(rm).forEach(function (e) {
  (im[e] = {}),
    Object.defineProperty(im[e], "channels", { value: rm[e].channels }),
    Object.defineProperty(im[e], "labels", { value: rm[e].labels });
  var t = nm(e);
  Object.keys(t).forEach(function (r) {
    var n = t[r];
    (im[e][r] = (function (e) {
      var t = function (t) {
        if (null == t) return t;
        arguments.length > 1 && (t = Array.prototype.slice.call(arguments));
        var r = e(t);
        if ("object" === g(r))
          for (var n = r.length, i = 0; i < n; i++) r[i] = Math.round(r[i]);
        return r;
      };
      return "conversion" in e && (t.conversion = e.conversion), t;
    })(n)),
      (im[e][r].raw = (function (e) {
        var t = function (t) {
          return null == t
            ? t
            : (arguments.length > 1 &&
                (t = Array.prototype.slice.call(arguments)),
              e(t));
        };
        return "conversion" in e && (t.conversion = e.conversion), t;
      })(n));
  });
});
var am = im;
function sm(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return om(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return om(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function om(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
!(function (e) {
  var t = am,
    r = function (e, r) {
      return function () {
        var n = e.apply(t, arguments);
        return "[".concat(n + r, "m");
      };
    },
    n = function (e, r) {
      return function () {
        var n = e.apply(t, arguments);
        return "[".concat(38 + r, ";5;").concat(n, "m");
      };
    },
    i = function (e, r) {
      return function () {
        var n = e.apply(t, arguments);
        return "["
          .concat(38 + r, ";2;")
          .concat(n[0], ";")
          .concat(n[1], ";")
          .concat(n[2], "m");
      };
    };
  Object.defineProperty(e, "exports", {
    enumerable: !0,
    get: function () {
      var e = new Map(),
        a = {
          modifier: {
            reset: [0, 0],
            bold: [1, 22],
            dim: [2, 22],
            italic: [3, 23],
            underline: [4, 24],
            inverse: [7, 27],
            hidden: [8, 28],
            strikethrough: [9, 29],
          },
          color: {
            black: [30, 39],
            red: [31, 39],
            green: [32, 39],
            yellow: [33, 39],
            blue: [34, 39],
            magenta: [35, 39],
            cyan: [36, 39],
            white: [37, 39],
            gray: [90, 39],
            redBright: [91, 39],
            greenBright: [92, 39],
            yellowBright: [93, 39],
            blueBright: [94, 39],
            magentaBright: [95, 39],
            cyanBright: [96, 39],
            whiteBright: [97, 39],
          },
          bgColor: {
            bgBlack: [40, 49],
            bgRed: [41, 49],
            bgGreen: [42, 49],
            bgYellow: [43, 49],
            bgBlue: [44, 49],
            bgMagenta: [45, 49],
            bgCyan: [46, 49],
            bgWhite: [47, 49],
            bgBlackBright: [100, 49],
            bgRedBright: [101, 49],
            bgGreenBright: [102, 49],
            bgYellowBright: [103, 49],
            bgBlueBright: [104, 49],
            bgMagentaBright: [105, 49],
            bgCyanBright: [106, 49],
            bgWhiteBright: [107, 49],
          },
        };
      a.color.grey = a.color.gray;
      for (var s = 0, o = Object.keys(a); s < o.length; s++) {
        for (
          var l = o[s], u = a[l], c = 0, p = Object.keys(u);
          c < p.length;
          c++
        ) {
          var h = p[c],
            d = u[h];
          (a[h] = {
            open: "[".concat(d[0], "m"),
            close: "[".concat(d[1], "m"),
          }),
            (u[h] = a[h]),
            e.set(d[0], d[1]);
        }
        Object.defineProperty(a, l, { value: u, enumerable: !1 }),
          Object.defineProperty(a, "codes", { value: e, enumerable: !1 });
      }
      var f = function (e) {
          return e;
        },
        y = function (e, t, r) {
          return [e, t, r];
        };
      (a.color.close = "[39m"),
        (a.bgColor.close = "[49m"),
        (a.color.ansi = { ansi: r(f, 0) }),
        (a.color.ansi256 = { ansi256: n(f, 0) }),
        (a.color.ansi16m = { rgb: i(y, 0) }),
        (a.bgColor.ansi = { ansi: r(f, 10) }),
        (a.bgColor.ansi256 = { ansi256: n(f, 10) }),
        (a.bgColor.ansi16m = { rgb: i(y, 10) });
      for (var m = 0, v = Object.keys(t); m < v.length; m++) {
        var b = v[m];
        if ("object" === g(t[b])) {
          var T = t[b];
          "ansi16" === b && (b = "ansi"),
            "ansi16" in T &&
              ((a.color.ansi[b] = r(T.ansi16, 0)),
              (a.bgColor.ansi[b] = r(T.ansi16, 10))),
            "ansi256" in T &&
              ((a.color.ansi256[b] = n(T.ansi256, 0)),
              (a.bgColor.ansi256[b] = n(T.ansi256, 10))),
            "rgb" in T &&
              ((a.color.ansi16m[b] = i(T.rgb, 0)),
              (a.bgColor.ansi16m[b] = i(T.rgb, 10)));
        }
      }
      return a;
    },
  });
})(Wy);
var lm =
    /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi,
  um = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g,
  cm = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/,
  pm = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi,
  hm = new Map([
    ["n", "\n"],
    ["r", "\r"],
    ["t", "\t"],
    ["b", "\b"],
    ["f", "\f"],
    ["v", "\v"],
    ["0", "\0"],
    ["\\", "\\"],
    ["e", ""],
    ["a", ""],
  ]);
function dm(e) {
  return ("u" === e[0] && 5 === e.length) || ("x" === e[0] && 3 === e.length)
    ? String.fromCharCode(parseInt(e.slice(1), 16))
    : hm.get(e) || e;
}
function fm(e, t) {
  var r,
    n,
    i = [],
    a = sm(t.trim().split(/\s*,\s*/g));
  try {
    for (a.s(); !(n = a.n()).done; ) {
      var s = n.value;
      if (isNaN(s)) {
        if (!(r = s.match(cm)))
          throw new Error(
            "Invalid Chalk template style argument: "
              .concat(s, " (in style '")
              .concat(e, "')")
          );
        i.push(
          r[2].replace(pm, function (e, t, r) {
            return t ? dm(t) : r;
          })
        );
      } else i.push(Number(s));
    }
  } catch (e) {
    a.e(e);
  } finally {
    a.f();
  }
  return i;
}
function ym(e) {
  um.lastIndex = 0;
  for (var t, r = []; null !== (t = um.exec(e)); ) {
    var n = t[1];
    if (t[2]) {
      var i = fm(n, t[2]);
      r.push([n].concat(i));
    } else r.push([n]);
  }
  return r;
}
function mm(e, t) {
  var r,
    n = {},
    i = sm(t);
  try {
    for (i.s(); !(r = i.n()).done; ) {
      var a,
        s = r.value,
        o = sm(s.styles);
      try {
        for (o.s(); !(a = o.n()).done; ) {
          var l = a.value;
          n[l[0]] = s.inverse ? null : l.slice(1);
        }
      } catch (e) {
        o.e(e);
      } finally {
        o.f();
      }
    }
  } catch (e) {
    i.e(e);
  } finally {
    i.f();
  }
  for (var u = e, c = 0, p = Object.keys(n); c < p.length; c++) {
    var h = p[c];
    if (Array.isArray(n[h])) {
      if (!(h in u)) throw new Error("Unknown Chalk style: ".concat(h));
      u = n[h].length > 0 ? u[h].apply(u, n[h]) : u[h];
    }
  }
  return u;
}
var vm = function (e, t) {
  var r = [],
    n = [],
    i = [];
  if (
    (t.replace(lm, function (t, a, s, o, l, u) {
      if (a) i.push(dm(a));
      else if (o) {
        var c = i.join("");
        (i = []),
          n.push(0 === r.length ? c : mm(e, r)(c)),
          r.push({ inverse: s, styles: ym(o) });
      } else if (l) {
        if (0 === r.length)
          throw new Error("Found extraneous } in Chalk template literal");
        n.push(mm(e, r)(i.join(""))), (i = []), r.pop();
      } else i.push(u);
    }),
    n.push(i.join("")),
    r.length > 0)
  ) {
    var a = "Chalk template literal is missing "
      .concat(r.length, " closing bracket")
      .concat(1 === r.length ? "" : "s", " (`}`)");
    throw new Error(a);
  }
  return n.join("");
};
function gm(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return bm(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return bm(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function bm(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function Tm(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Sm(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Sm(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Sm(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
!(function (e) {
  var t = Ky,
    r = Wy.exports,
    n = qf().stdout,
    i = vm,
    a =
      "win32" === process.platform &&
      !(process.env.TERM || "").toLowerCase().startsWith("xterm"),
    s = ["ansi", "ansi", "ansi256", "ansi16m"],
    o = new Set(["gray"]),
    l = Object.create(null);
  function u(e, t) {
    t = t || {};
    var r = n ? n.level : 0;
    (e.level = void 0 === t.level ? r : t.level),
      (e.enabled = "enabled" in t ? t.enabled : e.level > 0);
  }
  function c(e) {
    if (!this || !(this instanceof c) || this.template) {
      var t = {};
      return (
        u(t, e),
        (t.template = function () {
          var e = [].slice.call(arguments);
          return E.apply(null, [t.template].concat(e));
        }),
        Object.setPrototypeOf(t, c.prototype),
        Object.setPrototypeOf(t.template, t),
        (t.template.constructor = c),
        t.template
      );
    }
    u(this, e);
  }
  a && (r.blue.open = "[94m");
  for (
    var p = function () {
        var e = d[h];
        (r[e].closeRe = new RegExp(t(r[e].close), "g")),
          (l[e] = {
            get: function () {
              var t = r[e];
              return S.call(
                this,
                this._styles ? this._styles.concat(t) : [t],
                this._empty,
                e
              );
            },
          });
      },
      h = 0,
      d = Object.keys(r);
    h < d.length;
    h++
  )
    p();
  (l.visible = {
    get: function () {
      return S.call(this, this._styles || [], !0, "visible");
    },
  }),
    (r.color.closeRe = new RegExp(t(r.color.close), "g"));
  for (
    var f = function () {
        var e = m[y];
        if (o.has(e)) return "continue";
        l[e] = {
          get: function () {
            var t = this.level;
            return function () {
              var n = {
                open: r.color[s[t]][e].apply(null, arguments),
                close: r.color.close,
                closeRe: r.color.closeRe,
              };
              return S.call(
                this,
                this._styles ? this._styles.concat(n) : [n],
                this._empty,
                e
              );
            };
          },
        };
      },
      y = 0,
      m = Object.keys(r.color.ansi);
    y < m.length;
    y++
  )
    f();
  r.bgColor.closeRe = new RegExp(t(r.bgColor.close), "g");
  for (
    var v = function () {
        var e = b[g];
        if (o.has(e)) return "continue";
        var t = "bg" + e[0].toUpperCase() + e.slice(1);
        l[t] = {
          get: function () {
            var t = this.level;
            return function () {
              var n = {
                open: r.bgColor[s[t]][e].apply(null, arguments),
                close: r.bgColor.close,
                closeRe: r.bgColor.closeRe,
              };
              return S.call(
                this,
                this._styles ? this._styles.concat(n) : [n],
                this._empty,
                e
              );
            };
          },
        };
      },
      g = 0,
      b = Object.keys(r.bgColor.ansi);
    g < b.length;
    g++
  )
    v();
  var T = Object.defineProperties(function () {}, l);
  function S(e, t, r) {
    var n = function e() {
      return x.apply(e, arguments);
    };
    (n._styles = e), (n._empty = t);
    var i = this;
    return (
      Object.defineProperty(n, "level", {
        enumerable: !0,
        get: function () {
          return i.level;
        },
        set: function (e) {
          i.level = e;
        },
      }),
      Object.defineProperty(n, "enabled", {
        enumerable: !0,
        get: function () {
          return i.enabled;
        },
        set: function (e) {
          i.enabled = e;
        },
      }),
      (n.hasGrey = this.hasGrey || "gray" === r || "grey" === r),
      (n.__proto__ = T),
      n
    );
  }
  function x() {
    var e = arguments,
      t = e.length,
      n = String(arguments[0]);
    if (0 === t) return "";
    if (t > 1) for (var i = 1; i < t; i++) n += " " + e[i];
    if (!this.enabled || this.level <= 0 || !n) return this._empty ? "" : n;
    var s = r.dim.open;
    a && this.hasGrey && (r.dim.open = "");
    var o,
      l = gm(this._styles.slice().reverse());
    try {
      for (l.s(); !(o = l.n()).done; ) {
        var u = o.value;
        n = (n = u.open + n.replace(u.closeRe, u.open) + u.close).replace(
          /\r?\n/g,
          "".concat(u.close, "$&").concat(u.open)
        );
      }
    } catch (e) {
      l.e(e);
    } finally {
      l.f();
    }
    return (r.dim.open = s), n;
  }
  function E(e, t) {
    if (!Array.isArray(t)) return [].slice.call(arguments, 1).join(" ");
    for (
      var r = [].slice.call(arguments, 2), n = [t.raw[0]], a = 1;
      a < t.length;
      a++
    )
      n.push(String(r[a - 1]).replace(/[{}\\]/g, "\\$&")),
        n.push(String(t.raw[a]));
    return i(e, n.join(""));
  }
  Object.defineProperties(c.prototype, l),
    (e.exports = c()),
    (e.exports.supportsColor = n),
    (e.exports.default = e.exports);
})(Uy),
  Object.defineProperty(By, "__esModule", { value: !0 }),
  (By.default = function (e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
    if ("" !== e && Nm(t)) {
      var r = (function (e) {
        return {
          keyword: e.cyan,
          capitalized: e.yellow,
          jsxIdentifier: e.yellow,
          punctuator: e.yellow,
          number: e.magenta,
          string: e.green,
          regex: e.magenta,
          comment: e.grey,
          invalid: e.white.bgRed.bold,
        };
      })(_m(t));
      return (function (e, t) {
        var r,
          n = "",
          i = Tm(km(t));
        try {
          var a = function () {
            var t = r.value,
              i = t.type,
              a = t.value,
              s = e[i];
            n += s
              ? a
                  .split(wm)
                  .map(function (e) {
                    return s(e);
                  })
                  .join("\n")
              : a;
          };
          for (i.s(); !(r = i.n()).done; ) a();
        } catch (e) {
          i.e(e);
        } finally {
          i.f();
        }
        return n;
      })(r, e);
    }
    return e;
  }),
  (By.getChalk = _m),
  (By.shouldHighlight = Nm);
var xm = Ry,
  Em = da,
  Pm = Uy.exports,
  Am = new Set(["as", "async", "from", "get", "of", "set"]);
var km,
  wm = /\r\n|[\n\r\u2028\u2029]/,
  Cm = /^[()[\]{}]$/,
  Im = /^[a-z][\w-]*$/i,
  Om = function (e, t, r) {
    if ("name" === e.type) {
      if (
        (0, Em.isKeyword)(e.value) ||
        (0, Em.isStrictReservedWord)(e.value, !0) ||
        Am.has(e.value)
      )
        return "keyword";
      if (Im.test(e.value) && ("<" === r[t - 1] || "</" == r.slice(t - 2, t)))
        return "jsxIdentifier";
      if (e.value[0] !== e.value[0].toLowerCase()) return "capitalized";
    }
    return "punctuator" === e.type && Cm.test(e.value)
      ? "bracket"
      : "invalid" !== e.type || ("@" !== e.value && "#" !== e.value)
      ? e.type
      : "punctuator";
  };
function Nm(e) {
  return !!Pm.supportsColor || e.forceColor;
}
function _m(e) {
  return e.forceColor ? new Pm.constructor({ enabled: !0, level: 1 }) : Pm;
}
(km = G.mark(function e(t) {
  var r, n;
  return G.wrap(function (e) {
    for (;;)
      switch ((e.prev = e.next)) {
        case 0:
          if (!(r = xm.default.exec(t))) {
            e.next = 6;
            break;
          }
          return (
            (n = xm.matchToToken(r)),
            (e.next = 4),
            { type: Om(n, r.index, t), value: n.value }
          );
        case 4:
          e.next = 0;
          break;
        case 6:
        case "end":
          return e.stop();
      }
  }, e);
})),
  Object.defineProperty(Fy, "__esModule", { value: !0 }),
  (Fy.codeFrameColumns = jm),
  (Fy.default = function (e, t, r) {
    var n = arguments.length > 3 && void 0 !== arguments[3] ? arguments[3] : {};
    if (!Lm) {
      Lm = !0;
      var i =
        "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";
      if (process.emitWarning) process.emitWarning(i, "DeprecationWarning");
      else
        (new Error(i).name = "DeprecationWarning"), console.warn(new Error(i));
    }
    return (r = Math.max(r, 0)), jm(e, { start: { column: r, line: t } }, n);
  });
var Dm = By,
  Lm = !1;
var Mm = /\r\n|[\n\r\u2028\u2029]/;
function jm(e, t) {
  var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : {},
    n = (r.highlightCode || r.forceColor) && (0, Dm.shouldHighlight)(r),
    i = (0, Dm.getChalk)(r),
    a = (function (e) {
      return { gutter: e.grey, marker: e.red.bold, message: e.red.bold };
    })(i),
    s = function (e, t) {
      return n ? e(t) : t;
    },
    o = (function (e, t, r) {
      var n = Object.assign({ column: 0, line: -1 }, e.start),
        i = Object.assign({}, n, e.end),
        a = r || {},
        s = a.linesAbove,
        o = void 0 === s ? 2 : s,
        l = a.linesBelow,
        u = void 0 === l ? 3 : l,
        c = n.line,
        p = n.column,
        h = i.line,
        d = i.column,
        f = Math.max(c - (o + 1), 0),
        y = Math.min(t.length, h + u);
      -1 === c && (f = 0), -1 === h && (y = t.length);
      var m = h - c,
        v = {};
      if (m)
        for (var g = 0; g <= m; g++) {
          var b = g + c;
          if (p)
            if (0 === g) {
              var T = t[b - 1].length;
              v[b] = [p, T - p + 1];
            } else if (g === m) v[b] = [0, d];
            else {
              var S = t[b - g].length;
              v[b] = [0, S];
            }
          else v[b] = !0;
        }
      else v[c] = p === d ? !p || [p, 0] : [p, d - p];
      return { start: f, end: y, markerLines: v };
    })(t, e.split(Mm), r),
    l = o.start,
    u = o.end,
    c = o.markerLines,
    p = t.start && "number" == typeof t.start.column,
    h = String(u).length,
    d = (n ? (0, Dm.default)(e, r) : e)
      .split(Mm, u)
      .slice(l, u)
      .map(function (e, t) {
        var n = l + 1 + t,
          i = " ".concat(n).slice(-h),
          o = " ".concat(i, " |"),
          u = c[n],
          p = !c[n + 1];
        if (u) {
          var d = "";
          if (Array.isArray(u)) {
            var f = e.slice(0, Math.max(u[0] - 1, 0)).replace(/[^\t]/g, " "),
              y = u[1] || 1;
            (d = [
              "\n ",
              s(a.gutter, o.replace(/\d/g, " ")),
              " ",
              f,
              s(a.marker, "^").repeat(y),
            ].join("")),
              p && r.message && (d += " " + s(a.message, r.message));
          }
          return [
            s(a.marker, ">"),
            s(a.gutter, o),
            e.length > 0 ? " ".concat(e) : "",
            d,
          ].join("");
        }
        return " "
          .concat(s(a.gutter, o))
          .concat(e.length > 0 ? " ".concat(e) : "");
      })
      .join("\n");
  return (
    r.message &&
      !p &&
      (d = ""
        .concat(" ".repeat(h + 1))
        .concat(r.message, "\n")
        .concat(d)),
    n ? i.reset(d) : d
  );
}
var Fm = {};
function Bm(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Rm(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Rm(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Rm(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(Fm, "__esModule", { value: !0 }),
  (Fm.default = function (e, t) {
    var r =
      arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "var";
    e.traverse(Hm, { kind: r, emit: t });
  });
var Um,
  Vm = mc(),
  Km = Vm.assignmentExpression,
  Wm = Vm.expressionStatement,
  qm = Vm.identifier,
  Hm = {
    Scope: function (e, t) {
      "let" === t.kind && e.skip();
    },
    FunctionParent: function (e) {
      e.skip();
    },
    VariableDeclaration: function (e, t) {
      if (!t.kind || e.node.kind === t.kind) {
        var r,
          n,
          i = [],
          a = Bm(e.get("declarations"));
        try {
          for (a.s(); !(n = a.n()).done; ) {
            var s = n.value;
            (r = s.node.id),
              s.node.init && i.push(Wm(Km("=", s.node.id, s.node.init)));
            for (
              var o = 0, l = Object.keys(s.getBindingIdentifiers());
              o < l.length;
              o++
            ) {
              var u = l[o];
              t.emit(qm(u), u, null !== s.node.init);
            }
          }
        } catch (e) {
          a.e(e);
        } finally {
          a.f();
        }
        e.parentPath.isFor({ left: e.node })
          ? e.replaceWith(r)
          : e.replaceWithMultiple(i);
      }
    },
  };
function Ym(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Jm(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Jm(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Jm(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
var Xm = {};
function Gm(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return zm(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return zm(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function zm(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(Xm, "__esModule", { value: !0 }),
  (Xm.evaluate = function () {
    var e = { confident: !0, deoptPath: null, seen: new Map() },
      t = rv(this, e);
    e.confident || (t = void 0);
    return { confident: e.confident, deopt: e.deoptPath, value: t };
  }),
  (Xm.evaluateTruthy = function () {
    var e = this.evaluate();
    if (e.confident) return !!e.value;
  });
var $m = ["String", "Number", "Math"],
  Qm = ["random"];
function Zm(e) {
  return $m.includes(e);
}
function ev(e, t) {
  t.confident && ((t.deoptPath = e), (t.confident = !1));
}
var tv = new Map([
  ["undefined", void 0],
  ["Infinity", 1 / 0],
  ["NaN", NaN],
]);
function rv(e, t) {
  var r = e.node,
    n = t.seen;
  if (n.has(r)) {
    var i = n.get(r);
    return i.resolved ? i.value : void ev(e, t);
  }
  var a = { resolved: !1 };
  n.set(r, a);
  var s = (function (e, t) {
    if (!t.confident) return;
    if (e.isSequenceExpression()) {
      var r = e.get("expressions");
      return rv(r[r.length - 1], t);
    }
    if (e.isStringLiteral() || e.isNumericLiteral() || e.isBooleanLiteral())
      return e.node.value;
    if (e.isNullLiteral()) return null;
    if (e.isTemplateLiteral()) return nv(e, e.node.quasis, t);
    if (e.isTaggedTemplateExpression() && e.get("tag").isMemberExpression()) {
      var n = e.get("tag.object"),
        i = n.node.name,
        a = e.get("tag.property");
      if (
        n.isIdentifier() &&
        "String" === i &&
        !e.scope.getBinding(i) &&
        a.isIdentifier() &&
        "raw" === a.node.name
      )
        return nv(e, e.node.quasi.quasis, t, !0);
    }
    if (e.isConditionalExpression()) {
      var s = rv(e.get("test"), t);
      if (!t.confident) return;
      return rv(s ? e.get("consequent") : e.get("alternate"), t);
    }
    if (e.isExpressionWrapper()) return rv(e.get("expression"), t);
    if (
      e.isMemberExpression() &&
      !e.parentPath.isCallExpression({ callee: e.node })
    ) {
      var o = e.get("property"),
        l = e.get("object");
      if (l.isLiteral()) {
        var u = l.node.value,
          c = g(u),
          p = null;
        if (e.node.computed) {
          if (((p = rv(o, t)), !t.confident)) return;
        } else o.isIdentifier() && (p = o.node.name);
        if (
          !(
            ("number" !== c && "string" !== c) ||
            null == p ||
            ("number" != typeof p && "string" != typeof p)
          )
        )
          return u[p];
      }
    }
    if (e.isReferencedIdentifier()) {
      var h = e.scope.getBinding(e.node.name);
      if (h) {
        if (h.constantViolations.length > 0 || e.node.start < h.path.node.end)
          return void ev(h.path, t);
        if (h.hasValue) return h.value;
      }
      var d = e.node.name;
      if (tv.has(d)) return h ? void ev(h.path, t) : tv.get(d);
      var f = e.resolve();
      return f === e ? void ev(e, t) : rv(f, t);
    }
    if (e.isUnaryExpression({ prefix: !0 })) {
      if ("void" === e.node.operator) return;
      var y = e.get("argument");
      if ("typeof" === e.node.operator && (y.isFunction() || y.isClass()))
        return "function";
      var m = rv(y, t);
      if (!t.confident) return;
      switch (e.node.operator) {
        case "!":
          return !m;
        case "+":
          return +m;
        case "-":
          return -m;
        case "~":
          return ~m;
        case "typeof":
          return g(m);
      }
    }
    if (e.isArrayExpression()) {
      var v,
        b = [],
        T = Gm(e.get("elements"));
      try {
        for (T.s(); !(v = T.n()).done; ) {
          var x = v.value.evaluate();
          if (!x.confident) return void ev(x.deopt, t);
          b.push(x.value);
        }
      } catch (e) {
        T.e(e);
      } finally {
        T.f();
      }
      return b;
    }
    if (e.isObjectExpression()) {
      var E,
        P = {},
        A = Gm(e.get("properties"));
      try {
        for (A.s(); !(E = A.n()).done; ) {
          var k = E.value;
          if (k.isObjectMethod() || k.isSpreadElement()) return void ev(k, t);
          var w = k.get("key"),
            C = void 0;
          if (k.node.computed) {
            if (!(C = w.evaluate()).confident) return void ev(C.deopt, t);
            C = C.value;
          } else C = w.isIdentifier() ? w.node.name : w.node.value;
          var I = k.get("value").evaluate();
          if (!I.confident) return void ev(I.deopt, t);
          (I = I.value), (P[C] = I);
        }
      } catch (e) {
        A.e(e);
      } finally {
        A.f();
      }
      return P;
    }
    if (e.isLogicalExpression()) {
      var O = t.confident,
        N = rv(e.get("left"), t),
        _ = t.confident;
      t.confident = O;
      var D = rv(e.get("right"), t),
        L = t.confident;
      switch (e.node.operator) {
        case "||":
          if (((t.confident = _ && (!!N || L)), !t.confident)) return;
          return N || D;
        case "&&":
          if (((t.confident = _ && (!N || L)), !t.confident)) return;
          return N && D;
        case "??":
          if (((t.confident = _ && (null != N || L)), !t.confident)) return;
          return null != N ? N : D;
      }
    }
    if (e.isBinaryExpression()) {
      var M = rv(e.get("left"), t);
      if (!t.confident) return;
      var j = rv(e.get("right"), t);
      if (!t.confident) return;
      switch (e.node.operator) {
        case "-":
          return M - j;
        case "+":
          return M + j;
        case "/":
          return M / j;
        case "*":
          return M * j;
        case "%":
          return M % j;
        case "**":
          return Math.pow(M, j);
        case "<":
          return M < j;
        case ">":
          return M > j;
        case "<=":
          return M <= j;
        case ">=":
          return M >= j;
        case "==":
          return M == j;
        case "!=":
          return M != j;
        case "===":
          return M === j;
        case "!==":
          return M !== j;
        case "|":
          return M | j;
        case "&":
          return M & j;
        case "^":
          return M ^ j;
        case "<<":
          return M << j;
        case ">>":
          return M >> j;
        case ">>>":
          return M >>> j;
      }
    }
    if (e.isCallExpression()) {
      var F,
        B,
        R = e.get("callee");
      if (
        (R.isIdentifier() &&
          !e.scope.getBinding(R.node.name) &&
          Zm(R.node.name) &&
          (B = S[R.node.name]),
        R.isMemberExpression())
      ) {
        var U = R.get("object"),
          V = R.get("property");
        if (
          (U.isIdentifier() &&
            V.isIdentifier() &&
            Zm(U.node.name) &&
            !(function (e) {
              return Qm.includes(e);
            })(V.node.name) &&
            (B = (F = S[U.node.name])[V.node.name]),
          U.isLiteral() && V.isIdentifier())
        ) {
          var K = g(U.node.value);
          ("string" !== K && "number" !== K) ||
            (B = (F = U.node.value)[V.node.name]);
        }
      }
      if (B) {
        var W = e.get("arguments").map(function (e) {
          return rv(e, t);
        });
        if (!t.confident) return;
        return B.apply(F, W);
      }
    }
    ev(e, t);
  })(e, t);
  return t.confident && ((a.resolved = !0), (a.value = s)), s;
}
function nv(e, t, r) {
  var n,
    i = arguments.length > 3 && void 0 !== arguments[3] && arguments[3],
    a = "",
    s = 0,
    o = e.isTemplateLiteral()
      ? e.get("expressions")
      : e.get("quasi.expressions"),
    l = Gm(t);
  try {
    for (l.s(); !(n = l.n()).done; ) {
      var u = n.value;
      if (!r.confident) break;
      a += i ? u.value.raw : u.value.cooked;
      var c = o[s++];
      c && (a += String(rv(c, r)));
    }
  } catch (e) {
    l.e(e);
  } finally {
    l.f();
  }
  if (r.confident) return a;
}
var iv = {},
  av = {},
  sv = {},
  ov = {};
Object.defineProperty(ov, "__esModule", { value: !0 }),
  (ov.statements =
    ov.statement =
    ov.smart =
    ov.program =
    ov.expression =
      void 0);
var lv = mc().assertExpressionStatement;
function uv(e) {
  return {
    code: function (e) {
      return "/* @babel/template */;\n".concat(e);
    },
    validate: function () {},
    unwrap: function (t) {
      return e(t.program.body.slice(1));
    },
  };
}
var cv = uv(function (e) {
  return e.length > 1 ? e : e[0];
});
ov.smart = cv;
var pv = uv(function (e) {
  return e;
});
ov.statements = pv;
var hv = uv(function (e) {
  if (0 === e.length) throw new Error("Found nothing to return.");
  if (e.length > 1) throw new Error("Found multiple statements but wanted one");
  return e[0];
});
ov.statement = hv;
var dv = {
  code: function (e) {
    return "(\n".concat(e, "\n)");
  },
  validate: function (e) {
    if (e.program.body.length > 1)
      throw new Error("Found multiple statements but wanted one");
    if (0 === dv.unwrap(e).start)
      throw new Error("Parse result included parens.");
  },
  unwrap: function (e) {
    var t = H(e.program.body, 1)[0];
    return lv(t), t.expression;
  },
};
ov.expression = dv;
ov.program = {
  code: function (e) {
    return e;
  },
  validate: function () {},
  unwrap: function (e) {
    return e.program;
  },
};
var fv = {},
  yv = {};
Object.defineProperty(yv, "__esModule", { value: !0 }),
  (yv.merge = function (e, t) {
    var r = t.placeholderWhitelist,
      n = void 0 === r ? e.placeholderWhitelist : r,
      i = t.placeholderPattern,
      a = void 0 === i ? e.placeholderPattern : i,
      s = t.preserveComments,
      o = void 0 === s ? e.preserveComments : s,
      l = t.syntacticPlaceholders,
      u = void 0 === l ? e.syntacticPlaceholders : l;
    return {
      parser: Object.assign({}, e.parser, t.parser),
      placeholderWhitelist: n,
      placeholderPattern: a,
      preserveComments: o,
      syntacticPlaceholders: u,
    };
  }),
  (yv.normalizeReplacements = function (e) {
    if (Array.isArray(e))
      return e.reduce(function (e, t, r) {
        return (e["$" + r] = t), e;
      }, {});
    if ("object" === g(e) || null == e) return e || void 0;
    throw new Error(
      "Template replacements must be an array, object, null, or undefined"
    );
  }),
  (yv.validate = function (e) {
    if (null != e && "object" !== g(e))
      throw new Error("Unknown template options.");
    var t = e || {},
      r = t.placeholderWhitelist,
      n = t.placeholderPattern,
      i = t.preserveComments,
      a = t.syntacticPlaceholders,
      s = (function (e, t) {
        if (null == e) return {};
        var r,
          n,
          i = {},
          a = Object.keys(e);
        for (n = 0; n < a.length; n++)
          (r = a[n]), t.indexOf(r) >= 0 || (i[r] = e[r]);
        return i;
      })(t, mv);
    if (null != r && !(r instanceof Set))
      throw new Error(
        "'.placeholderWhitelist' must be a Set, null, or undefined"
      );
    if (null != n && !(n instanceof RegExp) && !1 !== n)
      throw new Error(
        "'.placeholderPattern' must be a RegExp, false, null, or undefined"
      );
    if (null != i && "boolean" != typeof i)
      throw new Error(
        "'.preserveComments' must be a boolean, null, or undefined"
      );
    if (null != a && "boolean" != typeof a)
      throw new Error(
        "'.syntacticPlaceholders' must be a boolean, null, or undefined"
      );
    if (!0 === a && (null != r || null != n))
      throw new Error(
        "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'"
      );
    return {
      parser: s,
      placeholderWhitelist: r || void 0,
      placeholderPattern: null == n ? void 0 : n,
      preserveComments: null == i ? void 0 : i,
      syntacticPlaceholders: null == a ? void 0 : a,
    };
  });
var mv = [
  "placeholderWhitelist",
  "placeholderPattern",
  "preserveComments",
  "syntacticPlaceholders",
];
var vv = {},
  gv = {};
Object.defineProperty(gv, "__esModule", { value: !0 }),
  (gv.default = function (e, t, r) {
    var n = r.placeholderWhitelist,
      i = r.placeholderPattern,
      a = r.preserveComments,
      s = r.syntacticPlaceholders,
      o = (function (e, t, r) {
        var n = (t.plugins || []).slice();
        !1 !== r && n.push("placeholders");
        t = Object.assign(
          {
            allowReturnOutsideFunction: !0,
            allowSuperOutsideMethod: !0,
            sourceType: "module",
          },
          t,
          { plugins: n }
        );
        try {
          return (0, Tv.parse)(e, t);
        } catch (t) {
          var i = t.loc;
          throw (
            (i &&
              ((t.message += "\n" + (0, Sv.codeFrameColumns)(e, { start: i })),
              (t.code = "BABEL_TEMPLATE_PARSE_ERROR")),
            t)
          );
        }
      })(t, r.parser, s);
    Nv(o, { preserveComments: a }), e.validate(o);
    var l = {
      syntactic: { placeholders: [], placeholderNames: new Set() },
      legacy: { placeholders: [], placeholderNames: new Set() },
      placeholderWhitelist: n,
      placeholderPattern: i,
      syntacticPlaceholders: s,
    };
    return (
      _v(o, Lv, l),
      Object.assign(
        { ast: o },
        l.syntactic.placeholders.length ? l.syntactic : l.legacy
      )
    );
  });
var bv = mc(),
  Tv = qe,
  Sv = Fy,
  xv = bv.isCallExpression,
  Ev = bv.isExpressionStatement,
  Pv = bv.isFunction,
  Av = bv.isIdentifier,
  kv = bv.isJSXIdentifier,
  wv = bv.isNewExpression,
  Cv = bv.isPlaceholder,
  Iv = bv.isStatement,
  Ov = bv.isStringLiteral,
  Nv = bv.removePropertiesDeep,
  _v = bv.traverse,
  Dv = /^[_$A-Z0-9]+$/;
function Lv(e, t, r) {
  var n,
    i,
    a = r.syntactic.placeholders.length > 0;
  if (Cv(e)) {
    if (!1 === r.syntacticPlaceholders)
      throw new Error(
        "%%foo%%-style placeholders can't be used when '.syntacticPlaceholders' is false."
      );
    (i = e.name.name), (a = !0);
  } else {
    if (a || r.syntacticPlaceholders) return;
    if (Av(e) || kv(e)) i = e.name;
    else {
      if (!Ov(e)) return;
      i = e.value;
    }
  }
  if (a && (null != r.placeholderPattern || null != r.placeholderWhitelist))
    throw new Error(
      "'.placeholderWhitelist' and '.placeholderPattern' aren't compatible with '.syntacticPlaceholders: true'"
    );
  if (
    a ||
    (!1 !== r.placeholderPattern && (r.placeholderPattern || Dv).test(i)) ||
    (null != (n = r.placeholderWhitelist) && n.has(i))
  ) {
    var s,
      o = (t = t.slice())[t.length - 1],
      l = o.node,
      u = o.key;
    Ov(e) || Cv(e, { expectedNode: "StringLiteral" })
      ? (s = "string")
      : (wv(l) && "arguments" === u) ||
        (xv(l) && "arguments" === u) ||
        (Pv(l) && "params" === u)
      ? (s = "param")
      : Ev(l) && !Cv(e)
      ? ((s = "statement"), (t = t.slice(0, -1)))
      : (s = Iv(e) && Cv(e) ? "statement" : "other");
    var c = a ? r.syntactic : r.legacy,
      p = c.placeholders,
      h = c.placeholderNames;
    p.push({
      name: i,
      type: s,
      resolve: function (e) {
        return (function (e, t) {
          for (var r = e, n = 0; n < t.length - 1; n++) {
            var i = t[n],
              a = i.key,
              s = i.index;
            r = void 0 === s ? r[a] : r[a][s];
          }
          var o = t[t.length - 1],
            l = o.key,
            u = o.index;
          return { parent: r, key: l, index: u };
        })(e, t);
      },
      isDuplicate: h.has(i),
    }),
      h.add(i);
  }
}
var Mv = {};
Object.defineProperty(Mv, "__esModule", { value: !0 }),
  (Mv.default = function (e, t) {
    var r = Bv(e.ast);
    t &&
      (e.placeholders.forEach(function (e) {
        if (!Object.prototype.hasOwnProperty.call(t, e.name)) {
          var r = e.name;
          throw new Error(
            'Error: No substitution given for "'
              .concat(
                r,
                "\". If this is not meant to be a\n            placeholder you may want to consider passing one of the following options to @babel/template:\n            - { placeholderPattern: false, placeholderWhitelist: new Set(['"
              )
              .concat(r, "'])}\n            - { placeholderPattern: /^")
              .concat(r, "$/ }")
          );
        }
      }),
      Object.keys(t).forEach(function (t) {
        if (!e.placeholderNames.has(t))
          throw new Error('Unknown substitution "'.concat(t, '" given'));
      }));
    return (
      e.placeholders
        .slice()
        .reverse()
        .forEach(function (e) {
          try {
            !(function (e, t, r) {
              e.isDuplicate &&
                (Array.isArray(r)
                  ? (r = r.map(function (e) {
                      return Bv(e);
                    }))
                  : "object" === g(r) && (r = Bv(r)));
              var n = e.resolve(t),
                i = n.parent,
                a = n.key,
                s = n.index;
              if ("string" === e.type) {
                if (("string" == typeof r && (r = qv(r)), !r || !Wv(r)))
                  throw new Error("Expected string substitution");
              } else if ("statement" === e.type)
                void 0 === s
                  ? r
                    ? Array.isArray(r)
                      ? (r = Fv(r))
                      : "string" == typeof r
                      ? (r = Uv(Vv(r)))
                      : Kv(r) || (r = Uv(r))
                    : (r = Rv())
                  : r &&
                    !Array.isArray(r) &&
                    ("string" == typeof r && (r = Vv(r)), Kv(r) || (r = Uv(r)));
              else if ("param" === e.type) {
                if (("string" == typeof r && (r = Vv(r)), void 0 === s))
                  throw new Error("Assertion failure.");
              } else if (
                ("string" == typeof r && (r = Vv(r)), Array.isArray(r))
              )
                throw new Error(
                  "Cannot replace single expression with an array."
                );
              if (void 0 === s) Hv(i, a, r), (i[a] = r);
              else {
                var o = i[a].slice();
                "statement" === e.type || "param" === e.type
                  ? null == r
                    ? o.splice(s, 1)
                    : Array.isArray(r)
                    ? o.splice.apply(o, [s, 1].concat(K(r)))
                    : (o[s] = r)
                  : (o[s] = r),
                  Hv(i, a, o),
                  (i[a] = o);
              }
            })(e, r, (t && t[e.name]) || null);
          } catch (t) {
            throw (
              ((t.message = '@babel/template placeholder "'
                .concat(e.name, '": ')
                .concat(t.message)),
              t)
            );
          }
        }),
      r
    );
  });
var jv = mc(),
  Fv = jv.blockStatement,
  Bv = jv.cloneNode,
  Rv = jv.emptyStatement,
  Uv = jv.expressionStatement,
  Vv = jv.identifier,
  Kv = jv.isStatement,
  Wv = jv.isStringLiteral,
  qv = jv.stringLiteral,
  Hv = jv.validate;
Object.defineProperty(vv, "__esModule", { value: !0 }),
  (vv.default = function (e, t, r) {
    var n;
    return (
      (t = e.code(t)),
      function (i) {
        var a = (0, Yv.normalizeReplacements)(i);
        return (
          n || (n = (0, Jv.default)(e, t, r)), e.unwrap((0, Xv.default)(n, a))
        );
      }
    );
  });
var Yv = yv,
  Jv = gv,
  Xv = Mv;
var Gv = {};
Object.defineProperty(Gv, "__esModule", { value: !0 }),
  (Gv.default = function (e, t, r) {
    var n = (function (e, t, r) {
        var n = "BABEL_TPL$",
          i = t.join("");
        do {
          n = "$$" + n;
        } while (i.includes(n));
        var a = (function (e, t) {
            for (var r = [], n = e[0], i = 1; i < e.length; i++) {
              var a = "".concat(t).concat(i - 1);
              r.push(a), (n += a + e[i]);
            }
            return { names: r, code: n };
          })(t, n),
          s = a.names,
          o = a.code,
          l = (0, $v.default)(e, e.code(o), {
            parser: r.parser,
            placeholderWhitelist: new Set(
              s.concat(
                r.placeholderWhitelist ? Array.from(r.placeholderWhitelist) : []
              )
            ),
            placeholderPattern: r.placeholderPattern,
            preserveComments: r.preserveComments,
            syntacticPlaceholders: r.syntacticPlaceholders,
          });
        return { metadata: l, names: s };
      })(e, t, r),
      i = n.metadata,
      a = n.names;
    return function (t) {
      var r = {};
      return (
        t.forEach(function (e, t) {
          r[a[t]] = e;
        }),
        function (t) {
          var n = (0, zv.normalizeReplacements)(t);
          return (
            n &&
              Object.keys(n).forEach(function (e) {
                if (Object.prototype.hasOwnProperty.call(r, e))
                  throw new Error("Unexpected replacement overlap.");
              }),
            e.unwrap((0, Qv.default)(i, n ? Object.assign(n, r) : r))
          );
        }
      );
    };
  });
var zv = yv,
  $v = gv,
  Qv = Mv;
Object.defineProperty(fv, "__esModule", { value: !0 }),
  (fv.default = function e(t, r) {
    var n = new WeakMap(),
      i = new WeakMap(),
      a = r || (0, Zv.validate)(null);
    return Object.assign(
      function (r) {
        for (
          var i = arguments.length, s = new Array(i > 1 ? i - 1 : 0), o = 1;
          o < i;
          o++
        )
          s[o - 1] = arguments[o];
        if ("string" == typeof r) {
          if (s.length > 1) throw new Error("Unexpected extra params.");
          return ng(
            (0, eg.default)(t, r, (0, Zv.merge)(a, (0, Zv.validate)(s[0])))
          );
        }
        if (Array.isArray(r)) {
          var l = n.get(r);
          return l || ((l = (0, tg.default)(t, r, a)), n.set(r, l)), ng(l(s));
        }
        if ("object" === g(r) && r) {
          if (s.length > 0) throw new Error("Unexpected extra params.");
          return e(t, (0, Zv.merge)(a, (0, Zv.validate)(r)));
        }
        throw new Error("Unexpected template param ".concat(g(r)));
      },
      {
        ast: function (e) {
          for (
            var r = arguments.length, n = new Array(r > 1 ? r - 1 : 0), s = 1;
            s < r;
            s++
          )
            n[s - 1] = arguments[s];
          if ("string" == typeof e) {
            if (n.length > 1) throw new Error("Unexpected extra params.");
            return (0, eg.default)(
              t,
              e,
              (0, Zv.merge)((0, Zv.merge)(a, (0, Zv.validate)(n[0])), rg)
            )();
          }
          if (Array.isArray(e)) {
            var o = i.get(e);
            return (
              o ||
                ((o = (0, tg.default)(t, e, (0, Zv.merge)(a, rg))),
                i.set(e, o)),
              o(n)()
            );
          }
          throw new Error("Unexpected template param ".concat(g(e)));
        },
      }
    );
  });
var Zv = yv,
  eg = vv,
  tg = Gv,
  rg = (0, Zv.validate)({ placeholderPattern: !1 });
function ng(e) {
  var t = "";
  try {
    throw new Error();
  } catch (e) {
    e.stack && (t = e.stack.split("\n").slice(3).join("\n"));
  }
  return function (r) {
    try {
      return e(r);
    } catch (e) {
      throw ((e.stack += "\n    =============\n".concat(t)), e);
    }
  };
}
Object.defineProperty(sv, "__esModule", { value: !0 }),
  (sv.statements =
    sv.statement =
    sv.smart =
    sv.program =
    sv.expression =
    sv.default =
      void 0);
var ig = ov,
  ag = fv,
  sg = (0, ag.default)(ig.smart);
sv.smart = sg;
var og = (0, ag.default)(ig.statement);
sv.statement = og;
var lg = (0, ag.default)(ig.statements);
sv.statements = lg;
var ug = (0, ag.default)(ig.expression);
sv.expression = ug;
var cg = (0, ag.default)(ig.program);
sv.program = cg;
var pg = Object.assign(sg.bind(void 0), {
  smart: sg,
  statement: og,
  statements: lg,
  expression: ug,
  program: cg,
  ast: sg.ast,
});
(sv.default = pg),
  Object.defineProperty(av, "__esModule", { value: !0 }),
  (av.default = function (e) {
    var t,
      r = e.node,
      n = e.parent,
      i = e.scope,
      a = e.id,
      s = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
      o = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
    if (r.id) return;
    if ((!Pg(n) && !Eg(n, { kind: "method" })) || (n.computed && !Sg(n.key))) {
      if (Cg(n)) {
        if (((a = n.id), Tg(a) && !s)) {
          var l = i.parent.getBinding(a.name);
          if (l && l.constant && i.getBinding(a.name) === l)
            return (r.id = yg(a)), void (r.id[fg] = !0);
        }
      } else if (vg(n, { operator: "=" })) a = n.left;
      else if (!a) return;
    } else a = n.key;
    a && Sg(a)
      ? (t = (function (e) {
          if (xg(e)) return "null";
          if (Ag(e)) return "_".concat(e.pattern, "_").concat(e.flags);
          if (wg(e))
            return e.quasis
              .map(function (e) {
                return e.value.raw;
              })
              .join("");
          if (void 0 !== e.value) return e.value + "";
          return "";
        })(a))
      : a && Tg(a) && (t = a.name);
    if (void 0 === t) return;
    if (!o && bg(r) && /[\uD800-\uDFFF]/.test(t)) return;
    t = Ig(t);
    var u = mg(t);
    u[fg] = !0;
    var c = (function (e, t, r) {
      var n = {
          selfAssignment: !1,
          selfReference: !1,
          outerDeclar: r.getBindingIdentifier(t),
          name: t,
        },
        i = r.getOwnBinding(t);
      i
        ? "param" === i.kind && (n.selfReference = !0)
        : (n.outerDeclar || r.hasGlobal(t)) && r.traverse(e, _g, n);
      return n;
    })(r, t, i);
    return (
      (function (e, t, r, n) {
        if (e.selfReference) {
          if (!n.hasBinding(r.name) || n.hasGlobal(r.name)) {
            if (!bg(t)) return;
            var i = Og;
            t.generator && (i = Ng);
            for (
              var a = i({
                  FUNCTION: t,
                  FUNCTION_ID: r,
                  FUNCTION_KEY: n.generateUidIdentifier(r.name),
                }).expression,
                s = a.callee.body.body[0].params,
                o = 0,
                l = (function (e) {
                  var t = e.params.findIndex(function (e) {
                    return gg(e) || kg(e);
                  });
                  return -1 === t ? e.params.length : t;
                })(t);
              o < l;
              o++
            )
              s.push(n.generateUidIdentifier("x"));
            return a;
          }
          n.rename(r.name);
        }
        (t.id = r), (n.getProgramParent().references[r.name] = !0);
      })(c, r, u, i) || r
    );
  });
var hg = sv,
  dg = mc(),
  fg = dg.NOT_LOCAL_BINDING,
  yg = dg.cloneNode,
  mg = dg.identifier,
  vg = dg.isAssignmentExpression,
  gg = dg.isAssignmentPattern,
  bg = dg.isFunction,
  Tg = dg.isIdentifier,
  Sg = dg.isLiteral,
  xg = dg.isNullLiteral,
  Eg = dg.isObjectMethod,
  Pg = dg.isObjectProperty,
  Ag = dg.isRegExpLiteral,
  kg = dg.isRestElement,
  wg = dg.isTemplateLiteral,
  Cg = dg.isVariableDeclarator,
  Ig = dg.toBindingIdentifierName;
var Og = hg.default.statement(
    "\n  (function (FUNCTION_KEY) {\n    function FUNCTION_ID() {\n      return FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    }\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"
  ),
  Ng = hg.default.statement(
    "\n  (function (FUNCTION_KEY) {\n    function* FUNCTION_ID() {\n      return yield* FUNCTION_KEY.apply(this, arguments);\n    }\n\n    FUNCTION_ID.toString = function () {\n      return FUNCTION_KEY.toString();\n    };\n\n    return FUNCTION_ID;\n  })(FUNCTION)\n"
  ),
  _g = {
    "ReferencedIdentifier|BindingIdentifier": function (e, t) {
      e.node.name === t.name &&
        e.scope.getBindingIdentifier(t.name) === t.outerDeclar &&
        ((t.selfReference = !0), e.stop());
    },
  };
Object.defineProperty(iv, "__esModule", { value: !0 }),
  (iv.arrowFunctionToExpression = function () {
    var e = arguments,
      t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},
      r = t.allowInsertArrow,
      n = void 0 === r || r,
      i = t.allowInsertArrowWithRest,
      a = void 0 === i ? n : i,
      s = t.noNewArrows,
      o = void 0 === s ? !(null == (l = e[0]) ? void 0 : l.specCompliant) : s;
    var l;
    if (!this.isArrowFunctionExpression())
      throw this.buildCodeFrameError(
        "Cannot convert non-arrow function to a function expression."
      );
    var u = ub(this, o, n, a),
      c = u.thisBinding,
      p = u.fnPath;
    if (
      (p.ensureBlock(),
      (function (e, t) {
        e.node.type = t;
      })(p, "FunctionExpression"),
      !o)
    ) {
      var h = c ? null : p.scope.generateUidIdentifier("arrowCheckId");
      return (
        h && p.parentPath.scope.push({ id: h, init: Qg([]) }),
        p
          .get("body")
          .unshiftContainer(
            "body",
            Wg(
              Vg(this.hub.addHelper("newArrowCheck"), [
                ab(),
                qg(h ? h.name : c),
              ])
            )
          ),
        p.replaceWith(
          Vg(Gg((0, Mg.default)(this, !0) || p.node, qg("bind")), [
            h ? qg(h.name) : ab(),
          ])
        ),
        p.get("callee.object")
      );
    }
    return p;
  }),
  (iv.ensureBlock = function () {
    var e = this.get("body"),
      t = e.node;
    if (Array.isArray(e))
      throw new Error("Can't convert array path to a block statement");
    if (!t) throw new Error("Can't convert node without a body");
    if (e.isBlockStatement()) return t;
    var r,
      n,
      i = [],
      a = "body";
    e.isStatement()
      ? ((n = "body"), (r = 0), i.push(e.node))
      : ((a += ".body.0"),
        this.isFunction()
          ? ((r = "argument"), i.push(eb(e.node)))
          : ((r = "expression"), i.push(Wg(e.node))));
    this.node.body = Ug(i);
    var s = this.get(a);
    return e.setup(s, n ? s.node[n] : s.node, n, r), this.node;
  }),
  (iv.toComputedKey = function () {
    var e;
    if (this.isMemberExpression()) e = this.node.property;
    else {
      if (!this.isProperty() && !this.isMethod())
        throw new ReferenceError("todo");
      e = this.node.key;
    }
    this.node.computed || (Hg(e) && (e = nb(e.name)));
    return e;
  }),
  (iv.unwrapFunctionEnvironment = function () {
    if (
      !this.isArrowFunctionExpression() &&
      !this.isFunctionExpression() &&
      !this.isFunctionDeclaration()
    )
      throw this.buildCodeFrameError(
        "Can only unwrap the environment of a function."
      );
    ub(this);
  });
var Dg = mc(),
  Lg = ry,
  Mg = av,
  jg = Qd,
  Fg = Dg.arrowFunctionExpression,
  Bg = Dg.assignmentExpression,
  Rg = Dg.binaryExpression,
  Ug = Dg.blockStatement,
  Vg = Dg.callExpression,
  Kg = Dg.conditionalExpression,
  Wg = Dg.expressionStatement,
  qg = Dg.identifier,
  Hg = Dg.isIdentifier,
  Yg = Dg.jsxIdentifier,
  Jg = Dg.logicalExpression,
  Xg = Dg.LOGICAL_OPERATORS,
  Gg = Dg.memberExpression,
  zg = Dg.metaProperty,
  $g = Dg.numericLiteral,
  Qg = Dg.objectExpression,
  Zg = Dg.restElement,
  eb = Dg.returnStatement,
  tb = Dg.sequenceExpression,
  rb = Dg.spreadElement,
  nb = Dg.stringLiteral,
  ib = Dg.super,
  ab = Dg.thisExpression,
  sb = Dg.toExpression,
  ob = Dg.unaryExpression;
iv.arrowFunctionToShadowed = function () {
  this.isArrowFunctionExpression() && this.arrowFunctionToExpression();
};
var lb = (0, jg.merge)([
  {
    CallExpression: function (e, t) {
      var r = t.allSuperCalls;
      e.get("callee").isSuper() && r.push(e);
    },
  },
  Lg.default,
]);
function ub(e) {
  var t,
    r = !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1],
    n = !(arguments.length > 2 && void 0 !== arguments[2]) || arguments[2],
    i = !(arguments.length > 3 && void 0 !== arguments[3]) || arguments[3],
    a = e.findParent(function (e) {
      return e.isArrowFunctionExpression()
        ? (null != t || (t = e), !1)
        : e.isFunction() ||
            e.isProgram() ||
            e.isClassProperty({ static: !1 }) ||
            e.isClassPrivateProperty({ static: !1 });
    }),
    s = a.isClassMethod({ kind: "constructor" });
  if (a.isClassProperty() || a.isClassPrivateProperty())
    if (t) a = t;
    else {
      if (!n)
        throw e.buildCodeFrameError(
          "Unable to transform arrow inside class property"
        );
      e.replaceWith(Vg(Fg([], sb(e.node)), [])),
        (a = e.get("callee")),
        (e = a.get("body"));
    }
  var o,
    l = (function (e) {
      var t = [],
        r = [],
        n = [],
        i = [],
        a = [];
      return (
        e.traverse(db, {
          thisPaths: t,
          argumentsPaths: r,
          newTargetPaths: n,
          superProps: i,
          superCalls: a,
        }),
        {
          thisPaths: t,
          argumentsPaths: r,
          newTargetPaths: n,
          superProps: i,
          superCalls: a,
        }
      );
    })(e),
    u = l.thisPaths,
    c = l.argumentsPaths,
    p = l.newTargetPaths,
    h = l.superProps,
    d = l.superCalls;
  if (s && d.length > 0) {
    if (!n)
      throw d[0].buildCodeFrameError(
        "When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super()` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration."
      );
    if (!i)
      throw d[0].buildCodeFrameError(
        "When using '@babel/plugin-transform-parameters', it's not possible to compile `super()` in an arrow function with default or rest parameters without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration."
      );
    var f = [];
    a.traverse(lb, { allSuperCalls: f });
    var y = (function (e) {
      return hb(e, "supercall", function () {
        var t = e.scope.generateUidIdentifier("args");
        return Fg([Zg(t)], Vg(ib(), [rb(qg(t.name))]));
      });
    })(a);
    f.forEach(function (e) {
      var t = qg(y);
      (t.loc = e.node.callee.loc), e.get("callee").replaceWith(t);
    });
  }
  if (c.length > 0) {
    var m = hb(a, "arguments", function () {
      var e = function () {
        return qg("arguments");
      };
      return a.scope.path.isProgram()
        ? Kg(
            Rg("===", ob("typeof", e()), nb("undefined")),
            a.scope.buildUndefinedNode(),
            e()
          )
        : e();
    });
    c.forEach(function (e) {
      var t = qg(m);
      (t.loc = e.node.loc), e.replaceWith(t);
    });
  }
  if (p.length > 0) {
    var v = hb(a, "newtarget", function () {
      return zg(qg("new"), qg("target"));
    });
    p.forEach(function (e) {
      var t = qg(v);
      (t.loc = e.node.loc), e.replaceWith(t);
    });
  }
  if (h.length > 0) {
    if (!n)
      throw h[0].buildCodeFrameError(
        "When using '@babel/plugin-transform-arrow-functions', it's not possible to compile `super.prop` in an arrow function without compiling classes.\nPlease add '@babel/plugin-transform-classes' to your Babel configuration."
      );
    var g = h.reduce(function (e, t) {
      return e.concat(
        (function (e) {
          if (
            e.parentPath.isAssignmentExpression() &&
            "=" !== e.parentPath.node.operator
          ) {
            var t = e.parentPath,
              r = t.node.operator.slice(0, -1),
              n = t.node.right,
              i = (function (e) {
                return Xg.includes(e);
              })(r);
            if (e.node.computed) {
              var a = e.scope.generateDeclaredUidIdentifier("tmp"),
                s = e.node.object,
                o = e.node.property;
              t.get("left").replaceWith(Gg(s, Bg("=", a, o), !0)),
                t
                  .get("right")
                  .replaceWith(f(i ? "=" : r, Gg(s, qg(a.name), !0), n));
            } else {
              var l = e.node.object,
                u = e.node.property;
              t.get("left").replaceWith(Gg(l, u)),
                t
                  .get("right")
                  .replaceWith(f(i ? "=" : r, Gg(l, qg(u.name)), n));
            }
            return (
              i
                ? t.replaceWith(Jg(r, t.node.left, t.node.right))
                : (t.node.operator = "="),
              [t.get("left"), t.get("right").get("left")]
            );
          }
          if (e.parentPath.isUpdateExpression()) {
            var c = e.parentPath,
              p = e.scope.generateDeclaredUidIdentifier("tmp"),
              h = e.node.computed
                ? e.scope.generateDeclaredUidIdentifier("prop")
                : null,
              d = [
                Bg(
                  "=",
                  p,
                  Gg(
                    e.node.object,
                    h ? Bg("=", h, e.node.property) : e.node.property,
                    e.node.computed
                  )
                ),
                Bg(
                  "=",
                  Gg(
                    e.node.object,
                    h ? qg(h.name) : e.node.property,
                    e.node.computed
                  ),
                  Rg(e.parentPath.node.operator[0], qg(p.name), $g(1))
                ),
              ];
            return (
              e.parentPath.node.prefix || d.push(qg(p.name)),
              c.replaceWith(tb(d)),
              [c.get("expressions.0.right"), c.get("expressions.1.left")]
            );
          }
          return [e];
          function f(e, t, r) {
            return "=" === e ? Bg("=", t, r) : Rg(e, t, r);
          }
        })(t)
      );
    }, []);
    g.forEach(function (e) {
      var t = e.node.computed ? "" : e.get("property").node.name,
        r = e.parentPath,
        n = r.isAssignmentExpression({ left: e.node }),
        i = r.isCallExpression({ callee: e.node }),
        s = r.isTaggedTemplateExpression({ tag: e.node }),
        o = (function (e, t, r) {
          var n = t ? "set" : "get";
          return hb(
            e,
            "superprop_".concat(n, ":").concat(r || ""),
            function () {
              var n,
                i = [];
              if (r) n = Gg(ib(), qg(r));
              else {
                var a = e.scope.generateUidIdentifier("prop");
                i.unshift(a), (n = Gg(ib(), qg(a.name), !0));
              }
              if (t) {
                var s = e.scope.generateUidIdentifier("value");
                i.push(s), (n = Bg("=", n, qg(s.name)));
              }
              return Fg(i, n);
            }
          );
        })(a, n, t),
        l = [];
      if ((e.node.computed && l.push(e.get("property").node), n)) {
        var c = r.node.right;
        l.push(c);
      }
      var p = Vg(qg(o), l);
      i
        ? (r.unshiftContainer("arguments", ab()),
          e.replaceWith(Gg(p, qg("call"))),
          u.push(r.get("arguments.0")))
        : n
        ? r.replaceWith(p)
        : s
        ? (e.replaceWith(Vg(Gg(p, qg("bind"), !1), [ab()])),
          u.push(e.get("arguments.0")))
        : e.replaceWith(p);
    });
  }
  return (
    (u.length > 0 || !r) &&
      ((o = (function (e, t) {
        return hb(e, "this", function (r) {
          if (!t || !cb(e)) return ab();
          e.traverse(pb, { supers: new WeakSet(), thisBinding: r });
        });
      })(a, s)),
      (r || (s && cb(a))) &&
        (u.forEach(function (e) {
          var t = e.isJSX() ? Yg(o) : qg(o);
          (t.loc = e.node.loc), e.replaceWith(t);
        }),
        r || (o = null))),
    { thisBinding: o, fnPath: e }
  );
}
function cb(e) {
  return e.isClassMethod() && !!e.parentPath.parentPath.node.superClass;
}
var pb = (0, jg.merge)([
  {
    CallExpression: function (e, t) {
      var r = t.supers,
        n = t.thisBinding;
      e.get("callee").isSuper() &&
        (r.has(e.node) ||
          (r.add(e.node),
          e.replaceWithMultiple([e.node, Bg("=", qg(n), qg("this"))])));
    },
  },
  Lg.default,
]);
function hb(e, t, r) {
  var n = "binding:" + t,
    i = e.getData(n);
  if (!i) {
    var a = e.scope.generateUidIdentifier(t);
    (i = a.name), e.setData(n, i), e.scope.push({ id: a, init: r(i) });
  }
  return i;
}
var db = (0, jg.merge)([
  {
    ThisExpression: function (e, t) {
      t.thisPaths.push(e);
    },
    JSXIdentifier: function (e, t) {
      var r = t.thisPaths;
      "this" === e.node.name &&
        (e.parentPath.isJSXMemberExpression({ object: e.node }) ||
          e.parentPath.isJSXOpeningElement({ name: e.node })) &&
        r.push(e);
    },
    CallExpression: function (e, t) {
      var r = t.superCalls;
      e.get("callee").isSuper() && r.push(e);
    },
    MemberExpression: function (e, t) {
      var r = t.superProps;
      e.get("object").isSuper() && r.push(e);
    },
    Identifier: function (e, t) {
      var r = t.argumentsPaths;
      if (e.isReferencedIdentifier({ name: "arguments" })) {
        var n = e.scope;
        do {
          if (n.hasOwnBinding("arguments")) return void n.rename("arguments");
          if (n.path.isFunction() && !n.path.isArrowFunctionExpression()) break;
        } while ((n = n.parent));
        r.push(e);
      }
    },
    MetaProperty: function (e, t) {
      var r = t.newTargetPaths;
      e.get("meta").isIdentifier({ name: "new" }) &&
        e.get("property").isIdentifier({ name: "target" }) &&
        r.push(e);
    },
  },
  Lg.default,
]);
var fb = {};
function yb(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return mb(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return mb(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function mb(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(fb, "__esModule", { value: !0 }),
  (fb._guessExecutionStatusRelativeTo = function (e) {
    return Db(this, e, new Map());
  }),
  (fb._resolve = function (e, t) {
    if (t && t.indexOf(this) >= 0) return;
    if (((t = t || []).push(this), this.isVariableDeclarator())) {
      if (this.get("id").isIdentifier()) return this.get("init").resolve(e, t);
    } else if (this.isReferencedIdentifier()) {
      var r = this.scope.getBinding(this.node.name);
      if (!r) return;
      if (!r.constant) return;
      if ("module" === r.kind) return;
      if (r.path !== this) {
        var n = r.path.resolve(e, t);
        if (
          this.find(function (e) {
            return e.node === n.node;
          })
        )
          return;
        return n;
      }
    } else {
      if (this.isTypeCastExpression())
        return this.get("expression").resolve(e, t);
      if (e && this.isMemberExpression()) {
        var i = this.toComputedKey();
        if (!Eb(i)) return;
        var a = i.value,
          s = this.get("object").resolve(e, t);
        if (s.isObjectExpression()) {
          var o,
            l = yb(s.get("properties"));
          try {
            for (l.s(); !(o = l.n()).done; ) {
              var u = o.value;
              if (u.isProperty()) {
                var c = u.get("key"),
                  p = u.isnt("computed") && c.isIdentifier({ name: a });
                if ((p = p || c.isLiteral({ value: a })))
                  return u.get("value").resolve(e, t);
              }
            }
          } catch (e) {
            l.e(e);
          } finally {
            l.f();
          }
        } else if (s.isArrayExpression() && !isNaN(+a)) {
          var h = s.get("elements")[a];
          if (h) return h.resolve(e, t);
        }
      }
    }
  }),
  (fb.canHaveVariableDeclarationOrExpression = function () {
    return (
      ("init" === this.key || "left" === this.key) && this.parentPath.isFor()
    );
  }),
  (fb.canSwapBetweenExpressionAndStatement = function (e) {
    if ("body" !== this.key || !this.parentPath.isArrowFunctionExpression())
      return !1;
    if (this.isExpression()) return Tb(e);
    if (this.isBlockStatement()) return Sb(e);
    return !1;
  }),
  (fb.equals = function (e, t) {
    return this.node[e] === t;
  }),
  (fb.getSource = function () {
    var e = this.node;
    if (e.end) {
      var t = this.hub.getCode();
      if (t) return t.slice(e.start, e.end);
    }
    return "";
  }),
  (fb.has = wb),
  (fb.is = void 0),
  (fb.isCompletionRecord = function (e) {
    var t = this,
      r = !0;
    do {
      var n = t,
        i = n.type,
        a = n.container;
      if (!r && (t.isFunction() || "StaticBlock" === i)) return !!e;
      if (((r = !1), Array.isArray(a) && t.key !== a.length - 1)) return !1;
    } while ((t = t.parentPath) && !t.isProgram() && !t.isDoExpression());
    return !0;
  }),
  (fb.isConstantExpression = function () {
    if (this.isIdentifier()) {
      var e = this.scope.getBinding(this.node.name);
      return !!e && e.constant;
    }
    if (this.isLiteral())
      return (
        !this.isRegExpLiteral() &&
        (!this.isTemplateLiteral() ||
          this.get("expressions").every(function (e) {
            return e.isConstantExpression();
          }))
      );
    if (this.isUnaryExpression())
      return (
        "void" === this.node.operator &&
        this.get("argument").isConstantExpression()
      );
    if (this.isBinaryExpression()) {
      var t = this.node.operator;
      return (
        "in" !== t &&
        "instanceof" !== t &&
        this.get("left").isConstantExpression() &&
        this.get("right").isConstantExpression()
      );
    }
    return !1;
  }),
  (fb.isInStrictMode = function () {
    var e = (this.isProgram() ? this : this.parentPath).find(function (e) {
      if (e.isProgram({ sourceType: "module" })) return !0;
      if (e.isClass()) return !0;
      if (e.isArrowFunctionExpression() && !e.get("body").isBlockStatement())
        return !1;
      var t;
      if (e.isFunction()) t = e.node.body;
      else {
        if (!e.isProgram()) return !1;
        t = e.node;
      }
      var r,
        n = yb(t.directives);
      try {
        for (n.s(); !(r = n.n()).done; ) {
          if ("use strict" === r.value.value.value) return !0;
        }
      } catch (e) {
        n.e(e);
      } finally {
        n.f();
      }
    });
    return !!e;
  }),
  (fb.isNodeType = function (e) {
    return Ab(this.type, e);
  }),
  (fb.isStatementOrBlock = function () {
    return (
      !this.parentPath.isLabeledStatement() &&
      !Tb(this.container) &&
      gb.includes(this.key)
    );
  }),
  (fb.isStatic = function () {
    return this.scope.isStatic(this.node);
  }),
  (fb.isnt = function (e) {
    return !this.has(e);
  }),
  (fb.matchesPattern = function (e, t) {
    return kb(this.node, e, t);
  }),
  (fb.referencesImport = function (e, t) {
    if (!this.isReferencedIdentifier()) {
      if (
        (this.isJSXMemberExpression() && this.node.property.name === t) ||
        ((this.isMemberExpression() || this.isOptionalMemberExpression()) &&
          (this.node.computed
            ? Pb(this.node.property, { value: t })
            : this.node.property.name === t))
      ) {
        var r = this.get("object");
        return r.isReferencedIdentifier() && r.referencesImport(e, "*");
      }
      return !1;
    }
    var n = this.scope.getBinding(this.node.name);
    if (!n || "module" !== n.kind) return !1;
    var i = n.path,
      a = i.parentPath;
    if (!a.isImportDeclaration()) return !1;
    if (a.node.source.value !== e) return !1;
    if (!t) return !0;
    if (i.isImportDefaultSpecifier() && "default" === t) return !0;
    if (i.isImportNamespaceSpecifier() && "*" === t) return !0;
    if (i.isImportSpecifier() && xb(i.node.imported, { name: t })) return !0;
    return !1;
  }),
  (fb.resolve = function (e, t) {
    return this._resolve(e, t) || this;
  }),
  (fb.willIMaybeExecuteBefore = function (e) {
    return "after" !== this._guessExecutionStatusRelativeTo(e);
  });
var vb = mc(),
  gb = vb.STATEMENT_OR_BLOCK_KEYS,
  bb = vb.VISITOR_KEYS,
  Tb = vb.isBlockStatement,
  Sb = vb.isExpression,
  xb = vb.isIdentifier,
  Eb = vb.isLiteral,
  Pb = vb.isStringLiteral,
  Ab = vb.isType,
  kb = vb.matchesPattern;
function wb(e) {
  var t = this.node && this.node[e];
  return t && Array.isArray(t) ? !!t.length : !!t;
}
var Cb = wb;
function Ib(e) {
  return e.isProgram()
    ? e
    : (
        e.parentPath.scope.getFunctionParent() ||
        e.parentPath.scope.getProgramParent()
      ).path;
}
function Ob(e, t) {
  switch (e) {
    case "LogicalExpression":
    case "AssignmentPattern":
      return "right" === t;
    case "ConditionalExpression":
    case "IfStatement":
      return "consequent" === t || "alternate" === t;
    case "WhileStatement":
    case "DoWhileStatement":
    case "ForInStatement":
    case "ForOfStatement":
      return "body" === t;
    case "ForStatement":
      return "body" === t || "update" === t;
    case "SwitchStatement":
      return "cases" === t;
    case "TryStatement":
      return "handler" === t;
    case "OptionalMemberExpression":
      return "property" === t;
    case "OptionalCallExpression":
      return "arguments" === t;
    default:
      return !1;
  }
}
function Nb(e, t) {
  for (var r = 0; r < t; r++) {
    var n = e[r];
    if (Ob(n.parent.type, n.parentKey)) return !0;
  }
  return !1;
}
fb.is = Cb;
var _b = Symbol();
function Db(e, t, r) {
  var n = { this: Ib(e), target: Ib(t) };
  if (n.target.node !== n.this.node)
    return (function (e, t, r) {
      var n,
        i = r.get(e.node);
      if (i) {
        if ((n = i.get(t.node))) return n === _b ? "unknown" : n;
      } else r.set(e.node, (i = new Map()));
      i.set(t.node, _b);
      var a = (function (e, t, r) {
        if (!t.isFunctionDeclaration())
          return "before" === Db(e, t, r) ? "before" : "unknown";
        if (t.parentPath.isExportDeclaration()) return "unknown";
        var n = t.scope.getBinding(t.node.id.name);
        if (!n.references) return "before";
        var i,
          a,
          s = n.referencePaths,
          o = yb(s);
        try {
          for (o.s(); !(a = o.n()).done; ) {
            var l = a.value;
            if (
              !!!l.find(function (e) {
                return e.node === t.node;
              })
            ) {
              if ("callee" !== l.key || !l.parentPath.isCallExpression())
                return "unknown";
              var u = Db(e, l, r);
              if (i && i !== u) return "unknown";
              i = u;
            }
          }
        } catch (e) {
          o.e(e);
        } finally {
          o.f();
        }
        return i;
      })(e, t, r);
      return i.set(t.node, a), a;
    })(e, n.target, r);
  var i,
    a = { target: t.getAncestry(), this: e.getAncestry() };
  if (a.target.indexOf(e) >= 0) return "after";
  if (a.this.indexOf(t) >= 0) return "before";
  for (var s = { target: 0, this: 0 }; !i && s.this < a.this.length; ) {
    var o = a.this[s.this];
    (s.target = a.target.indexOf(o)), s.target >= 0 ? (i = o) : s.this++;
  }
  if (!i)
    throw new Error(
      "Internal Babel error - The two compared nodes don't appear to belong to the same program."
    );
  if (Nb(a.this, s.this - 1) || Nb(a.target, s.target - 1)) return "unknown";
  var l = { this: a.this[s.this - 1], target: a.target[s.target - 1] };
  if (
    l.target.listKey &&
    l.this.listKey &&
    l.target.container === l.this.container
  )
    return l.target.key > l.this.key ? "before" : "after";
  var u = bb[i.type],
    c = u.indexOf(l.this.parentKey);
  return u.indexOf(l.target.parentKey) > c ? "before" : "after";
}
var Lb,
  Mb = {};
function jb(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Fb(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Fb(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Fb(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
var Bb = {},
  Rb = {};
Object.defineProperty(Rb, "__esModule", { value: !0 }), (Rb.hooks = void 0);
var Ub;
function Vb(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Kb(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Kb(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Kb(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Rb.hooks = [
  function (e, t) {
    if (
      ("test" === e.key && (t.isWhile() || t.isSwitchCase())) ||
      ("declaration" === e.key && t.isExportDeclaration()) ||
      ("body" === e.key && t.isLabeledStatement()) ||
      ("declarations" === e.listKey &&
        t.isVariableDeclaration() &&
        1 === t.node.declarations.length) ||
      ("expression" === e.key && t.isExpressionStatement())
    )
      return t.remove(), !0;
  },
  function (e, t) {
    if (t.isSequenceExpression() && 1 === t.node.expressions.length)
      return t.replaceWith(t.node.expressions[0]), !0;
  },
  function (e, t) {
    if (t.isBinary())
      return (
        "left" === e.key
          ? t.replaceWith(t.node.right)
          : t.replaceWith(t.node.left),
        !0
      );
  },
  function (e, t) {
    if (
      (t.isIfStatement() && "consequent" === e.key) ||
      ("body" === e.key && (t.isLoop() || t.isArrowFunctionExpression()))
    )
      return e.replaceWith({ type: "BlockStatement", body: [] }), !0;
  },
];
var Wb = {},
  qb = {};
function Hb(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return Yb(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return Yb(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function Yb(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
Object.defineProperty(qb, "__esModule", { value: !0 }), (qb.default = void 0);
var Jb,
  Xb = mc(),
  Gb = Xb,
  zb = Xb.react,
  $b = Gb.cloneNode,
  Qb = Gb.jsxExpressionContainer,
  Zb = Gb.variableDeclaration,
  eT = Gb.variableDeclarator,
  tT = {
    ReferencedIdentifier: function (e, t) {
      if (
        !e.isJSXIdentifier() ||
        !zb.isCompatTag(e.node.name) ||
        e.parentPath.isJSXMemberExpression()
      ) {
        if ("this" === e.node.name) {
          var r = e.scope;
          do {
            if (r.path.isFunction() && !r.path.isArrowFunctionExpression())
              break;
          } while ((r = r.parent));
          r && t.breakOnScopePaths.push(r.path);
        }
        var n = e.scope.getBinding(e.node.name);
        if (n) {
          var i,
            a = Hb(n.constantViolations);
          try {
            for (a.s(); !(i = a.n()).done; ) {
              if (i.value.scope !== n.path.scope)
                return (t.mutableBinding = !0), void e.stop();
            }
          } catch (e) {
            a.e(e);
          } finally {
            a.f();
          }
          n === t.scope.getBinding(e.node.name) &&
            (t.bindings[e.node.name] = n);
        }
      }
    },
  },
  rT = (function () {
    function e(t, r) {
      E(this, e),
        (this.breakOnScopePaths = void 0),
        (this.bindings = void 0),
        (this.mutableBinding = void 0),
        (this.scopes = void 0),
        (this.scope = void 0),
        (this.path = void 0),
        (this.attachAfter = void 0),
        (this.breakOnScopePaths = []),
        (this.bindings = {}),
        (this.mutableBinding = !1),
        (this.scopes = []),
        (this.scope = r),
        (this.path = t),
        (this.attachAfter = !1);
    }
    return (
      A(e, [
        {
          key: "isCompatibleScope",
          value: function (e) {
            for (var t = 0, r = Object.keys(this.bindings); t < r.length; t++) {
              var n = r[t],
                i = this.bindings[n];
              if (!e.bindingIdentifierEquals(n, i.identifier)) return !1;
            }
            return !0;
          },
        },
        {
          key: "getCompatibleScopes",
          value: function () {
            var e = this.path.scope;
            do {
              if (!this.isCompatibleScope(e)) break;
              if (
                (this.scopes.push(e),
                this.breakOnScopePaths.indexOf(e.path) >= 0)
              )
                break;
            } while ((e = e.parent));
          },
        },
        {
          key: "getAttachmentPath",
          value: function () {
            var e = this._getAttachmentPath();
            if (e) {
              var t = e.scope;
              if (
                (t.path === e && (t = e.scope.parent),
                t.path.isProgram() || t.path.isFunction())
              )
                for (
                  var r = 0, n = Object.keys(this.bindings);
                  r < n.length;
                  r++
                ) {
                  var i = n[r];
                  if (t.hasOwnBinding(i)) {
                    var a = this.bindings[i];
                    if ("param" !== a.kind && "params" !== a.path.parentKey)
                      if (
                        this.getAttachmentParentForPath(a.path).key >= e.key
                      ) {
                        (this.attachAfter = !0), (e = a.path);
                        var s,
                          o = Hb(a.constantViolations);
                        try {
                          for (o.s(); !(s = o.n()).done; ) {
                            var l = s.value;
                            this.getAttachmentParentForPath(l).key > e.key &&
                              (e = l);
                          }
                        } catch (e) {
                          o.e(e);
                        } finally {
                          o.f();
                        }
                      }
                  }
                }
              return e;
            }
          },
        },
        {
          key: "_getAttachmentPath",
          value: function () {
            var e = this.scopes.pop();
            if (e)
              if (e.path.isFunction()) {
                if (!this.hasOwnParamBindings(e))
                  return this.getNextScopeAttachmentParent();
                if (this.scope === e) return;
                for (
                  var t = e.path.get("body").get("body"), r = 0;
                  r < t.length;
                  r++
                )
                  if (!t[r].node._blockHoist) return t[r];
              } else if (e.path.isProgram())
                return this.getNextScopeAttachmentParent();
          },
        },
        {
          key: "getNextScopeAttachmentParent",
          value: function () {
            var e = this.scopes.pop();
            if (e) return this.getAttachmentParentForPath(e.path);
          },
        },
        {
          key: "getAttachmentParentForPath",
          value: function (e) {
            do {
              if (
                !e.parentPath ||
                (Array.isArray(e.container) && e.isStatement())
              )
                return e;
            } while ((e = e.parentPath));
          },
        },
        {
          key: "hasOwnParamBindings",
          value: function (e) {
            for (var t = 0, r = Object.keys(this.bindings); t < r.length; t++) {
              var n = r[t];
              if (e.hasOwnBinding(n)) {
                var i = this.bindings[n];
                if ("param" === i.kind && i.constant) return !0;
              }
            }
            return !1;
          },
        },
        {
          key: "run",
          value: function () {
            if ((this.path.traverse(tT, this), !this.mutableBinding)) {
              this.getCompatibleScopes();
              var e = this.getAttachmentPath();
              if (
                e &&
                e.getFunctionParent() !== this.path.getFunctionParent()
              ) {
                var t = e.scope.generateUidIdentifier("ref"),
                  r = eT(t, this.path.node),
                  n = H(
                    e[this.attachAfter ? "insertAfter" : "insertBefore"]([
                      e.isVariableDeclarator() ? r : Zb("var", [r]),
                    ]),
                    1
                  )[0],
                  i = this.path.parentPath;
                return (
                  i.isJSXElement() &&
                    this.path.container === i.node.children &&
                    (t = Qb(t)),
                  this.path.replaceWith($b(t)),
                  e.isVariableDeclarator()
                    ? n.get("init")
                    : n.get("declarations.0.init")
                );
              }
            }
          },
        },
      ]),
      e
    );
  })();
function nT(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return iT(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return iT(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function iT(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function aT() {
  if (Jb) return Wb;
  (Jb = 1),
    Object.defineProperty(Wb, "__esModule", { value: !0 }),
    (Wb._containerInsert = function (e, t) {
      var r;
      this.updateSiblingKeys(e, t.length);
      var n = [];
      (r = this.container).splice.apply(r, [e, 0].concat(K(t)));
      for (var i = 0; i < t.length; i++) {
        var a = e + i,
          s = this.getSibling(a);
        n.push(s),
          this.context && this.context.queue && s.pushContext(this.context);
      }
      for (var o = this._getQueueContexts(), l = 0, u = n; l < u.length; l++) {
        var c = u[l];
        c.setScope(), c.debug("Inserted.");
        var p,
          h = nT(o);
        try {
          for (h.s(); !(p = h.n()).done; ) {
            p.value.maybeQueue(c, !0);
          }
        } catch (e) {
          h.e(e);
        } finally {
          h.f();
        }
      }
      return n;
    }),
    (Wb._containerInsertAfter = function (e) {
      return this._containerInsert(this.key + 1, e);
    }),
    (Wb._containerInsertBefore = function (e) {
      return this._containerInsert(this.key, e);
    }),
    (Wb._verifyNodeList = function (e) {
      if (!e) return [];
      Array.isArray(e) || (e = [e]);
      for (var t = 0; t < e.length; t++) {
        var n = e[t],
          i = void 0;
        if (
          (n
            ? "object" !== g(n)
              ? (i = "contains a non-object node")
              : n.type
              ? n instanceof r.default &&
                (i = "has a NodePath when it expected a raw object")
              : (i = "without a type")
            : (i = "has falsy node"),
          i)
        ) {
          var a = Array.isArray(n) ? "array" : g(n);
          throw new Error(
            "Node list "
              .concat(i, " with the index of ")
              .concat(t, " and type of ")
              .concat(a)
          );
        }
      }
      return e;
    }),
    (Wb.hoist = function () {
      var e =
          arguments.length > 0 && void 0 !== arguments[0]
            ? arguments[0]
            : this.scope,
        r = new t.default(this, e);
      return r.run();
    }),
    (Wb.insertAfter = function (e) {
      if ((this._assertUnremoved(), this.isSequenceExpression()))
        return T(this.get("expressions")).insertAfter(e);
      var t = this._verifyNodeList(e),
        r = this.parentPath,
        n = this.parent;
      if (
        r.isExpressionStatement() ||
        r.isLabeledStatement() ||
        d(n) ||
        (r.isExportDefaultDeclaration() && this.isDeclaration())
      )
        return r.insertAfter(
          t.map(function (e) {
            return f(e) ? c(e) : e;
          })
        );
      if (
        (this.isNodeType("Expression") &&
          !this.isJSXElement() &&
          !r.isJSXElement()) ||
        (r.isForStatement() && "init" === this.key)
      ) {
        if (this.node) {
          var m = this.node,
            g = this.scope;
          if (g.path.isPattern())
            return (
              a(m),
              this.replaceWith(l(i([], m), [])),
              this.get("callee.body").insertAfter(t),
              [this]
            );
          if (S(this)) t.unshift(m);
          else if (h(m) && v(m.callee)) t.unshift(m), t.push(b());
          else if (
            (function (e, t) {
              if (!p(e) || !y(e.left)) return !1;
              var r = t.getBlockParent();
              return (
                r.hasOwnBinding(e.left.name) &&
                r.getOwnBinding(e.left.name).constantViolations.length <= 1
              );
            })(m, g)
          )
            t.unshift(m), t.push(u(m.left));
          else if (g.isPure(m, !0)) t.push(m);
          else {
            r.isMethod({ computed: !0, key: m }) && (g = g.parent);
            var x = g.generateDeclaredUidIdentifier();
            t.unshift(c(s("=", u(x), m))), t.push(c(u(x)));
          }
        }
        return this.replaceExpressionWithStatements(t);
      }
      if (Array.isArray(this.container)) return this._containerInsertAfter(t);
      if (this.isStatementOrBlock()) {
        var E = this.node,
          P = E && (!this.isExpressionStatement() || null != E.expression);
        return this.replaceWith(o(P ? [E] : [])), this.pushContainer("body", t);
      }
      throw new Error(
        "We don't know what to do with this node type. We were previously a Statement but we can't fit in here?"
      );
    }),
    (Wb.insertBefore = function (e) {
      this._assertUnremoved();
      var t = this._verifyNodeList(e),
        r = this.parentPath,
        n = this.parent;
      if (
        r.isExpressionStatement() ||
        r.isLabeledStatement() ||
        d(n) ||
        (r.isExportDefaultDeclaration() && this.isDeclaration())
      )
        return r.insertBefore(t);
      if (
        (this.isNodeType("Expression") && !this.isJSXElement()) ||
        (r.isForStatement() && "init" === this.key)
      )
        return (
          this.node && t.push(this.node),
          this.replaceExpressionWithStatements(t)
        );
      if (Array.isArray(this.container)) return this._containerInsertBefore(t);
      if (this.isStatementOrBlock()) {
        var i = this.node,
          a = i && (!this.isExpressionStatement() || null != i.expression);
        return (
          this.replaceWith(o(a ? [i] : [])), this.unshiftContainer("body", t)
        );
      }
      throw new Error(
        "We don't know what to do with this node type. We were previously a Statement but we can't fit in here?"
      );
    }),
    (Wb.pushContainer = function (e, t) {
      this._assertUnremoved();
      var n = this._verifyNodeList(t),
        i = this.node[e],
        a = r.default
          .get({
            parentPath: this,
            parent: this.node,
            container: i,
            listKey: e,
            key: i.length,
          })
          .setContext(this.context);
      return a.replaceWithMultiple(n);
    }),
    (Wb.unshiftContainer = function (e, t) {
      this._assertUnremoved(), (t = this._verifyNodeList(t));
      var n = r.default
        .get({
          parentPath: this,
          parent: this.node,
          container: this.node[e],
          listKey: e,
          key: 0,
        })
        .setContext(this.context);
      return n._containerInsertBefore(t);
    }),
    (Wb.updateSiblingKeys = function (t, r) {
      if (!this.parent) return;
      var n,
        i = nT(e.path.get(this.parent));
      try {
        for (i.s(); !(n = i.n()).done; ) {
          var a = H(n.value, 2)[1];
          a.key >= t && (a.key += r);
        }
      } catch (e) {
        i.e(e);
      } finally {
        i.f();
      }
    });
  var e = bf,
    t = qb,
    r = HT(),
    n = mc(),
    i = n.arrowFunctionExpression,
    a = n.assertExpression,
    s = n.assignmentExpression,
    o = n.blockStatement,
    l = n.callExpression,
    u = n.cloneNode,
    c = n.expressionStatement,
    p = n.isAssignmentExpression,
    h = n.isCallExpression,
    d = n.isExportNamedDeclaration,
    f = n.isExpression,
    y = n.isIdentifier,
    m = n.isSequenceExpression,
    v = n.isSuper,
    b = n.thisExpression;
  var T = function (e) {
    return e[e.length - 1];
  };
  function S(e) {
    return (
      m(e.parent) && (T(e.parent.expressions) !== e.node || S(e.parentPath))
    );
  }
  return Wb;
}
qb.default = rT;
var sT,
  oT = {};
function lT(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return uT(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return uT(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function uT(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function cT() {
  if (sT) return oT;
  (sT = 1),
    Object.defineProperty(oT, "__esModule", { value: !0 }),
    (oT._getKey = function (t, r) {
      var n = this,
        i = this.node,
        a = i[t];
      return Array.isArray(a)
        ? a.map(function (s, o) {
            return e.default
              .get({
                listKey: t,
                parentPath: n,
                parent: i,
                container: a,
                key: o,
              })
              .setContext(r);
          })
        : e.default
            .get({ parentPath: this, parent: i, container: i, key: t })
            .setContext(r);
    }),
    (oT._getPattern = function (e, t) {
      var r,
        n = this,
        i = lT(e);
      try {
        for (i.s(); !(r = i.n()).done; ) {
          var a = r.value;
          n = "." === a ? n.parentPath : Array.isArray(n) ? n[a] : n.get(a, t);
        }
      } catch (e) {
        i.e(e);
      } finally {
        i.f();
      }
      return n;
    }),
    (oT.get = function (e) {
      var t =
        !(arguments.length > 1 && void 0 !== arguments[1]) || arguments[1];
      !0 === t && (t = this.context);
      var r = e.split(".");
      return 1 === r.length ? this._getKey(e, t) : this._getPattern(r, t);
    }),
    (oT.getAllNextSiblings = function () {
      var e = this.key,
        t = this.getSibling(++e),
        r = [];
      for (; t.node; ) r.push(t), (t = this.getSibling(++e));
      return r;
    }),
    (oT.getAllPrevSiblings = function () {
      var e = this.key,
        t = this.getSibling(--e),
        r = [];
      for (; t.node; ) r.push(t), (t = this.getSibling(--e));
      return r;
    }),
    (oT.getBindingIdentifierPaths = function () {
      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0],
        t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1],
        n = [this],
        a = Object.create(null);
      for (; n.length; ) {
        var s = n.shift();
        if (s && s.node) {
          var o = r.keys[s.node.type];
          if (s.isIdentifier())
            e
              ? (a[s.node.name] = a[s.node.name] || []).push(s)
              : (a[s.node.name] = s);
          else if (s.isExportDeclaration()) {
            var l = s.get("declaration");
            i(l) && n.push(l);
          } else {
            if (t) {
              if (s.isFunctionDeclaration()) {
                n.push(s.get("id"));
                continue;
              }
              if (s.isFunctionExpression()) continue;
            }
            if (o)
              for (var u = 0; u < o.length; u++) {
                var c = o[u],
                  p = s.get(c);
                Array.isArray(p) ? n.push.apply(n, K(p)) : p.node && n.push(p);
              }
          }
        }
      }
      return a;
    }),
    (oT.getBindingIdentifiers = function (e) {
      return r(this.node, e);
    }),
    (oT.getCompletionRecords = function () {
      return d(this, {
        canHaveBreak: !1,
        shouldPopulateBreak: !1,
        inCaseClause: !1,
      }).map(function (e) {
        return e.path;
      });
    }),
    (oT.getNextSibling = function () {
      return this.getSibling(this.key + 1);
    }),
    (oT.getOpposite = function () {
      if ("left" === this.key) return this.getSibling("right");
      if ("right" === this.key) return this.getSibling("left");
      return null;
    }),
    (oT.getOuterBindingIdentifierPaths = function () {
      var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
      return this.getBindingIdentifierPaths(e, !0);
    }),
    (oT.getOuterBindingIdentifiers = function (e) {
      return n(this.node, e);
    }),
    (oT.getPrevSibling = function () {
      return this.getSibling(this.key - 1);
    }),
    (oT.getSibling = function (t) {
      return e.default
        .get({
          parentPath: this.parentPath,
          parent: this.parent,
          container: this.container,
          listKey: this.listKey,
          key: t,
        })
        .setContext(this.context);
    });
  var e = HT(),
    t = mc(),
    r = t.getBindingIdentifiers,
    n = t.getOuterBindingIdentifiers,
    i = t.isDeclaration,
    a = t.numericLiteral,
    s = t.unaryExpression,
    o = 0,
    l = 1;
  function u(e, t, r) {
    return e && t.push.apply(t, K(d(e, r))), t;
  }
  function c(e) {
    e.forEach(function (e) {
      e.type = l;
    });
  }
  function p(e, t) {
    e.forEach(function (e) {
      e.path.isBreakStatement({ label: null }) &&
        (t ? e.path.replaceWith(s("void", a(0))) : e.path.remove());
    });
  }
  function h(e, t) {
    var r = [];
    if (t.canHaveBreak)
      for (var n = [], i = 0; i < e.length; i++) {
        var a = e[i],
          s = Object.assign({}, t, { inCaseClause: !1 });
        a.isBlockStatement() && (t.inCaseClause || t.shouldPopulateBreak)
          ? (s.shouldPopulateBreak = !0)
          : (s.shouldPopulateBreak = !1);
        var u = d(a, s);
        if (
          u.length > 0 &&
          u.every(function (e) {
            return e.type === l;
          })
        ) {
          n.length > 0 &&
          u.every(function (e) {
            return e.path.isBreakStatement({ label: null });
          })
            ? (c(n),
              r.push.apply(r, K(n)),
              n.some(function (e) {
                return e.path.isDeclaration();
              }) && (r.push.apply(r, K(u)), p(u, !0)),
              p(u, !1))
            : (r.push.apply(r, K(u)), t.shouldPopulateBreak || p(u, !0));
          break;
        }
        if (i === e.length - 1) r.push.apply(r, K(u));
        else {
          n = [];
          for (var h = 0; h < u.length; h++) {
            var f = u[h];
            f.type === l && r.push(f), f.type === o && n.push(f);
          }
        }
      }
    else if (e.length)
      for (var y = e.length - 1; y >= 0; y--) {
        var m = d(e[y], t);
        if (
          m.length > 1 ||
          (1 === m.length && !m[0].path.isVariableDeclaration())
        ) {
          r.push.apply(r, K(m));
          break;
        }
      }
    return r;
  }
  function d(e, t) {
    var r = [];
    if (e.isIfStatement())
      (r = u(e.get("consequent"), r, t)), (r = u(e.get("alternate"), r, t));
    else {
      if (
        e.isDoExpression() ||
        e.isFor() ||
        e.isWhile() ||
        e.isLabeledStatement()
      )
        return u(e.get("body"), r, t);
      if (e.isProgram() || e.isBlockStatement()) return h(e.get("body"), t);
      if (e.isFunction()) return d(e.get("body"), t);
      if (e.isTryStatement())
        (r = u(e.get("block"), r, t)), (r = u(e.get("handler"), r, t));
      else {
        if (e.isCatchClause()) return u(e.get("body"), r, t);
        if (e.isSwitchStatement())
          return (function (e, t, r) {
            for (var n = [], i = 0; i < e.length; i++) {
              var a,
                s = [],
                u = [],
                c = lT(d(e[i], r));
              try {
                for (c.s(); !(a = c.n()).done; ) {
                  var p = a.value;
                  p.type === o && s.push(p), p.type === l && u.push(p);
                }
              } catch (e) {
                c.e(e);
              } finally {
                c.f();
              }
              s.length && (n = s), t.push.apply(t, u);
            }
            return t.push.apply(t, K(n)), t;
          })(e.get("cases"), r, t);
        if (e.isSwitchCase())
          return h(e.get("consequent"), {
            canHaveBreak: !0,
            shouldPopulateBreak: !1,
            inCaseClause: !0,
          });
        e.isBreakStatement()
          ? r.push(
              (function (e) {
                return { type: l, path: e };
              })(e)
            )
          : r.push(
              (function (e) {
                return { type: o, path: e };
              })(e)
            );
      }
    }
    return r;
  }
  return oT;
}
var pT = {};
Object.defineProperty(pT, "__esModule", { value: !0 }),
  (pT.addComment = function (e, t, r) {
    dT(this.node, e, t, r);
  }),
  (pT.addComments = function (e, t) {
    fT(this.node, e, t);
  }),
  (pT.shareCommentsWithSiblings = function () {
    if ("string" == typeof this.key) return;
    var e = this.node;
    if (!e) return;
    var t = e.trailingComments,
      r = e.leadingComments;
    if (!t && !r) return;
    var n = this.getSibling(this.key - 1),
      i = this.getSibling(this.key + 1),
      a = Boolean(n.node),
      s = Boolean(i.node);
    a &&
      (r && n.addComments("trailing", yT(r, n.node.trailingComments)),
      t && !s && n.addComments("trailing", t));
    s &&
      (t && i.addComments("leading", yT(t, i.node.leadingComments)),
      r && !a && i.addComments("leading", r));
  });
var hT = mc(),
  dT = hT.addComment,
  fT = hT.addComments;
function yT(e, t) {
  if (!t) return e;
  var r = -1;
  return e.filter(function (e) {
    var n = t.indexOf(e, r);
    if (-1 === n) return !0;
    r = n;
  });
}
var mT = {};
Object.defineProperty(mT, "__esModule", { value: !0 }),
  (mT.isBindingIdentifier = function () {
    var e = this.node,
      t = this.parent,
      r = this.parentPath.parent;
    return CT(e) && ST(e, t, r);
  }),
  (mT.isBlockScoped = function () {
    return xT(this.node);
  }),
  (mT.isExistentialTypeParam = function () {
    throw new Error(
      "`path.isExistentialTypeParam` has been renamed to `path.isExistsTypeAnnotation()` in Babel 7."
    );
  }),
  (mT.isExpression = function () {
    return this.isIdentifier() ? this.isReferencedIdentifier() : PT(this.node);
  }),
  (mT.isFlow = function () {
    var e = this.node;
    return (
      !!AT(e) ||
      (IT(e)
        ? "type" === e.importKind || "typeof" === e.importKind
        : ET(e)
        ? "type" === e.exportKind
        : !!OT(e) && ("type" === e.importKind || "typeof" === e.importKind))
    );
  }),
  (mT.isForAwaitStatement = function () {
    return VT(this.node, { await: !0 });
  }),
  (mT.isGenerated = function () {
    return !this.isUser();
  }),
  (mT.isNumericLiteralTypeAnnotation = function () {
    throw new Error(
      "`path.isNumericLiteralTypeAnnotation()` has been renamed to `path.isNumberLiteralTypeAnnotation()` in Babel 7."
    );
  }),
  (mT.isPure = function (e) {
    return this.scope.isPure(this.node, e);
  }),
  (mT.isReferenced = function () {
    return MT(this.node, this.parent);
  }),
  (mT.isReferencedIdentifier = function (e) {
    var t = this.node,
      r = this.parent;
    if (!CT(t, e) && !_T(r, e)) {
      if (!NT(t, e)) return !1;
      if (KT(t.name)) return !1;
    }
    return MT(t, r, this.parentPath.parent);
  }),
  (mT.isReferencedMemberExpression = function () {
    var e = this.node,
      t = this.parent;
    return DT(e) && MT(e, t);
  }),
  (mT.isRestProperty = function () {
    return (
      LT(this.node) && this.parentPath && this.parentPath.isObjectPattern()
    );
  }),
  (mT.isScope = function () {
    return jT(this.node, this.parent);
  }),
  (mT.isSpreadProperty = function () {
    return (
      LT(this.node) && this.parentPath && this.parentPath.isObjectExpression()
    );
  }),
  (mT.isStatement = function () {
    var e = this.node,
      t = this.parent;
    if (FT(e)) {
      if (RT(e)) {
        if (wT(t, { left: e })) return !1;
        if (kT(t, { init: e })) return !1;
      }
      return !0;
    }
    return !1;
  }),
  (mT.isUser = function () {
    return this.node && !!this.node.loc;
  }),
  (mT.isVar = function () {
    return BT(this.node);
  });
var vT,
  gT,
  bT,
  TT = mc(),
  ST = TT.isBinding,
  xT = TT.isBlockScoped,
  ET = TT.isExportDeclaration,
  PT = TT.isExpression,
  AT = TT.isFlow,
  kT = TT.isForStatement,
  wT = TT.isForXStatement,
  CT = TT.isIdentifier,
  IT = TT.isImportDeclaration,
  OT = TT.isImportSpecifier,
  NT = TT.isJSXIdentifier,
  _T = TT.isJSXMemberExpression,
  DT = TT.isMemberExpression,
  LT = TT.isRestElement,
  MT = TT.isReferenced,
  jT = TT.isScope,
  FT = TT.isStatement,
  BT = TT.isVar,
  RT = TT.isVariableDeclaration,
  UT = TT.react,
  VT = TT.isForOfStatement,
  KT = UT.isCompatTag;
function WT(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return qT(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return qT(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function qT(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function HT() {
  if (vT) return Nf;
  (vT = 1),
    Object.defineProperty(Nf, "__esModule", { value: !0 }),
    (Nf.default = Nf.SHOULD_STOP = Nf.SHOULD_SKIP = Nf.REMOVED = void 0);
  var e = Zd,
    t = _f.exports,
    r = eS(),
    n = my(),
    i = mc(),
    a = i,
    s = bf,
    o = ai,
    l = vy,
    u = (function () {
      if (Py) return Ay;
      (Py = 1),
        Object.defineProperty(Ay, "__esModule", { value: !0 }),
        (Ay._getTypeAnnotation = function () {
          var t = this.node;
          if (t) {
            if (t.typeAnnotation) return t.typeAnnotation;
            if (!x.has(t)) {
              x.add(t);
              try {
                var n,
                  i = e[t.type];
                if (i) return i.call(this, t);
                if (null != (n = i = e[this.parentPath.type]) && n.validParent)
                  return this.parentPath.getTypeAnnotation();
              } finally {
                x.delete(t);
              }
            }
          } else if (
            "init" === this.key &&
            this.parentPath.isVariableDeclarator()
          ) {
            var a = this.parentPath.parentPath,
              s = a.parentPath;
            return "left" === a.key && s.isForInStatement()
              ? T()
              : "left" === a.key && s.isForOfStatement()
              ? r()
              : S();
          }
        }),
        (Ay.baseTypeStrictlyMatches = function (e) {
          var t = this.getTypeAnnotation(),
            r = e.getTypeAnnotation();
          return !(n(t) || !o(t)) && r.type === t.type;
        }),
        (Ay.couldBeBaseType = function (e) {
          var t = this.getTypeAnnotation();
          if (n(t)) return !0;
          if (g(t)) {
            var r,
              i = Ly(t.types);
            try {
              for (i.s(); !(r = i.n()).done; ) {
                var a = r.value;
                if (n(a) || E(e, a, !0)) return !0;
              }
            } catch (e) {
              i.e(e);
            } finally {
              i.f();
            }
            return !1;
          }
          return E(e, t, !0);
        }),
        (Ay.getTypeAnnotation = function () {
          var e = this.getData("typeAnnotation");
          return (
            null != e ||
              ((e = this._getTypeAnnotation() || r()),
              (v(e) || f(e)) && (e = e.typeAnnotation),
              this.setData("typeAnnotation", e)),
            e
          );
        }),
        (Ay.isBaseType = function (e, t) {
          return E(e, this.getTypeAnnotation(), t);
        }),
        (Ay.isGenericType = function (e) {
          var t = this.getTypeAnnotation();
          return (
            !("Array" !== e || !(d(t) || i(t) || m(t))) ||
            (l(t) && u(t.id, { name: e })) ||
            (y(t) && u(t.typeName, { name: e }))
          );
        });
      var e = Dy(),
        t = mc(),
        r = t.anyTypeAnnotation,
        n = t.isAnyTypeAnnotation,
        i = t.isArrayTypeAnnotation,
        a = t.isBooleanTypeAnnotation,
        s = t.isEmptyTypeAnnotation,
        o = t.isFlowBaseAnnotation,
        l = t.isGenericTypeAnnotation,
        u = t.isIdentifier,
        c = t.isMixedTypeAnnotation,
        p = t.isNumberTypeAnnotation,
        h = t.isStringTypeAnnotation,
        d = t.isTSArrayType,
        f = t.isTSTypeAnnotation,
        y = t.isTSTypeReference,
        m = t.isTupleTypeAnnotation,
        v = t.isTypeAnnotation,
        g = t.isUnionTypeAnnotation,
        b = t.isVoidTypeAnnotation,
        T = t.stringTypeAnnotation,
        S = t.voidTypeAnnotation,
        x = new WeakSet();
      function E(e, t, r) {
        if ("string" === e) return h(t);
        if ("number" === e) return p(t);
        if ("boolean" === e) return a(t);
        if ("any" === e) return n(t);
        if ("mixed" === e) return c(t);
        if ("empty" === e) return s(t);
        if ("void" === e) return b(t);
        if (r) return !1;
        throw new Error("Unknown base type ".concat(e));
      }
      return Ay;
    })(),
    c = (function () {
      if (Um) return jy;
      (Um = 1),
        Object.defineProperty(jy, "__esModule", { value: !0 }),
        (jy._replaceWith = function (e) {
          var t;
          if (!this.container) throw new ReferenceError("Container is falsy");
          this.inList
            ? A(this.parent, this.key, [e])
            : A(this.parent, this.key, e),
            this.debug("Replace with ".concat(null == e ? void 0 : e.type)),
            null == (t = n.path.get(this.parent)) ||
              t.set(e, this).delete(this.node),
            (this.node = this.container[this.key] = e);
        }),
        (jy.replaceExpressionWithStatements = function (e) {
          var r = this;
          this.resync();
          var n = P(e, this.scope);
          if (n) return this.replaceWith(n)[0].get("expressions");
          var i = this.getFunctionParent(),
            a = null == i ? void 0 : i.is("async"),
            f = null == i ? void 0 : i.is("generator"),
            m = l([], p(e));
          this.replaceWith(h(m, []));
          var v = this.get("callee");
          (0, s.default)(
            v.get("body"),
            function (e) {
              r.scope.push({ id: e });
            },
            "var"
          );
          var g,
            b = Ym(this.get("callee").getCompletionRecords());
          try {
            for (b.s(); !(g = b.n()).done; ) {
              var T = g.value;
              if (T.isExpressionStatement()) {
                var S = T.findParent(function (e) {
                  return e.isLoop();
                });
                if (S) {
                  var x = S.getData("expressionReplacementReturnUid");
                  x
                    ? (x = y(x.name))
                    : ((x = v.scope.generateDeclaredUidIdentifier("ret")),
                      v.get("body").pushContainer("body", E(d(x))),
                      S.setData("expressionReplacementReturnUid", x)),
                    T.get("expression").replaceWith(
                      u("=", d(x), T.node.expression)
                    );
                } else T.replaceWith(E(T.node.expression));
              }
            }
          } catch (e) {
            b.e(e);
          } finally {
            b.f();
          }
          v.arrowFunctionToExpression();
          var A = v,
            w =
              a &&
              t.default.hasType(
                this.get("callee.body").node,
                "AwaitExpression",
                o
              ),
            C =
              f &&
              t.default.hasType(
                this.get("callee.body").node,
                "YieldExpression",
                o
              );
          return (
            w && (A.set("async", !0), C || this.replaceWith(c(this.node))),
            C && (A.set("generator", !0), this.replaceWith(k(this.node, !0))),
            A.get("body.body")
          );
        }),
        (jy.replaceInline = function (e) {
          if ((this.resync(), Array.isArray(e))) {
            if (Array.isArray(this.container)) {
              e = this._verifyNodeList(e);
              var t = this._containerInsertAfter(e);
              return this.remove(), t;
            }
            return this.replaceWithMultiple(e);
          }
          return this.replaceWith(e);
        }),
        (jy.replaceWith = function (e) {
          if ((this.resync(), this.removed))
            throw new Error(
              "You can't replace this node, we've already removed it"
            );
          var t = e instanceof r.default ? e.node : e;
          if (!t)
            throw new Error(
              "You passed `path.replaceWith()` a falsy node, use `path.remove()` instead"
            );
          if (this.node === t) return [this];
          if (this.isProgram() && !T(t))
            throw new Error(
              "You can only replace a Program root node with another Program node"
            );
          if (Array.isArray(t))
            throw new Error(
              "Don't use `path.replaceWith()` with an array of nodes, use `path.replaceWithMultiple()`"
            );
          if ("string" == typeof t)
            throw new Error(
              "Don't use `path.replaceWith()` with a source string, use `path.replaceWithSourceString()`"
            );
          var n = "";
          if (
            (this.isNodeType("Statement") &&
              b(t) &&
              (this.canHaveVariableDeclarationOrExpression() ||
                this.canSwapBetweenExpressionAndStatement(t) ||
                this.parentPath.isExportDefaultDeclaration() ||
                ((t = f(t)), (n = "expression"))),
            this.isNodeType("Expression") &&
              S(t) &&
              !this.canHaveVariableDeclarationOrExpression() &&
              !this.canSwapBetweenExpressionAndStatement(t))
          )
            return this.replaceExpressionWithStatements([t]);
          var i = this.node;
          return (
            i && (g(t, i), x(i)),
            this._replaceWith(t),
            (this.type = t.type),
            this.setScope(),
            this.requeue(),
            [n ? this.get(n) : this]
          );
        }),
        (jy.replaceWithMultiple = function (e) {
          var t;
          this.resync(),
            (e = this._verifyNodeList(e)),
            m(e[0], this.node),
            v(e[e.length - 1], this.node),
            null == (t = n.path.get(this.parent)) || t.delete(this.node),
            (this.node = this.container[this.key] = null);
          var r = this.insertAfter(e);
          return this.node ? this.requeue() : this.remove(), r;
        }),
        (jy.replaceWithSourceString = function (r) {
          var n;
          this.resync();
          try {
            (r = "(".concat(r, ")")), (n = (0, i.parse)(r));
          } catch (t) {
            var a = t.loc;
            throw (
              (a &&
                ((t.message +=
                  " - make sure this is an expression.\n" +
                  (0, e.codeFrameColumns)(r, {
                    start: { line: a.line, column: a.column + 1 },
                  })),
                (t.code = "BABEL_REPLACE_SOURCE_ERROR")),
              t)
            );
          }
          var s = n.program.body[0].expression;
          return t.default.removeProperties(s), this.replaceWith(s);
        });
      var e = Fy,
        t = eS(),
        r = HT(),
        n = bf,
        i = qe,
        a = mc(),
        s = Fm,
        o = a.FUNCTION_TYPES,
        l = a.arrowFunctionExpression,
        u = a.assignmentExpression,
        c = a.awaitExpression,
        p = a.blockStatement,
        h = a.callExpression,
        d = a.cloneNode,
        f = a.expressionStatement,
        y = a.identifier,
        m = a.inheritLeadingComments,
        v = a.inheritTrailingComments,
        g = a.inheritsComments,
        b = a.isExpression,
        T = a.isProgram,
        S = a.isStatement,
        x = a.removeComments,
        E = a.returnStatement,
        P = a.toSequenceExpression,
        A = a.validate,
        k = a.yieldExpression;
      return jy;
    })(),
    p = Xm,
    h = iv,
    d = fb,
    f = (function () {
      if (Lb) return Mb;
      (Lb = 1),
        Object.defineProperty(Mb, "__esModule", { value: !0 }),
        (Mb._call = function (e) {
          if (!e) return !1;
          var t,
            r = jb(e);
          try {
            for (r.s(); !(t = r.n()).done; ) {
              var n = t.value;
              if (n) {
                var i = this.node;
                if (!i) return !0;
                var a = n.call(this.state, this, this.state);
                if (a && "object" === g(a) && "function" == typeof a.then)
                  throw new Error(
                    "You appear to be using a plugin with an async traversal visitor, which your current version of Babel does not support. If you're using a published plugin, you may need to upgrade your @babel/core version."
                  );
                if (a)
                  throw new Error(
                    "Unexpected return value from visitor method ".concat(n)
                  );
                if (this.node !== i) return !0;
                if (this._traverseFlags > 0) return !0;
              }
            }
          } catch (e) {
            r.e(e);
          } finally {
            r.f();
          }
          return !1;
        }),
        (Mb._getQueueContexts = function () {
          for (
            var e = this, t = this.contexts;
            !t.length && (e = e.parentPath);

          )
            t = e.contexts;
          return t;
        }),
        (Mb._resyncKey = function () {
          if (this.container && this.node !== this.container[this.key]) {
            if (Array.isArray(this.container)) {
              for (var e = 0; e < this.container.length; e++)
                if (this.container[e] === this.node) return void this.setKey(e);
            } else
              for (
                var t = 0, r = Object.keys(this.container);
                t < r.length;
                t++
              ) {
                var n = r[t];
                if (this.container[n] === this.node) return void this.setKey(n);
              }
            this.key = null;
          }
        }),
        (Mb._resyncList = function () {
          if (this.parent && this.inList) {
            var e = this.parent[this.listKey];
            this.container !== e && (this.container = e || null);
          }
        }),
        (Mb._resyncParent = function () {
          this.parentPath && (this.parent = this.parentPath.node);
        }),
        (Mb._resyncRemoved = function () {
          (null != this.key &&
            this.container &&
            this.container[this.key] === this.node) ||
            this._markRemoved();
        }),
        (Mb.call = function (e) {
          var t = this.opts;
          return (
            this.debug(e),
            !(!this.node || !this._call(t[e])) ||
              (!!this.node &&
                this._call(t[this.node.type] && t[this.node.type][e]))
          );
        }),
        (Mb.isBlacklisted = Mb.isDenylisted =
          function () {
            var e,
              t = null != (e = this.opts.denylist) ? e : this.opts.blacklist;
            return t && t.indexOf(this.node.type) > -1;
          }),
        (Mb.popContext = function () {
          this.contexts.pop(),
            this.contexts.length > 0
              ? this.setContext(this.contexts[this.contexts.length - 1])
              : this.setContext(void 0);
        }),
        (Mb.pushContext = function (e) {
          this.contexts.push(e), this.setContext(e);
        }),
        (Mb.requeue = function () {
          var e =
            arguments.length > 0 && void 0 !== arguments[0]
              ? arguments[0]
              : this;
          if (!e.removed) {
            var t,
              r = jb(this.contexts);
            try {
              for (r.s(); !(t = r.n()).done; ) t.value.maybeQueue(e);
            } catch (e) {
              r.e(e);
            } finally {
              r.f();
            }
          }
        }),
        (Mb.resync = function () {
          this.removed ||
            (this._resyncParent(), this._resyncList(), this._resyncKey());
        }),
        (Mb.setContext = function (e) {
          return (
            null != this.skipKeys && (this.skipKeys = {}),
            (this._traverseFlags = 0),
            e &&
              ((this.context = e),
              (this.state = e.state),
              (this.opts = e.opts)),
            this.setScope(),
            this
          );
        }),
        (Mb.setKey = function (e) {
          var t;
          (this.key = e),
            (this.node = this.container[this.key]),
            (this.type = null == (t = this.node) ? void 0 : t.type);
        }),
        (Mb.setScope = function () {
          var e, t;
          if (null == (e = this.opts) || !e.noScope) {
            var r,
              n = this.parentPath;
            for (
              ((("key" === this.key || "decorators" === this.listKey) &&
                n.isMethod()) ||
                ("discriminant" === this.key && n.isSwitchStatement())) &&
              (n = n.parentPath);
              n && !r;

            ) {
              var i;
              if (null != (i = n.opts) && i.noScope) return;
              (r = n.scope), (n = n.parentPath);
            }
            (this.scope = this.getScope(r)),
              null == (t = this.scope) || t.init();
          }
        }),
        (Mb.setup = function (e, t, r, n) {
          (this.listKey = r),
            (this.container = t),
            (this.parentPath = e || this.parentPath),
            this.setKey(n);
        }),
        (Mb.skip = function () {
          this.shouldSkip = !0;
        }),
        (Mb.skipKey = function (e) {
          null == this.skipKeys && (this.skipKeys = {}),
            (this.skipKeys[e] = !0);
        }),
        (Mb.stop = function () {
          this._traverseFlags |= t.SHOULD_SKIP | t.SHOULD_STOP;
        }),
        (Mb.visit = function () {
          var t, n;
          if (!this.node) return !1;
          if (this.isDenylisted()) return !1;
          if (null != (t = (n = this.opts).shouldSkip) && t.call(n, this))
            return !1;
          var i = this.context;
          return this.shouldSkip || this.call("enter")
            ? (this.debug("Skip..."), this.shouldStop)
            : (r(this, i),
              this.debug("Recursing into..."),
              (this.shouldStop = (0, e.traverseNode)(
                this.node,
                this.opts,
                this.scope,
                this.state,
                this,
                this.skipKeys
              )),
              r(this, i),
              this.call("exit"),
              this.shouldStop);
        });
      var e = zT(),
        t = HT();
      function r(e, t) {
        e.context !== t &&
          ((e.context = t), (e.state = t.state), (e.opts = t.opts));
      }
      return Mb;
    })(),
    y = (function () {
      if (Ub) return Bb;
      (Ub = 1),
        Object.defineProperty(Bb, "__esModule", { value: !0 }),
        (Bb._assertUnremoved = function () {
          if (this.removed)
            throw this.buildCodeFrameError(
              "NodePath has been removed so is read-only."
            );
        }),
        (Bb._callRemovalHooks = function () {
          var t,
            r = Vb(e.hooks);
          try {
            for (r.s(); !(t = r.n()).done; )
              if ((0, t.value)(this, this.parentPath)) return !0;
          } catch (e) {
            r.e(e);
          } finally {
            r.f();
          }
        }),
        (Bb._markRemoved = function () {
          (this._traverseFlags |= r.SHOULD_SKIP | r.REMOVED),
            this.parent && t.path.get(this.parent).delete(this.node),
            (this.node = null);
        }),
        (Bb._remove = function () {
          Array.isArray(this.container)
            ? (this.container.splice(this.key, 1),
              this.updateSiblingKeys(this.key, -1))
            : this._replaceWith(null);
        }),
        (Bb._removeFromScope = function () {
          var e = this,
            t = this.getBindingIdentifiers();
          Object.keys(t).forEach(function (t) {
            return e.scope.removeBinding(t);
          });
        }),
        (Bb.remove = function () {
          var e;
          this._assertUnremoved(),
            this.resync(),
            (null != (e = this.opts) && e.noScope) || this._removeFromScope(),
            this._callRemovalHooks() ||
              (this.shareCommentsWithSiblings(), this._remove()),
            this._markRemoved();
        });
      var e = Rb,
        t = bf,
        r = HT();
      return Bb;
    })(),
    m = aT(),
    v = cT(),
    b = pT,
    T = mT,
    S = i.validate,
    x = t("babel");
  Nf.REMOVED = 1;
  Nf.SHOULD_STOP = 2;
  Nf.SHOULD_SKIP = 4;
  var P = (function () {
    function e(t, r) {
      E(this, e),
        (this.contexts = []),
        (this.state = null),
        (this.opts = null),
        (this._traverseFlags = 0),
        (this.skipKeys = null),
        (this.parentPath = null),
        (this.container = null),
        (this.listKey = null),
        (this.key = null),
        (this.node = null),
        (this.type = null),
        (this.parent = r),
        (this.hub = t),
        (this.data = null),
        (this.context = null),
        (this.scope = null);
    }
    return (
      A(
        e,
        [
          {
            key: "getScope",
            value: function (e) {
              return this.isScope() ? new n.default(this) : e;
            },
          },
          {
            key: "setData",
            value: function (e, t) {
              return (
                null == this.data && (this.data = Object.create(null)),
                (this.data[e] = t)
              );
            },
          },
          {
            key: "getData",
            value: function (e, t) {
              null == this.data && (this.data = Object.create(null));
              var r = this.data[e];
              return void 0 === r && void 0 !== t && (r = this.data[e] = t), r;
            },
          },
          {
            key: "hasNode",
            value: function () {
              return null != this.node;
            },
          },
          {
            key: "buildCodeFrameError",
            value: function (e) {
              var t =
                arguments.length > 1 && void 0 !== arguments[1]
                  ? arguments[1]
                  : SyntaxError;
              return this.hub.buildError(this.node, e, t);
            },
          },
          {
            key: "traverse",
            value: function (e, t) {
              (0, r.default)(this.node, e, this.scope, t, this);
            },
          },
          {
            key: "set",
            value: function (e, t) {
              S(this.node, e, t), (this.node[e] = t);
            },
          },
          {
            key: "getPathLocation",
            value: function () {
              var e = [],
                t = this;
              do {
                var r = t.key;
                t.inList && (r = "".concat(t.listKey, "[").concat(r, "]")),
                  e.unshift(r);
              } while ((t = t.parentPath));
              return e.join(".");
            },
          },
          {
            key: "debug",
            value: function (e) {
              x.enabled &&
                x(
                  ""
                    .concat(this.getPathLocation(), " ")
                    .concat(this.type, ": ")
                    .concat(e)
                );
            },
          },
          {
            key: "toString",
            value: function () {
              return (0, o.default)(this.node).code;
            },
          },
          {
            key: "inList",
            get: function () {
              return !!this.listKey;
            },
            set: function (e) {
              e || (this.listKey = null);
            },
          },
          {
            key: "parentKey",
            get: function () {
              return this.listKey || this.key;
            },
          },
          {
            key: "shouldSkip",
            get: function () {
              return !!(4 & this._traverseFlags);
            },
            set: function (e) {
              e ? (this._traverseFlags |= 4) : (this._traverseFlags &= -5);
            },
          },
          {
            key: "shouldStop",
            get: function () {
              return !!(2 & this._traverseFlags);
            },
            set: function (e) {
              e ? (this._traverseFlags |= 2) : (this._traverseFlags &= -3);
            },
          },
          {
            key: "removed",
            get: function () {
              return !!(1 & this._traverseFlags);
            },
            set: function (e) {
              e ? (this._traverseFlags |= 1) : (this._traverseFlags &= -2);
            },
          },
        ],
        [
          {
            key: "get",
            value: function (t) {
              var r = t.hub,
                n = t.parentPath,
                i = t.parent,
                a = t.container,
                o = t.listKey,
                l = t.key;
              if ((!r && n && (r = n.hub), !i))
                throw new Error("To get a node path the parent needs to exist");
              var u = a[l],
                c = s.path.get(i);
              c || ((c = new Map()), s.path.set(i, c));
              var p = c.get(u);
              return (
                p || ((p = new e(r, i)), u && c.set(u, p)),
                p.setup(n, a, o, l),
                p
              );
            },
          },
        ]
      ),
      e
    );
  })();
  Object.assign(P.prototype, l, u, c, p, h, d, f, y, m, v, b),
    (P.prototype._guessExecutionStatusRelativeToDifferentFunctions =
      d._guessExecutionStatusRelativeTo);
  var k,
    w = WT(a.TYPES);
  try {
    var C = function () {
      var e = k.value,
        t = "is".concat(e),
        r = a[t];
      (P.prototype[t] = function (e) {
        return r(this.node, e);
      }),
        (P.prototype["assert".concat(e)] = function (t) {
          if (!r(this.node, t))
            throw new TypeError("Expected node path of type ".concat(e));
        });
    };
    for (w.s(); !(k = w.n()).done; ) C();
  } catch (e) {
    w.e(e);
  } finally {
    w.f();
  }
  Object.assign(P.prototype, T);
  for (var I = 0, O = Object.keys(e); I < O.length; I++) {
    var N = O[I];
    "_" !== N[0] && (a.TYPES.includes(N) || a.TYPES.push(N));
  }
  var _ = P;
  return (Nf.default = _), Nf;
}
function YT(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return JT(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return JT(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function JT(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function XT(e, t) {
  var r =
    ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
  if (!r) {
    if (
      Array.isArray(e) ||
      (r = (function (e, t) {
        if (!e) return;
        if ("string" == typeof e) return GT(e, t);
        var r = Object.prototype.toString.call(e).slice(8, -1);
        "Object" === r && e.constructor && (r = e.constructor.name);
        if ("Map" === r || "Set" === r) return Array.from(e);
        if (
          "Arguments" === r ||
          /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(r)
        )
          return GT(e, t);
      })(e)) ||
      (t && e && "number" == typeof e.length)
    ) {
      r && (e = r);
      var n = 0,
        i = function () {};
      return {
        s: i,
        n: function () {
          return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
        },
        e: function (e) {
          throw e;
        },
        f: i,
      };
    }
    throw new TypeError(
      "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
    );
  }
  var a,
    s = !0,
    o = !1;
  return {
    s: function () {
      r = r.call(e);
    },
    n: function () {
      var e = r.next();
      return (s = e.done), e;
    },
    e: function (e) {
      (o = !0), (a = e);
    },
    f: function () {
      try {
        s || null == r.return || r.return();
      } finally {
        if (o) throw a;
      }
    },
  };
}
function GT(e, t) {
  (null == t || t > e.length) && (t = e.length);
  for (var r = 0, n = new Array(t); r < t; r++) n[r] = e[r];
  return n;
}
function zT() {
  if (bT) return If;
  (bT = 1),
    Object.defineProperty(If, "__esModule", { value: !0 }),
    (If.traverseNode = function (r, n, i, a, s, o) {
      var l = t[r.type];
      if (!l) return !1;
      var u,
        c = new e.default(i, n, a, s),
        p = XT(l);
      try {
        for (p.s(); !(u = p.n()).done; ) {
          var h = u.value;
          if ((!o || !o[h]) && c.visit(r, h)) return !0;
        }
      } catch (e) {
        p.e(e);
      } finally {
        p.f();
      }
      return !1;
    });
  var e = (function () {
      if (gT) return Of;
      (gT = 1),
        Object.defineProperty(Of, "__esModule", { value: !0 }),
        (Of.default = void 0);
      var e = HT(),
        t = mc().VISITOR_KEYS,
        r = (function () {
          function r(e, t, n, i) {
            E(this, r),
              (this.queue = null),
              (this.priorityQueue = null),
              (this.parentPath = i),
              (this.scope = e),
              (this.state = n),
              (this.opts = t);
          }
          return (
            A(r, [
              {
                key: "shouldVisit",
                value: function (e) {
                  var r = this.opts;
                  if (r.enter || r.exit) return !0;
                  if (r[e.type]) return !0;
                  var n = t[e.type];
                  if (null == n || !n.length) return !1;
                  var i,
                    a = YT(n);
                  try {
                    for (a.s(); !(i = a.n()).done; ) if (e[i.value]) return !0;
                  } catch (e) {
                    a.e(e);
                  } finally {
                    a.f();
                  }
                  return !1;
                },
              },
              {
                key: "create",
                value: function (t, r, n, i) {
                  return e.default.get({
                    parentPath: this.parentPath,
                    parent: t,
                    container: r,
                    key: n,
                    listKey: i,
                  });
                },
              },
              {
                key: "maybeQueue",
                value: function (e, t) {
                  this.queue &&
                    (t ? this.queue.push(e) : this.priorityQueue.push(e));
                },
              },
              {
                key: "visitMultiple",
                value: function (e, t, r) {
                  if (0 === e.length) return !1;
                  for (var n = [], i = 0; i < e.length; i++) {
                    var a = e[i];
                    a && this.shouldVisit(a) && n.push(this.create(t, e, i, r));
                  }
                  return this.visitQueue(n);
                },
              },
              {
                key: "visitSingle",
                value: function (e, t) {
                  return (
                    !!this.shouldVisit(e[t]) &&
                    this.visitQueue([this.create(e, e, t)])
                  );
                },
              },
              {
                key: "visitQueue",
                value: function (e) {
                  (this.queue = e), (this.priorityQueue = []);
                  var t,
                    r = new WeakSet(),
                    n = !1,
                    i = YT(e);
                  try {
                    for (i.s(); !(t = i.n()).done; ) {
                      var a = t.value;
                      if (
                        (a.resync(),
                        (0 !== a.contexts.length &&
                          a.contexts[a.contexts.length - 1] === this) ||
                          a.pushContext(this),
                        null !== a.key)
                      ) {
                        var s = a.node;
                        if (!r.has(s)) {
                          if ((s && r.add(s), a.visit())) {
                            n = !0;
                            break;
                          }
                          if (
                            this.priorityQueue.length &&
                            ((n = this.visitQueue(this.priorityQueue)),
                            (this.priorityQueue = []),
                            (this.queue = e),
                            n)
                          )
                            break;
                        }
                      }
                    }
                  } catch (e) {
                    i.e(e);
                  } finally {
                    i.f();
                  }
                  var o,
                    l = YT(e);
                  try {
                    for (l.s(); !(o = l.n()).done; ) o.value.popContext();
                  } catch (e) {
                    l.e(e);
                  } finally {
                    l.f();
                  }
                  return (this.queue = null), n;
                },
              },
              {
                key: "visit",
                value: function (e, t) {
                  var r = e[t];
                  return (
                    !!r &&
                    (Array.isArray(r)
                      ? this.visitMultiple(r, e, t)
                      : this.visitSingle(e, t))
                  );
                },
              },
            ]),
            r
          );
        })();
      return (Of.default = r), Of;
    })(),
    t = mc().VISITOR_KEYS;
  return If;
}
var $T = {};
Object.defineProperty($T, "__esModule", { value: !0 }), ($T.default = void 0);
var QT,
  ZT = (function () {
    function e() {
      E(this, e);
    }
    return (
      A(e, [
        { key: "getCode", value: function () {} },
        { key: "getScope", value: function () {} },
        {
          key: "addHelper",
          value: function () {
            throw new Error("Helpers are not supported by the default hub.");
          },
        },
        {
          key: "buildError",
          value: function (e, t) {
            return new (
              arguments.length > 2 && void 0 !== arguments[2]
                ? arguments[2]
                : TypeError
            )(t);
          },
        },
      ]),
      e
    );
  })();
function eS() {
  return (
    QT ||
      ((QT = 1),
      (function (e) {
        Object.defineProperty(e, "__esModule", { value: !0 }),
          Object.defineProperty(e, "Hub", {
            enumerable: !0,
            get: function () {
              return o.default;
            },
          }),
          Object.defineProperty(e, "NodePath", {
            enumerable: !0,
            get: function () {
              return a.default;
            },
          }),
          Object.defineProperty(e, "Scope", {
            enumerable: !0,
            get: function () {
              return s.default;
            },
          }),
          (e.visitors = e.default = void 0);
        var t = Qd;
        e.visitors = t;
        var r = mc(),
          n = bf,
          i = zT(),
          a = HT(),
          s = my(),
          o = $T,
          l = r.VISITOR_KEYS,
          u = r.removeProperties,
          c = r.traverseFast;
        function p(e) {
          var r =
              arguments.length > 1 && void 0 !== arguments[1]
                ? arguments[1]
                : {},
            n = arguments.length > 2 ? arguments[2] : void 0,
            a = arguments.length > 3 ? arguments[3] : void 0,
            s = arguments.length > 4 ? arguments[4] : void 0;
          if (e) {
            if (!r.noScope && !n && "Program" !== e.type && "File" !== e.type)
              throw new Error(
                "You must pass a scope and parentPath unless traversing a Program/File. " +
                  "Instead of that you tried to traverse a ".concat(
                    e.type,
                    " node without "
                  ) +
                  "passing scope and parentPath."
              );
            l[e.type] && (t.explode(r), (0, i.traverseNode)(e, r, n, a, s));
          }
        }
        var h = p;
        function d(e, t) {
          e.node.type === t.type && ((t.has = !0), e.stop());
        }
        (e.default = h),
          (p.visitors = t),
          (p.verify = t.verify),
          (p.explode = t.explode),
          (p.cheap = function (e, t) {
            c(e, t);
          }),
          (p.node = function (e, t, r, n, a, s) {
            (0, i.traverseNode)(e, t, r, n, a, s);
          }),
          (p.clearNode = function (e, t) {
            u(e, t), n.path.delete(e);
          }),
          (p.removeProperties = function (e, t) {
            return c(e, p.clearNode, t), e;
          }),
          (p.hasType = function (e, t, r) {
            if (null != r && r.includes(e.type)) return !1;
            if (e.type === t) return !0;
            var n = { has: !1, type: t };
            return p(e, { noScope: !0, denylist: r, enter: d }, null, n), n.has;
          }),
          (p.cache = n);
      })($d)),
    $d
  );
}
$T.default = ZT;
var tS = eS().default;
function rS(e) {
  return !!/[\u4E00-\u9FA5]+/.test(e.trim());
}
var nS = function (e) {
    var t = e.inputDir,
      r = e.extname,
      n = e.intlFunName;
    e.localFunDir,
      zd(t, r, function (e) {
        var t = u.default.readFileSync(e, { encoding: "utf-8" }),
          r = ni(t, {
            sourceType: "module",
            plugins: ["jsx", "typescript", "decorators"],
          });
        !(function (e, t, r) {
          tS(e, {
            StringLiteral: {
              enter: function (e) {
                if (rS(e.node.value)) {
                  var r = e.parentPath;
                  r.isImportDeclaration() ||
                    (r.isCallExpression() &&
                      "Identifier" === r.node.callee.type &&
                      r.node.callee.name === t) ||
                    (r.isJSXAttribute()
                      ? e.replaceWith(
                          Gd.jsxExpressionContainer(
                            Gd.callExpression(Gd.identifier(t), [
                              Gd.stringLiteral(e.node.value),
                            ])
                          )
                        )
                      : e.replaceWith(
                          Gd.callExpression(Gd.identifier(t), [
                            Gd.stringLiteral(e.node.value),
                          ])
                        ));
                }
              },
            },
            JSXText: {
              enter: function (e) {
                rS(e.node.value) &&
                  e.replaceWith(
                    Gd.jsxExpressionContainer(
                      Gd.callExpression(Gd.identifier(t), [
                        Gd.stringLiteral(e.node.value.trim()),
                      ])
                    )
                  );
              },
            },
            ImportDefaultSpecifier: {
              enter: function (e) {
                e.node.local.name;
              },
            },
            Program: { exit: function (e) {} },
          });
        })(r, "".concat(n));
        var i = qd(r, { jsescOption: { minimal: !0 } });
        u.default.writeFileSync(e, i.code, { encoding: "utf-8" });
      });
  },
  iS = (function () {
    var e = q(
      G.mark(function e(t) {
        var r, n, i, a, s, o, l, c, p, d, f;
        return G.wrap(function (e) {
          for (;;)
            switch ((e.prev = e.next)) {
              case 0:
                if (
                  ((r = t.inputDir),
                  (n = t.extname),
                  (i = t.intlFunName),
                  (a = t.localFunDir),
                  (s = t.targetLanguage),
                  (o = t.ignoreCache),
                  (l = require(h.default.resolve(a, "request"))),
                  (c = new Set()),
                  zd(r, n, function (e) {
                    console.log("dfsFile ---\x3e filePath:", e);
                    var t = u.default.readFileSync(e, { encoding: "utf-8" }),
                      r = ni(t, {
                        sourceType: "module",
                        plugins: ["jsx", "typescript", "decorators"],
                      });
                    tS(r, {
                      StringLiteral: {
                        enter: function (e) {
                          var t = e.parentPath;
                          t.isCallExpression() &&
                            "Identifier" === t.node.callee.type &&
                            t.node.callee.name === i &&
                            c.add(e.node.value);
                        },
                      },
                    });
                  }),
                  (p = {}),
                  (d = {}),
                  !o)
                )
                  try {
                    p = JSON.parse(
                      u.default.readFileSync(
                        h.default.resolve(a, "".concat(s, ".json")),
                        { encoding: "utf-8" }
                      )
                    );
                  } catch (e) {
                    p = {};
                  }
                return (
                  Object.keys(p).forEach(function (e) {
                    c.has(e) && c.delete(e);
                  }),
                  (e.next = 10),
                  l(K(c), s)
                );
              case 10:
                (f = e.sent),
                  console.log("translatedWords22222222222222:", f),
                  K(c).forEach(function (e, t) {
                    var r = f[t].charAt(0).toUpperCase() + f[t].slice(1);
                    (p[e] = r.split("_").join(" ")), (d[e] = e);
                  }),
                  u.default.writeFileSync(
                    h.default.resolve(a, "".concat(s, ".json")),
                    JSON.stringify(p)
                  ),
                  u.default.writeFileSync(
                    h.default.resolve(a, "zh-CN.json"),
                    JSON.stringify(d)
                  );
              case 15:
              case "end":
                return e.stop();
            }
        }, e);
      })
    );
    return function (t) {
      return e.apply(this, arguments);
    };
  })(),
  aS = ["replaceWord", "ignoreCache", "targetLanguage"];
function sS(e, t) {
  var r = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var n = Object.getOwnPropertySymbols(e);
    t &&
      (n = n.filter(function (t) {
        return Object.getOwnPropertyDescriptor(e, t).enumerable;
      })),
      r.push.apply(r, n);
  }
  return r;
}
function oS(e) {
  for (var t = 1; t < arguments.length; t++) {
    var r = null != arguments[t] ? arguments[t] : {};
    t % 2
      ? sS(Object(r), !0).forEach(function (t) {
          T(e, t, r[t]);
        })
      : Object.getOwnPropertyDescriptors
      ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(r))
      : sS(Object(r)).forEach(function (t) {
          Object.defineProperty(e, t, Object.getOwnPropertyDescriptor(r, t));
        });
  }
  return e;
}
var lS = {
  inputDir: "./src",
  extname: [".ts", ".tsx"],
  intlFunName: "i18n",
  localFunDir: "./locals",
  targetLanguage: "en-US",
  replaceWord: !0,
};
ke.name("i18n_tool").description("transform language cli"),
  console.log("__dirname:", __dirname),
  ke.option("-c <string>", "set config file path").action(function (e) {
    console.log("program.option ---\x3e path:", e);
    var t = lS;
    try {
      t = oS(
        oS({}, t),
        JSON.parse(u.default.readFileSync(e.c, { encoding: "utf-8" }))
      );
    } catch (e) {
      console.error("program.option ---\x3e error:", e), (t = lS);
    }
    var r = t,
      n = r.replaceWord,
      i = r.ignoreCache,
      a = r.targetLanguage,
      s = v(r, aS);
    console.log("program.option ---\x3e userConfig:", t),
      n && nS(s),
      iS(oS(oS({}, s), {}, { targetLanguage: a, ignoreCache: i }));
  }),
  ke.parse(process.argv);
